var ApiHeader;
(function (ApiHeader) {
    var SessionInventory = (function () {
        function SessionInventory() {
        }
        return SessionInventory;
    })();
    ApiHeader.SessionInventory = SessionInventory;
    var APISilentMsg = (function () {
        function APISilentMsg() {
        }
        APISilentMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.test.multinodes.APISilentMsg': this
            };
            return msg;
        };
        return APISilentMsg;
    })();
    ApiHeader.APISilentMsg = APISilentMsg;
    var FakePolicyAllowMsg = (function () {
        function FakePolicyAllowMsg() {
        }
        FakePolicyAllowMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.test.identity.FakePolicyAllowMsg': this
            };
            return msg;
        };
        return FakePolicyAllowMsg;
    })();
    ApiHeader.FakePolicyAllowMsg = FakePolicyAllowMsg;
    var FakePolicyDenyMsg = (function () {
        function FakePolicyDenyMsg() {
        }
        FakePolicyDenyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.test.identity.FakePolicyDenyMsg': this
            };
            return msg;
        };
        return FakePolicyDenyMsg;
    })();
    ApiHeader.FakePolicyDenyMsg = FakePolicyDenyMsg;
    var FakePolicyAllowHas2RoleMsg = (function () {
        function FakePolicyAllowHas2RoleMsg() {
        }
        FakePolicyAllowHas2RoleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.test.identity.FakePolicyAllowHas2RoleMsg': this
            };
            return msg;
        };
        return FakePolicyAllowHas2RoleMsg;
    })();
    ApiHeader.FakePolicyAllowHas2RoleMsg = FakePolicyAllowHas2RoleMsg;
    var QueryCondition = (function () {
        function QueryCondition() {
        }
        return QueryCondition;
    })();
    ApiHeader.QueryCondition = QueryCondition;
    var APIQueryGlobalConfigMsg = (function () {
        function APIQueryGlobalConfigMsg() {
        }
        APIQueryGlobalConfigMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.core.config.APIQueryGlobalConfigMsg': this
            };
            return msg;
        };
        return APIQueryGlobalConfigMsg;
    })();
    ApiHeader.APIQueryGlobalConfigMsg = APIQueryGlobalConfigMsg;
    var APIListGlobalConfigMsg = (function () {
        function APIListGlobalConfigMsg() {
        }
        APIListGlobalConfigMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.core.config.APIListGlobalConfigMsg': this
            };
            return msg;
        };
        return APIListGlobalConfigMsg;
    })();
    ApiHeader.APIListGlobalConfigMsg = APIListGlobalConfigMsg;
    var APIGetGlobalConfigMsg = (function () {
        function APIGetGlobalConfigMsg() {
        }
        APIGetGlobalConfigMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.core.config.APIGetGlobalConfigMsg': this
            };
            return msg;
        };
        return APIGetGlobalConfigMsg;
    })();
    ApiHeader.APIGetGlobalConfigMsg = APIGetGlobalConfigMsg;
    var APIUpdateGlobalConfigMsg = (function () {
        function APIUpdateGlobalConfigMsg() {
        }
        APIUpdateGlobalConfigMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.core.config.APIUpdateGlobalConfigMsg': this
            };
            return msg;
        };
        return APIUpdateGlobalConfigMsg;
    })();
    ApiHeader.APIUpdateGlobalConfigMsg = APIUpdateGlobalConfigMsg;
    var APIGenerateInventoryQueryDetailsMsg = (function () {
        function APIGenerateInventoryQueryDetailsMsg() {
        }
        APIGenerateInventoryQueryDetailsMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.query.APIGenerateInventoryQueryDetailsMsg': this
            };
            return msg;
        };
        return APIGenerateInventoryQueryDetailsMsg;
    })();
    ApiHeader.APIGenerateInventoryQueryDetailsMsg = APIGenerateInventoryQueryDetailsMsg;
    var APIGenerateQueryableFieldsMsg = (function () {
        function APIGenerateQueryableFieldsMsg() {
        }
        APIGenerateQueryableFieldsMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.query.APIGenerateQueryableFieldsMsg': this
            };
            return msg;
        };
        return APIGenerateQueryableFieldsMsg;
    })();
    ApiHeader.APIGenerateQueryableFieldsMsg = APIGenerateQueryableFieldsMsg;
    var APIGetHostAllocatorStrategiesMsg = (function () {
        function APIGetHostAllocatorStrategiesMsg() {
        }
        APIGetHostAllocatorStrategiesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.allocator.APIGetHostAllocatorStrategiesMsg': this
            };
            return msg;
        };
        return APIGetHostAllocatorStrategiesMsg;
    })();
    ApiHeader.APIGetHostAllocatorStrategiesMsg = APIGetHostAllocatorStrategiesMsg;
    var APIGetCpuMemoryCapacityMsg = (function () {
        function APIGetCpuMemoryCapacityMsg() {
        }
        APIGetCpuMemoryCapacityMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.allocator.APIGetCpuMemoryCapacityMsg': this
            };
            return msg;
        };
        return APIGetCpuMemoryCapacityMsg;
    })();
    ApiHeader.APIGetCpuMemoryCapacityMsg = APIGetCpuMemoryCapacityMsg;
    var APIUpdateVmInstanceMsg = (function () {
        function APIUpdateVmInstanceMsg() {
        }
        APIUpdateVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIUpdateVmInstanceMsg': this
            };
            return msg;
        };
        return APIUpdateVmInstanceMsg;
    })();
    ApiHeader.APIUpdateVmInstanceMsg = APIUpdateVmInstanceMsg;
    var APIGetVmAttachableL3NetworkMsg = (function () {
        function APIGetVmAttachableL3NetworkMsg() {
        }
        APIGetVmAttachableL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIGetVmAttachableL3NetworkMsg': this
            };
            return msg;
        };
        return APIGetVmAttachableL3NetworkMsg;
    })();
    ApiHeader.APIGetVmAttachableL3NetworkMsg = APIGetVmAttachableL3NetworkMsg;
    var APIMigrateVmMsg = (function () {
        function APIMigrateVmMsg() {
        }
        APIMigrateVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIMigrateVmMsg': this
            };
            return msg;
        };
        return APIMigrateVmMsg;
    })();
    ApiHeader.APIMigrateVmMsg = APIMigrateVmMsg;
    var APIStopVmInstanceMsg = (function () {
        function APIStopVmInstanceMsg() {
        }
        APIStopVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIStopVmInstanceMsg': this
            };
            return msg;
        };
        return APIStopVmInstanceMsg;
    })();
    ApiHeader.APIStopVmInstanceMsg = APIStopVmInstanceMsg;
    var APIChangeInstanceOfferingMsg = (function () {
        function APIChangeInstanceOfferingMsg() {
        }
        APIChangeInstanceOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIChangeInstanceOfferingMsg': this
            };
            return msg;
        };
        return APIChangeInstanceOfferingMsg;
    })();
    ApiHeader.APIChangeInstanceOfferingMsg = APIChangeInstanceOfferingMsg;
    var NOVTriple = (function () {
        function NOVTriple() {
        }
        return NOVTriple;
    })();
    ApiHeader.NOVTriple = NOVTriple;
    var NOLTriple = (function () {
        function NOLTriple() {
        }
        return NOLTriple;
    })();
    ApiHeader.NOLTriple = NOLTriple;
    var APISearchVmInstanceMsg = (function () {
        function APISearchVmInstanceMsg() {
        }
        APISearchVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APISearchVmInstanceMsg': this
            };
            return msg;
        };
        return APISearchVmInstanceMsg;
    })();
    ApiHeader.APISearchVmInstanceMsg = APISearchVmInstanceMsg;
    var APIGetVmAttachableDataVolumeMsg = (function () {
        function APIGetVmAttachableDataVolumeMsg() {
        }
        APIGetVmAttachableDataVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIGetVmAttachableDataVolumeMsg': this
            };
            return msg;
        };
        return APIGetVmAttachableDataVolumeMsg;
    })();
    ApiHeader.APIGetVmAttachableDataVolumeMsg = APIGetVmAttachableDataVolumeMsg;
    var APIQueryVmNicMsg = (function () {
        function APIQueryVmNicMsg() {
        }
        APIQueryVmNicMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIQueryVmNicMsg': this
            };
            return msg;
        };
        return APIQueryVmNicMsg;
    })();
    ApiHeader.APIQueryVmNicMsg = APIQueryVmNicMsg;
    var APIAttachL3NetworkToVmMsg = (function () {
        function APIAttachL3NetworkToVmMsg() {
        }
        APIAttachL3NetworkToVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIAttachL3NetworkToVmMsg': this
            };
            return msg;
        };
        return APIAttachL3NetworkToVmMsg;
    })();
    ApiHeader.APIAttachL3NetworkToVmMsg = APIAttachL3NetworkToVmMsg;
    var APIDestroyVmInstanceMsg = (function () {
        function APIDestroyVmInstanceMsg() {
        }
        APIDestroyVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIDestroyVmInstanceMsg': this
            };
            return msg;
        };
        return APIDestroyVmInstanceMsg;
    })();
    ApiHeader.APIDestroyVmInstanceMsg = APIDestroyVmInstanceMsg;
    var APIGetVmMigrationCandidateHostsMsg = (function () {
        function APIGetVmMigrationCandidateHostsMsg() {
        }
        APIGetVmMigrationCandidateHostsMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIGetVmMigrationCandidateHostsMsg': this
            };
            return msg;
        };
        return APIGetVmMigrationCandidateHostsMsg;
    })();
    ApiHeader.APIGetVmMigrationCandidateHostsMsg = APIGetVmMigrationCandidateHostsMsg;
    var APIQueryVmInstanceMsg = (function () {
        function APIQueryVmInstanceMsg() {
        }
        APIQueryVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIQueryVmInstanceMsg': this
            };
            return msg;
        };
        return APIQueryVmInstanceMsg;
    })();
    ApiHeader.APIQueryVmInstanceMsg = APIQueryVmInstanceMsg;
    var APIDetachL3NetworkFromVmMsg = (function () {
        function APIDetachL3NetworkFromVmMsg() {
        }
        APIDetachL3NetworkFromVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIDetachL3NetworkFromVmMsg': this
            };
            return msg;
        };
        return APIDetachL3NetworkFromVmMsg;
    })();
    ApiHeader.APIDetachL3NetworkFromVmMsg = APIDetachL3NetworkFromVmMsg;
    var APIListVmNicMsg = (function () {
        function APIListVmNicMsg() {
        }
        APIListVmNicMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIListVmNicMsg': this
            };
            return msg;
        };
        return APIListVmNicMsg;
    })();
    ApiHeader.APIListVmNicMsg = APIListVmNicMsg;
    var APIListVmInstanceMsg = (function () {
        function APIListVmInstanceMsg() {
        }
        APIListVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIListVmInstanceMsg': this
            };
            return msg;
        };
        return APIListVmInstanceMsg;
    })();
    ApiHeader.APIListVmInstanceMsg = APIListVmInstanceMsg;
    var APIRebootVmInstanceMsg = (function () {
        function APIRebootVmInstanceMsg() {
        }
        APIRebootVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIRebootVmInstanceMsg': this
            };
            return msg;
        };
        return APIRebootVmInstanceMsg;
    })();
    ApiHeader.APIRebootVmInstanceMsg = APIRebootVmInstanceMsg;
    var APICreateVmInstanceMsg = (function () {
        function APICreateVmInstanceMsg() {
        }
        APICreateVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APICreateVmInstanceMsg': this
            };
            return msg;
        };
        return APICreateVmInstanceMsg;
    })();
    ApiHeader.APICreateVmInstanceMsg = APICreateVmInstanceMsg;
    var APIGetVmInstanceMsg = (function () {
        function APIGetVmInstanceMsg() {
        }
        APIGetVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIGetVmInstanceMsg': this
            };
            return msg;
        };
        return APIGetVmInstanceMsg;
    })();
    ApiHeader.APIGetVmInstanceMsg = APIGetVmInstanceMsg;
    var APIStartVmInstanceMsg = (function () {
        function APIStartVmInstanceMsg() {
        }
        APIStartVmInstanceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.vm.APIStartVmInstanceMsg': this
            };
            return msg;
        };
        return APIStartVmInstanceMsg;
    })();
    ApiHeader.APIStartVmInstanceMsg = APIStartVmInstanceMsg;
    var APIChangeImageStateMsg = (function () {
        function APIChangeImageStateMsg() {
        }
        APIChangeImageStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APIChangeImageStateMsg': this
            };
            return msg;
        };
        return APIChangeImageStateMsg;
    })();
    ApiHeader.APIChangeImageStateMsg = APIChangeImageStateMsg;
    var APIGetImageMsg = (function () {
        function APIGetImageMsg() {
        }
        APIGetImageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APIGetImageMsg': this
            };
            return msg;
        };
        return APIGetImageMsg;
    })();
    ApiHeader.APIGetImageMsg = APIGetImageMsg;
    var APIUpdateImageMsg = (function () {
        function APIUpdateImageMsg() {
        }
        APIUpdateImageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APIUpdateImageMsg': this
            };
            return msg;
        };
        return APIUpdateImageMsg;
    })();
    ApiHeader.APIUpdateImageMsg = APIUpdateImageMsg;
    var APIDeleteImageMsg = (function () {
        function APIDeleteImageMsg() {
        }
        APIDeleteImageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APIDeleteImageMsg': this
            };
            return msg;
        };
        return APIDeleteImageMsg;
    })();
    ApiHeader.APIDeleteImageMsg = APIDeleteImageMsg;
    var APISearchImageMsg = (function () {
        function APISearchImageMsg() {
        }
        APISearchImageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APISearchImageMsg': this
            };
            return msg;
        };
        return APISearchImageMsg;
    })();
    ApiHeader.APISearchImageMsg = APISearchImageMsg;
    var APICreateDataVolumeTemplateFromVolumeMsg = (function () {
        function APICreateDataVolumeTemplateFromVolumeMsg() {
        }
        APICreateDataVolumeTemplateFromVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APICreateDataVolumeTemplateFromVolumeMsg': this
            };
            return msg;
        };
        return APICreateDataVolumeTemplateFromVolumeMsg;
    })();
    ApiHeader.APICreateDataVolumeTemplateFromVolumeMsg = APICreateDataVolumeTemplateFromVolumeMsg;
    var APICreateRootVolumeTemplateFromRootVolumeMsg = (function () {
        function APICreateRootVolumeTemplateFromRootVolumeMsg() {
        }
        APICreateRootVolumeTemplateFromRootVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APICreateRootVolumeTemplateFromRootVolumeMsg': this
            };
            return msg;
        };
        return APICreateRootVolumeTemplateFromRootVolumeMsg;
    })();
    ApiHeader.APICreateRootVolumeTemplateFromRootVolumeMsg = APICreateRootVolumeTemplateFromRootVolumeMsg;
    var APIQueryImageMsg = (function () {
        function APIQueryImageMsg() {
        }
        APIQueryImageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APIQueryImageMsg': this
            };
            return msg;
        };
        return APIQueryImageMsg;
    })();
    ApiHeader.APIQueryImageMsg = APIQueryImageMsg;
    var APIListImageMsg = (function () {
        function APIListImageMsg() {
        }
        APIListImageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APIListImageMsg': this
            };
            return msg;
        };
        return APIListImageMsg;
    })();
    ApiHeader.APIListImageMsg = APIListImageMsg;
    var APICreateRootVolumeTemplateFromVolumeSnapshotMsg = (function () {
        function APICreateRootVolumeTemplateFromVolumeSnapshotMsg() {
        }
        APICreateRootVolumeTemplateFromVolumeSnapshotMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APICreateRootVolumeTemplateFromVolumeSnapshotMsg': this
            };
            return msg;
        };
        return APICreateRootVolumeTemplateFromVolumeSnapshotMsg;
    })();
    ApiHeader.APICreateRootVolumeTemplateFromVolumeSnapshotMsg = APICreateRootVolumeTemplateFromVolumeSnapshotMsg;
    var APIAddImageMsg = (function () {
        function APIAddImageMsg() {
        }
        APIAddImageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.image.APIAddImageMsg': this
            };
            return msg;
        };
        return APIAddImageMsg;
    })();
    ApiHeader.APIAddImageMsg = APIAddImageMsg;
    var APIRequestConsoleAccessMsg = (function () {
        function APIRequestConsoleAccessMsg() {
        }
        APIRequestConsoleAccessMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.console.APIRequestConsoleAccessMsg': this
            };
            return msg;
        };
        return APIRequestConsoleAccessMsg;
    })();
    ApiHeader.APIRequestConsoleAccessMsg = APIRequestConsoleAccessMsg;
    var APIBackupDataVolumeMsg = (function () {
        function APIBackupDataVolumeMsg() {
        }
        APIBackupDataVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIBackupDataVolumeMsg': this
            };
            return msg;
        };
        return APIBackupDataVolumeMsg;
    })();
    ApiHeader.APIBackupDataVolumeMsg = APIBackupDataVolumeMsg;
    var APIAttachDataVolumeToVmMsg = (function () {
        function APIAttachDataVolumeToVmMsg() {
        }
        APIAttachDataVolumeToVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIAttachDataVolumeToVmMsg': this
            };
            return msg;
        };
        return APIAttachDataVolumeToVmMsg;
    })();
    ApiHeader.APIAttachDataVolumeToVmMsg = APIAttachDataVolumeToVmMsg;
    var APISearchVolumeMsg = (function () {
        function APISearchVolumeMsg() {
        }
        APISearchVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APISearchVolumeMsg': this
            };
            return msg;
        };
        return APISearchVolumeMsg;
    })();
    ApiHeader.APISearchVolumeMsg = APISearchVolumeMsg;
    var APIUpdateVolumeMsg = (function () {
        function APIUpdateVolumeMsg() {
        }
        APIUpdateVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIUpdateVolumeMsg': this
            };
            return msg;
        };
        return APIUpdateVolumeMsg;
    })();
    ApiHeader.APIUpdateVolumeMsg = APIUpdateVolumeMsg;
    var APIQueryVolumeMsg = (function () {
        function APIQueryVolumeMsg() {
        }
        APIQueryVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIQueryVolumeMsg': this
            };
            return msg;
        };
        return APIQueryVolumeMsg;
    })();
    ApiHeader.APIQueryVolumeMsg = APIQueryVolumeMsg;
    var APICreateDataVolumeFromVolumeSnapshotMsg = (function () {
        function APICreateDataVolumeFromVolumeSnapshotMsg() {
        }
        APICreateDataVolumeFromVolumeSnapshotMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APICreateDataVolumeFromVolumeSnapshotMsg': this
            };
            return msg;
        };
        return APICreateDataVolumeFromVolumeSnapshotMsg;
    })();
    ApiHeader.APICreateDataVolumeFromVolumeSnapshotMsg = APICreateDataVolumeFromVolumeSnapshotMsg;
    var APICreateDataVolumeFromVolumeTemplateMsg = (function () {
        function APICreateDataVolumeFromVolumeTemplateMsg() {
        }
        APICreateDataVolumeFromVolumeTemplateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APICreateDataVolumeFromVolumeTemplateMsg': this
            };
            return msg;
        };
        return APICreateDataVolumeFromVolumeTemplateMsg;
    })();
    ApiHeader.APICreateDataVolumeFromVolumeTemplateMsg = APICreateDataVolumeFromVolumeTemplateMsg;
    var APIDetachDataVolumeFromVmMsg = (function () {
        function APIDetachDataVolumeFromVmMsg() {
        }
        APIDetachDataVolumeFromVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIDetachDataVolumeFromVmMsg': this
            };
            return msg;
        };
        return APIDetachDataVolumeFromVmMsg;
    })();
    ApiHeader.APIDetachDataVolumeFromVmMsg = APIDetachDataVolumeFromVmMsg;
    var APIGetVolumeMsg = (function () {
        function APIGetVolumeMsg() {
        }
        APIGetVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIGetVolumeMsg': this
            };
            return msg;
        };
        return APIGetVolumeMsg;
    })();
    ApiHeader.APIGetVolumeMsg = APIGetVolumeMsg;
    var APICreateDataVolumeMsg = (function () {
        function APICreateDataVolumeMsg() {
        }
        APICreateDataVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APICreateDataVolumeMsg': this
            };
            return msg;
        };
        return APICreateDataVolumeMsg;
    })();
    ApiHeader.APICreateDataVolumeMsg = APICreateDataVolumeMsg;
    var APIGetDataVolumeAttachableVmMsg = (function () {
        function APIGetDataVolumeAttachableVmMsg() {
        }
        APIGetDataVolumeAttachableVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIGetDataVolumeAttachableVmMsg': this
            };
            return msg;
        };
        return APIGetDataVolumeAttachableVmMsg;
    })();
    ApiHeader.APIGetDataVolumeAttachableVmMsg = APIGetDataVolumeAttachableVmMsg;
    var APIGetVolumeFormatMsg = (function () {
        function APIGetVolumeFormatMsg() {
        }
        APIGetVolumeFormatMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIGetVolumeFormatMsg': this
            };
            return msg;
        };
        return APIGetVolumeFormatMsg;
    })();
    ApiHeader.APIGetVolumeFormatMsg = APIGetVolumeFormatMsg;
    var APIDeleteDataVolumeMsg = (function () {
        function APIDeleteDataVolumeMsg() {
        }
        APIDeleteDataVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIDeleteDataVolumeMsg': this
            };
            return msg;
        };
        return APIDeleteDataVolumeMsg;
    })();
    ApiHeader.APIDeleteDataVolumeMsg = APIDeleteDataVolumeMsg;
    var APICreateVolumeSnapshotMsg = (function () {
        function APICreateVolumeSnapshotMsg() {
        }
        APICreateVolumeSnapshotMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APICreateVolumeSnapshotMsg': this
            };
            return msg;
        };
        return APICreateVolumeSnapshotMsg;
    })();
    ApiHeader.APICreateVolumeSnapshotMsg = APICreateVolumeSnapshotMsg;
    var APIListVolumeMsg = (function () {
        function APIListVolumeMsg() {
        }
        APIListVolumeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIListVolumeMsg': this
            };
            return msg;
        };
        return APIListVolumeMsg;
    })();
    ApiHeader.APIListVolumeMsg = APIListVolumeMsg;
    var APIChangeVolumeStateMsg = (function () {
        function APIChangeVolumeStateMsg() {
        }
        APIChangeVolumeStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.volume.APIChangeVolumeStateMsg': this
            };
            return msg;
        };
        return APIChangeVolumeStateMsg;
    })();
    ApiHeader.APIChangeVolumeStateMsg = APIChangeVolumeStateMsg;
    var APIIsReadyToGoMsg = (function () {
        function APIIsReadyToGoMsg() {
        }
        APIIsReadyToGoMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.apimediator.APIIsReadyToGoMsg': this
            };
            return msg;
        };
        return APIIsReadyToGoMsg;
    })();
    ApiHeader.APIIsReadyToGoMsg = APIIsReadyToGoMsg;
    var APIListDiskOfferingMsg = (function () {
        function APIListDiskOfferingMsg() {
        }
        APIListDiskOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIListDiskOfferingMsg': this
            };
            return msg;
        };
        return APIListDiskOfferingMsg;
    })();
    ApiHeader.APIListDiskOfferingMsg = APIListDiskOfferingMsg;
    var APIGenerateApiTypeScriptDefinitionMsg = (function () {
        function APIGenerateApiTypeScriptDefinitionMsg() {
        }
        APIGenerateApiTypeScriptDefinitionMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGenerateApiTypeScriptDefinitionMsg': this
            };
            return msg;
        };
        return APIGenerateApiTypeScriptDefinitionMsg;
    })();
    ApiHeader.APIGenerateApiTypeScriptDefinitionMsg = APIGenerateApiTypeScriptDefinitionMsg;
    var APIDeleteDiskOfferingMsg = (function () {
        function APIDeleteDiskOfferingMsg() {
        }
        APIDeleteDiskOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIDeleteDiskOfferingMsg': this
            };
            return msg;
        };
        return APIDeleteDiskOfferingMsg;
    })();
    ApiHeader.APIDeleteDiskOfferingMsg = APIDeleteDiskOfferingMsg;
    var APIGenerateGroovyClassMsg = (function () {
        function APIGenerateGroovyClassMsg() {
        }
        APIGenerateGroovyClassMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGenerateGroovyClassMsg': this
            };
            return msg;
        };
        return APIGenerateGroovyClassMsg;
    })();
    ApiHeader.APIGenerateGroovyClassMsg = APIGenerateGroovyClassMsg;
    var APIQueryInstanceOfferingMsg = (function () {
        function APIQueryInstanceOfferingMsg() {
        }
        APIQueryInstanceOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIQueryInstanceOfferingMsg': this
            };
            return msg;
        };
        return APIQueryInstanceOfferingMsg;
    })();
    ApiHeader.APIQueryInstanceOfferingMsg = APIQueryInstanceOfferingMsg;
    var APIUpdateInstanceOfferingMsg = (function () {
        function APIUpdateInstanceOfferingMsg() {
        }
        APIUpdateInstanceOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIUpdateInstanceOfferingMsg': this
            };
            return msg;
        };
        return APIUpdateInstanceOfferingMsg;
    })();
    ApiHeader.APIUpdateInstanceOfferingMsg = APIUpdateInstanceOfferingMsg;
    var APICreateInstanceOfferingMsg = (function () {
        function APICreateInstanceOfferingMsg() {
        }
        APICreateInstanceOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APICreateInstanceOfferingMsg': this
            };
            return msg;
        };
        return APICreateInstanceOfferingMsg;
    })();
    ApiHeader.APICreateInstanceOfferingMsg = APICreateInstanceOfferingMsg;
    var APIGenerateApiJsonTemplateMsg = (function () {
        function APIGenerateApiJsonTemplateMsg() {
        }
        APIGenerateApiJsonTemplateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGenerateApiJsonTemplateMsg': this
            };
            return msg;
        };
        return APIGenerateApiJsonTemplateMsg;
    })();
    ApiHeader.APIGenerateApiJsonTemplateMsg = APIGenerateApiJsonTemplateMsg;
    var APICreateDiskOfferingMsg = (function () {
        function APICreateDiskOfferingMsg() {
        }
        APICreateDiskOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APICreateDiskOfferingMsg': this
            };
            return msg;
        };
        return APICreateDiskOfferingMsg;
    })();
    ApiHeader.APICreateDiskOfferingMsg = APICreateDiskOfferingMsg;
    var APIGetInstanceOfferingMsg = (function () {
        function APIGetInstanceOfferingMsg() {
        }
        APIGetInstanceOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGetInstanceOfferingMsg': this
            };
            return msg;
        };
        return APIGetInstanceOfferingMsg;
    })();
    ApiHeader.APIGetInstanceOfferingMsg = APIGetInstanceOfferingMsg;
    var APIListInstanceOfferingMsg = (function () {
        function APIListInstanceOfferingMsg() {
        }
        APIListInstanceOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIListInstanceOfferingMsg': this
            };
            return msg;
        };
        return APIListInstanceOfferingMsg;
    })();
    ApiHeader.APIListInstanceOfferingMsg = APIListInstanceOfferingMsg;
    var APISearchDnsMsg = (function () {
        function APISearchDnsMsg() {
        }
        APISearchDnsMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APISearchDnsMsg': this
            };
            return msg;
        };
        return APISearchDnsMsg;
    })();
    ApiHeader.APISearchDnsMsg = APISearchDnsMsg;
    var APISearchDiskOfferingMsg = (function () {
        function APISearchDiskOfferingMsg() {
        }
        APISearchDiskOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APISearchDiskOfferingMsg': this
            };
            return msg;
        };
        return APISearchDiskOfferingMsg;
    })();
    ApiHeader.APISearchDiskOfferingMsg = APISearchDiskOfferingMsg;
    var APIDeleteInstanceOfferingMsg = (function () {
        function APIDeleteInstanceOfferingMsg() {
        }
        APIDeleteInstanceOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIDeleteInstanceOfferingMsg': this
            };
            return msg;
        };
        return APIDeleteInstanceOfferingMsg;
    })();
    ApiHeader.APIDeleteInstanceOfferingMsg = APIDeleteInstanceOfferingMsg;
    var APIGenerateSqlVOViewMsg = (function () {
        function APIGenerateSqlVOViewMsg() {
        }
        APIGenerateSqlVOViewMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGenerateSqlVOViewMsg': this
            };
            return msg;
        };
        return APIGenerateSqlVOViewMsg;
    })();
    ApiHeader.APIGenerateSqlVOViewMsg = APIGenerateSqlVOViewMsg;
    var APIGenerateTestLinkDocumentMsg = (function () {
        function APIGenerateTestLinkDocumentMsg() {
        }
        APIGenerateTestLinkDocumentMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGenerateTestLinkDocumentMsg': this
            };
            return msg;
        };
        return APIGenerateTestLinkDocumentMsg;
    })();
    ApiHeader.APIGenerateTestLinkDocumentMsg = APIGenerateTestLinkDocumentMsg;
    var APIGetGlobalPropertyMsg = (function () {
        function APIGetGlobalPropertyMsg() {
        }
        APIGetGlobalPropertyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGetGlobalPropertyMsg': this
            };
            return msg;
        };
        return APIGetGlobalPropertyMsg;
    })();
    ApiHeader.APIGetGlobalPropertyMsg = APIGetGlobalPropertyMsg;
    var APIChangeInstanceOfferingStateMsg = (function () {
        function APIChangeInstanceOfferingStateMsg() {
        }
        APIChangeInstanceOfferingStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIChangeInstanceOfferingStateMsg': this
            };
            return msg;
        };
        return APIChangeInstanceOfferingStateMsg;
    })();
    ApiHeader.APIChangeInstanceOfferingStateMsg = APIChangeInstanceOfferingStateMsg;
    var APIGenerateSqlIndexMsg = (function () {
        function APIGenerateSqlIndexMsg() {
        }
        APIGenerateSqlIndexMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGenerateSqlIndexMsg': this
            };
            return msg;
        };
        return APIGenerateSqlIndexMsg;
    })();
    ApiHeader.APIGenerateSqlIndexMsg = APIGenerateSqlIndexMsg;
    var APIQueryDiskOfferingMsg = (function () {
        function APIQueryDiskOfferingMsg() {
        }
        APIQueryDiskOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIQueryDiskOfferingMsg': this
            };
            return msg;
        };
        return APIQueryDiskOfferingMsg;
    })();
    ApiHeader.APIQueryDiskOfferingMsg = APIQueryDiskOfferingMsg;
    var APIGetDiskOfferingMsg = (function () {
        function APIGetDiskOfferingMsg() {
        }
        APIGetDiskOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGetDiskOfferingMsg': this
            };
            return msg;
        };
        return APIGetDiskOfferingMsg;
    })();
    ApiHeader.APIGetDiskOfferingMsg = APIGetDiskOfferingMsg;
    var APIGenerateSqlForeignKeyMsg = (function () {
        function APIGenerateSqlForeignKeyMsg() {
        }
        APIGenerateSqlForeignKeyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIGenerateSqlForeignKeyMsg': this
            };
            return msg;
        };
        return APIGenerateSqlForeignKeyMsg;
    })();
    ApiHeader.APIGenerateSqlForeignKeyMsg = APIGenerateSqlForeignKeyMsg;
    var APIUpdateDiskOfferingMsg = (function () {
        function APIUpdateDiskOfferingMsg() {
        }
        APIUpdateDiskOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIUpdateDiskOfferingMsg': this
            };
            return msg;
        };
        return APIUpdateDiskOfferingMsg;
    })();
    ApiHeader.APIUpdateDiskOfferingMsg = APIUpdateDiskOfferingMsg;
    var APIChangeDiskOfferingStateMsg = (function () {
        function APIChangeDiskOfferingStateMsg() {
        }
        APIChangeDiskOfferingStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APIChangeDiskOfferingStateMsg': this
            };
            return msg;
        };
        return APIChangeDiskOfferingStateMsg;
    })();
    ApiHeader.APIChangeDiskOfferingStateMsg = APIChangeDiskOfferingStateMsg;
    var APISearchInstanceOfferingMsg = (function () {
        function APISearchInstanceOfferingMsg() {
        }
        APISearchInstanceOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.configuration.APISearchInstanceOfferingMsg': this
            };
            return msg;
        };
        return APISearchInstanceOfferingMsg;
    })();
    ApiHeader.APISearchInstanceOfferingMsg = APISearchInstanceOfferingMsg;
    var APISearchPrimaryStorageMsg = (function () {
        function APISearchPrimaryStorageMsg() {
        }
        APISearchPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APISearchPrimaryStorageMsg': this
            };
            return msg;
        };
        return APISearchPrimaryStorageMsg;
    })();
    ApiHeader.APISearchPrimaryStorageMsg = APISearchPrimaryStorageMsg;
    var APIGetPrimaryStorageTypesMsg = (function () {
        function APIGetPrimaryStorageTypesMsg() {
        }
        APIGetPrimaryStorageTypesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIGetPrimaryStorageTypesMsg': this
            };
            return msg;
        };
        return APIGetPrimaryStorageTypesMsg;
    })();
    ApiHeader.APIGetPrimaryStorageTypesMsg = APIGetPrimaryStorageTypesMsg;
    var APIAttachPrimaryStorageToClusterMsg = (function () {
        function APIAttachPrimaryStorageToClusterMsg() {
        }
        APIAttachPrimaryStorageToClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIAttachPrimaryStorageToClusterMsg': this
            };
            return msg;
        };
        return APIAttachPrimaryStorageToClusterMsg;
    })();
    ApiHeader.APIAttachPrimaryStorageToClusterMsg = APIAttachPrimaryStorageToClusterMsg;
    var APIListPrimaryStorageMsg = (function () {
        function APIListPrimaryStorageMsg() {
        }
        APIListPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIListPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIListPrimaryStorageMsg;
    })();
    ApiHeader.APIListPrimaryStorageMsg = APIListPrimaryStorageMsg;
    var APIGetPrimaryStorageCapacityMsg = (function () {
        function APIGetPrimaryStorageCapacityMsg() {
        }
        APIGetPrimaryStorageCapacityMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIGetPrimaryStorageCapacityMsg': this
            };
            return msg;
        };
        return APIGetPrimaryStorageCapacityMsg;
    })();
    ApiHeader.APIGetPrimaryStorageCapacityMsg = APIGetPrimaryStorageCapacityMsg;
    var APIUpdatePrimaryStorageMsg = (function () {
        function APIUpdatePrimaryStorageMsg() {
        }
        APIUpdatePrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIUpdatePrimaryStorageMsg': this
            };
            return msg;
        };
        return APIUpdatePrimaryStorageMsg;
    })();
    ApiHeader.APIUpdatePrimaryStorageMsg = APIUpdatePrimaryStorageMsg;
    var APIGetPrimaryStorageMsg = (function () {
        function APIGetPrimaryStorageMsg() {
        }
        APIGetPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIGetPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIGetPrimaryStorageMsg;
    })();
    ApiHeader.APIGetPrimaryStorageMsg = APIGetPrimaryStorageMsg;
    var APIQueryPrimaryStorageMsg = (function () {
        function APIQueryPrimaryStorageMsg() {
        }
        APIQueryPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIQueryPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIQueryPrimaryStorageMsg;
    })();
    ApiHeader.APIQueryPrimaryStorageMsg = APIQueryPrimaryStorageMsg;
    var APIChangePrimaryStorageStateMsg = (function () {
        function APIChangePrimaryStorageStateMsg() {
        }
        APIChangePrimaryStorageStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIChangePrimaryStorageStateMsg': this
            };
            return msg;
        };
        return APIChangePrimaryStorageStateMsg;
    })();
    ApiHeader.APIChangePrimaryStorageStateMsg = APIChangePrimaryStorageStateMsg;
    var APISyncPrimaryStorageCapacityMsg = (function () {
        function APISyncPrimaryStorageCapacityMsg() {
        }
        APISyncPrimaryStorageCapacityMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APISyncPrimaryStorageCapacityMsg': this
            };
            return msg;
        };
        return APISyncPrimaryStorageCapacityMsg;
    })();
    ApiHeader.APISyncPrimaryStorageCapacityMsg = APISyncPrimaryStorageCapacityMsg;
    var APIDeletePrimaryStorageMsg = (function () {
        function APIDeletePrimaryStorageMsg() {
        }
        APIDeletePrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIDeletePrimaryStorageMsg': this
            };
            return msg;
        };
        return APIDeletePrimaryStorageMsg;
    })();
    ApiHeader.APIDeletePrimaryStorageMsg = APIDeletePrimaryStorageMsg;
    var APIReconnectPrimaryStorageMsg = (function () {
        function APIReconnectPrimaryStorageMsg() {
        }
        APIReconnectPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIReconnectPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIReconnectPrimaryStorageMsg;
    })();
    ApiHeader.APIReconnectPrimaryStorageMsg = APIReconnectPrimaryStorageMsg;
    var APIDetachPrimaryStorageFromClusterMsg = (function () {
        function APIDetachPrimaryStorageFromClusterMsg() {
        }
        APIDetachPrimaryStorageFromClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIDetachPrimaryStorageFromClusterMsg': this
            };
            return msg;
        };
        return APIDetachPrimaryStorageFromClusterMsg;
    })();
    ApiHeader.APIDetachPrimaryStorageFromClusterMsg = APIDetachPrimaryStorageFromClusterMsg;
    var APIGetPrimaryStorageAllocatorStrategiesMsg = (function () {
        function APIGetPrimaryStorageAllocatorStrategiesMsg() {
        }
        APIGetPrimaryStorageAllocatorStrategiesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.primary.APIGetPrimaryStorageAllocatorStrategiesMsg': this
            };
            return msg;
        };
        return APIGetPrimaryStorageAllocatorStrategiesMsg;
    })();
    ApiHeader.APIGetPrimaryStorageAllocatorStrategiesMsg = APIGetPrimaryStorageAllocatorStrategiesMsg;
    var APIQueryVolumeSnapshotTreeMsg = (function () {
        function APIQueryVolumeSnapshotTreeMsg() {
        }
        APIQueryVolumeSnapshotTreeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.snapshot.APIQueryVolumeSnapshotTreeMsg': this
            };
            return msg;
        };
        return APIQueryVolumeSnapshotTreeMsg;
    })();
    ApiHeader.APIQueryVolumeSnapshotTreeMsg = APIQueryVolumeSnapshotTreeMsg;
    var APIDeleteVolumeSnapshotMsg = (function () {
        function APIDeleteVolumeSnapshotMsg() {
        }
        APIDeleteVolumeSnapshotMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.snapshot.APIDeleteVolumeSnapshotMsg': this
            };
            return msg;
        };
        return APIDeleteVolumeSnapshotMsg;
    })();
    ApiHeader.APIDeleteVolumeSnapshotMsg = APIDeleteVolumeSnapshotMsg;
    var APIUpdateVolumeSnapshotMsg = (function () {
        function APIUpdateVolumeSnapshotMsg() {
        }
        APIUpdateVolumeSnapshotMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.snapshot.APIUpdateVolumeSnapshotMsg': this
            };
            return msg;
        };
        return APIUpdateVolumeSnapshotMsg;
    })();
    ApiHeader.APIUpdateVolumeSnapshotMsg = APIUpdateVolumeSnapshotMsg;
    var APIDeleteVolumeSnapshotFromBackupStorageMsg = (function () {
        function APIDeleteVolumeSnapshotFromBackupStorageMsg() {
        }
        APIDeleteVolumeSnapshotFromBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.snapshot.APIDeleteVolumeSnapshotFromBackupStorageMsg': this
            };
            return msg;
        };
        return APIDeleteVolumeSnapshotFromBackupStorageMsg;
    })();
    ApiHeader.APIDeleteVolumeSnapshotFromBackupStorageMsg = APIDeleteVolumeSnapshotFromBackupStorageMsg;
    var APIQueryVolumeSnapshotMsg = (function () {
        function APIQueryVolumeSnapshotMsg() {
        }
        APIQueryVolumeSnapshotMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.snapshot.APIQueryVolumeSnapshotMsg': this
            };
            return msg;
        };
        return APIQueryVolumeSnapshotMsg;
    })();
    ApiHeader.APIQueryVolumeSnapshotMsg = APIQueryVolumeSnapshotMsg;
    var APIRevertVolumeFromSnapshotMsg = (function () {
        function APIRevertVolumeFromSnapshotMsg() {
        }
        APIRevertVolumeFromSnapshotMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.snapshot.APIRevertVolumeFromSnapshotMsg': this
            };
            return msg;
        };
        return APIRevertVolumeFromSnapshotMsg;
    })();
    ApiHeader.APIRevertVolumeFromSnapshotMsg = APIRevertVolumeFromSnapshotMsg;
    var APIBackupVolumeSnapshotMsg = (function () {
        function APIBackupVolumeSnapshotMsg() {
        }
        APIBackupVolumeSnapshotMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.snapshot.APIBackupVolumeSnapshotMsg': this
            };
            return msg;
        };
        return APIBackupVolumeSnapshotMsg;
    })();
    ApiHeader.APIBackupVolumeSnapshotMsg = APIBackupVolumeSnapshotMsg;
    var APIGetVolumeSnapshotTreeMsg = (function () {
        function APIGetVolumeSnapshotTreeMsg() {
        }
        APIGetVolumeSnapshotTreeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.snapshot.APIGetVolumeSnapshotTreeMsg': this
            };
            return msg;
        };
        return APIGetVolumeSnapshotTreeMsg;
    })();
    ApiHeader.APIGetVolumeSnapshotTreeMsg = APIGetVolumeSnapshotTreeMsg;
    var APIQueryBackupStorageMsg = (function () {
        function APIQueryBackupStorageMsg() {
        }
        APIQueryBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIQueryBackupStorageMsg': this
            };
            return msg;
        };
        return APIQueryBackupStorageMsg;
    })();
    ApiHeader.APIQueryBackupStorageMsg = APIQueryBackupStorageMsg;
    var APIListBackupStorageMsg = (function () {
        function APIListBackupStorageMsg() {
        }
        APIListBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIListBackupStorageMsg': this
            };
            return msg;
        };
        return APIListBackupStorageMsg;
    })();
    ApiHeader.APIListBackupStorageMsg = APIListBackupStorageMsg;
    var APIAttachBackupStorageToZoneMsg = (function () {
        function APIAttachBackupStorageToZoneMsg() {
        }
        APIAttachBackupStorageToZoneMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIAttachBackupStorageToZoneMsg': this
            };
            return msg;
        };
        return APIAttachBackupStorageToZoneMsg;
    })();
    ApiHeader.APIAttachBackupStorageToZoneMsg = APIAttachBackupStorageToZoneMsg;
    var APISearchBackupStorageMsg = (function () {
        function APISearchBackupStorageMsg() {
        }
        APISearchBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APISearchBackupStorageMsg': this
            };
            return msg;
        };
        return APISearchBackupStorageMsg;
    })();
    ApiHeader.APISearchBackupStorageMsg = APISearchBackupStorageMsg;
    var APIGetBackupStorageMsg = (function () {
        function APIGetBackupStorageMsg() {
        }
        APIGetBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIGetBackupStorageMsg': this
            };
            return msg;
        };
        return APIGetBackupStorageMsg;
    })();
    ApiHeader.APIGetBackupStorageMsg = APIGetBackupStorageMsg;
    var APIGetBackupStorageTypesMsg = (function () {
        function APIGetBackupStorageTypesMsg() {
        }
        APIGetBackupStorageTypesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIGetBackupStorageTypesMsg': this
            };
            return msg;
        };
        return APIGetBackupStorageTypesMsg;
    })();
    ApiHeader.APIGetBackupStorageTypesMsg = APIGetBackupStorageTypesMsg;
    var APIChangeBackupStorageStateMsg = (function () {
        function APIChangeBackupStorageStateMsg() {
        }
        APIChangeBackupStorageStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIChangeBackupStorageStateMsg': this
            };
            return msg;
        };
        return APIChangeBackupStorageStateMsg;
    })();
    ApiHeader.APIChangeBackupStorageStateMsg = APIChangeBackupStorageStateMsg;
    var APIScanBackupStorageMsg = (function () {
        function APIScanBackupStorageMsg() {
        }
        APIScanBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIScanBackupStorageMsg': this
            };
            return msg;
        };
        return APIScanBackupStorageMsg;
    })();
    ApiHeader.APIScanBackupStorageMsg = APIScanBackupStorageMsg;
    var APIGetBackupStorageCapacityMsg = (function () {
        function APIGetBackupStorageCapacityMsg() {
        }
        APIGetBackupStorageCapacityMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIGetBackupStorageCapacityMsg': this
            };
            return msg;
        };
        return APIGetBackupStorageCapacityMsg;
    })();
    ApiHeader.APIGetBackupStorageCapacityMsg = APIGetBackupStorageCapacityMsg;
    var APIDetachBackupStorageFromZoneMsg = (function () {
        function APIDetachBackupStorageFromZoneMsg() {
        }
        APIDetachBackupStorageFromZoneMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIDetachBackupStorageFromZoneMsg': this
            };
            return msg;
        };
        return APIDetachBackupStorageFromZoneMsg;
    })();
    ApiHeader.APIDetachBackupStorageFromZoneMsg = APIDetachBackupStorageFromZoneMsg;
    var APIUpdateBackupStorageMsg = (function () {
        function APIUpdateBackupStorageMsg() {
        }
        APIUpdateBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIUpdateBackupStorageMsg': this
            };
            return msg;
        };
        return APIUpdateBackupStorageMsg;
    })();
    ApiHeader.APIUpdateBackupStorageMsg = APIUpdateBackupStorageMsg;
    var APIDeleteBackupStorageMsg = (function () {
        function APIDeleteBackupStorageMsg() {
        }
        APIDeleteBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.storage.backup.APIDeleteBackupStorageMsg': this
            };
            return msg;
        };
        return APIDeleteBackupStorageMsg;
    })();
    ApiHeader.APIDeleteBackupStorageMsg = APIDeleteBackupStorageMsg;
    var APIListL3NetworkMsg = (function () {
        function APIListL3NetworkMsg() {
        }
        APIListL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIListL3NetworkMsg': this
            };
            return msg;
        };
        return APIListL3NetworkMsg;
    })();
    ApiHeader.APIListL3NetworkMsg = APIListL3NetworkMsg;
    var APIAddDnsToL3NetworkMsg = (function () {
        function APIAddDnsToL3NetworkMsg() {
        }
        APIAddDnsToL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIAddDnsToL3NetworkMsg': this
            };
            return msg;
        };
        return APIAddDnsToL3NetworkMsg;
    })();
    ApiHeader.APIAddDnsToL3NetworkMsg = APIAddDnsToL3NetworkMsg;
    var APICreateL3NetworkMsg = (function () {
        function APICreateL3NetworkMsg() {
        }
        APICreateL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APICreateL3NetworkMsg': this
            };
            return msg;
        };
        return APICreateL3NetworkMsg;
    })();
    ApiHeader.APICreateL3NetworkMsg = APICreateL3NetworkMsg;
    var APIGetFreeIpMsg = (function () {
        function APIGetFreeIpMsg() {
        }
        APIGetFreeIpMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIGetFreeIpMsg': this
            };
            return msg;
        };
        return APIGetFreeIpMsg;
    })();
    ApiHeader.APIGetFreeIpMsg = APIGetFreeIpMsg;
    var APIUpdateL3NetworkMsg = (function () {
        function APIUpdateL3NetworkMsg() {
        }
        APIUpdateL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIUpdateL3NetworkMsg': this
            };
            return msg;
        };
        return APIUpdateL3NetworkMsg;
    })();
    ApiHeader.APIUpdateL3NetworkMsg = APIUpdateL3NetworkMsg;
    var APIDeleteIpRangeMsg = (function () {
        function APIDeleteIpRangeMsg() {
        }
        APIDeleteIpRangeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIDeleteIpRangeMsg': this
            };
            return msg;
        };
        return APIDeleteIpRangeMsg;
    })();
    ApiHeader.APIDeleteIpRangeMsg = APIDeleteIpRangeMsg;
    var APIChangeL3NetworkStateMsg = (function () {
        function APIChangeL3NetworkStateMsg() {
        }
        APIChangeL3NetworkStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIChangeL3NetworkStateMsg': this
            };
            return msg;
        };
        return APIChangeL3NetworkStateMsg;
    })();
    ApiHeader.APIChangeL3NetworkStateMsg = APIChangeL3NetworkStateMsg;
    var APIGetL3NetworkMsg = (function () {
        function APIGetL3NetworkMsg() {
        }
        APIGetL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIGetL3NetworkMsg': this
            };
            return msg;
        };
        return APIGetL3NetworkMsg;
    })();
    ApiHeader.APIGetL3NetworkMsg = APIGetL3NetworkMsg;
    var APIAddIpRangeMsg = (function () {
        function APIAddIpRangeMsg() {
        }
        APIAddIpRangeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIAddIpRangeMsg': this
            };
            return msg;
        };
        return APIAddIpRangeMsg;
    })();
    ApiHeader.APIAddIpRangeMsg = APIAddIpRangeMsg;
    var APIGetL3NetworkTypesMsg = (function () {
        function APIGetL3NetworkTypesMsg() {
        }
        APIGetL3NetworkTypesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIGetL3NetworkTypesMsg': this
            };
            return msg;
        };
        return APIGetL3NetworkTypesMsg;
    })();
    ApiHeader.APIGetL3NetworkTypesMsg = APIGetL3NetworkTypesMsg;
    var APISearchL3NetworkMsg = (function () {
        function APISearchL3NetworkMsg() {
        }
        APISearchL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APISearchL3NetworkMsg': this
            };
            return msg;
        };
        return APISearchL3NetworkMsg;
    })();
    ApiHeader.APISearchL3NetworkMsg = APISearchL3NetworkMsg;
    var APIAddIpRangeByNetworkCidrMsg = (function () {
        function APIAddIpRangeByNetworkCidrMsg() {
        }
        APIAddIpRangeByNetworkCidrMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIAddIpRangeByNetworkCidrMsg': this
            };
            return msg;
        };
        return APIAddIpRangeByNetworkCidrMsg;
    })();
    ApiHeader.APIAddIpRangeByNetworkCidrMsg = APIAddIpRangeByNetworkCidrMsg;
    var APIQueryIpRangeMsg = (function () {
        function APIQueryIpRangeMsg() {
        }
        APIQueryIpRangeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIQueryIpRangeMsg': this
            };
            return msg;
        };
        return APIQueryIpRangeMsg;
    })();
    ApiHeader.APIQueryIpRangeMsg = APIQueryIpRangeMsg;
    var APIRemoveDnsFromL3NetworkMsg = (function () {
        function APIRemoveDnsFromL3NetworkMsg() {
        }
        APIRemoveDnsFromL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIRemoveDnsFromL3NetworkMsg': this
            };
            return msg;
        };
        return APIRemoveDnsFromL3NetworkMsg;
    })();
    ApiHeader.APIRemoveDnsFromL3NetworkMsg = APIRemoveDnsFromL3NetworkMsg;
    var APIListIpRangeMsg = (function () {
        function APIListIpRangeMsg() {
        }
        APIListIpRangeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIListIpRangeMsg': this
            };
            return msg;
        };
        return APIListIpRangeMsg;
    })();
    ApiHeader.APIListIpRangeMsg = APIListIpRangeMsg;
    var APIGetIpAddressCapacityMsg = (function () {
        function APIGetIpAddressCapacityMsg() {
        }
        APIGetIpAddressCapacityMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIGetIpAddressCapacityMsg': this
            };
            return msg;
        };
        return APIGetIpAddressCapacityMsg;
    })();
    ApiHeader.APIGetIpAddressCapacityMsg = APIGetIpAddressCapacityMsg;
    var APIDeleteL3NetworkMsg = (function () {
        function APIDeleteL3NetworkMsg() {
        }
        APIDeleteL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIDeleteL3NetworkMsg': this
            };
            return msg;
        };
        return APIDeleteL3NetworkMsg;
    })();
    ApiHeader.APIDeleteL3NetworkMsg = APIDeleteL3NetworkMsg;
    var APIUpdateIpRangeMsg = (function () {
        function APIUpdateIpRangeMsg() {
        }
        APIUpdateIpRangeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIUpdateIpRangeMsg': this
            };
            return msg;
        };
        return APIUpdateIpRangeMsg;
    })();
    ApiHeader.APIUpdateIpRangeMsg = APIUpdateIpRangeMsg;
    var APIQueryL3NetworkMsg = (function () {
        function APIQueryL3NetworkMsg() {
        }
        APIQueryL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l3.APIQueryL3NetworkMsg': this
            };
            return msg;
        };
        return APIQueryL3NetworkMsg;
    })();
    ApiHeader.APIQueryL3NetworkMsg = APIQueryL3NetworkMsg;
    var APIAttachNetworkServiceToL3NetworkMsg = (function () {
        function APIAttachNetworkServiceToL3NetworkMsg() {
        }
        APIAttachNetworkServiceToL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIAttachNetworkServiceToL3NetworkMsg': this
            };
            return msg;
        };
        return APIAttachNetworkServiceToL3NetworkMsg;
    })();
    ApiHeader.APIAttachNetworkServiceToL3NetworkMsg = APIAttachNetworkServiceToL3NetworkMsg;
    var APIAddNetworkServiceProviderMsg = (function () {
        function APIAddNetworkServiceProviderMsg() {
        }
        APIAddNetworkServiceProviderMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIAddNetworkServiceProviderMsg': this
            };
            return msg;
        };
        return APIAddNetworkServiceProviderMsg;
    })();
    ApiHeader.APIAddNetworkServiceProviderMsg = APIAddNetworkServiceProviderMsg;
    var APIQueryNetworkServiceL3NetworkRefMsg = (function () {
        function APIQueryNetworkServiceL3NetworkRefMsg() {
        }
        APIQueryNetworkServiceL3NetworkRefMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIQueryNetworkServiceL3NetworkRefMsg': this
            };
            return msg;
        };
        return APIQueryNetworkServiceL3NetworkRefMsg;
    })();
    ApiHeader.APIQueryNetworkServiceL3NetworkRefMsg = APIQueryNetworkServiceL3NetworkRefMsg;
    var APIAttachNetworkServiceProviderToL2NetworkMsg = (function () {
        function APIAttachNetworkServiceProviderToL2NetworkMsg() {
        }
        APIAttachNetworkServiceProviderToL2NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIAttachNetworkServiceProviderToL2NetworkMsg': this
            };
            return msg;
        };
        return APIAttachNetworkServiceProviderToL2NetworkMsg;
    })();
    ApiHeader.APIAttachNetworkServiceProviderToL2NetworkMsg = APIAttachNetworkServiceProviderToL2NetworkMsg;
    var APISearchNetworkServiceProviderMsg = (function () {
        function APISearchNetworkServiceProviderMsg() {
        }
        APISearchNetworkServiceProviderMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APISearchNetworkServiceProviderMsg': this
            };
            return msg;
        };
        return APISearchNetworkServiceProviderMsg;
    })();
    ApiHeader.APISearchNetworkServiceProviderMsg = APISearchNetworkServiceProviderMsg;
    var APIDetachNetworkServiceProviderFromL2NetworkMsg = (function () {
        function APIDetachNetworkServiceProviderFromL2NetworkMsg() {
        }
        APIDetachNetworkServiceProviderFromL2NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIDetachNetworkServiceProviderFromL2NetworkMsg': this
            };
            return msg;
        };
        return APIDetachNetworkServiceProviderFromL2NetworkMsg;
    })();
    ApiHeader.APIDetachNetworkServiceProviderFromL2NetworkMsg = APIDetachNetworkServiceProviderFromL2NetworkMsg;
    var APIQueryNetworkServiceProviderMsg = (function () {
        function APIQueryNetworkServiceProviderMsg() {
        }
        APIQueryNetworkServiceProviderMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIQueryNetworkServiceProviderMsg': this
            };
            return msg;
        };
        return APIQueryNetworkServiceProviderMsg;
    })();
    ApiHeader.APIQueryNetworkServiceProviderMsg = APIQueryNetworkServiceProviderMsg;
    var APIGetNetworkServiceTypesMsg = (function () {
        function APIGetNetworkServiceTypesMsg() {
        }
        APIGetNetworkServiceTypesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIGetNetworkServiceTypesMsg': this
            };
            return msg;
        };
        return APIGetNetworkServiceTypesMsg;
    })();
    ApiHeader.APIGetNetworkServiceTypesMsg = APIGetNetworkServiceTypesMsg;
    var APIGetNetworkServiceProviderMsg = (function () {
        function APIGetNetworkServiceProviderMsg() {
        }
        APIGetNetworkServiceProviderMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIGetNetworkServiceProviderMsg': this
            };
            return msg;
        };
        return APIGetNetworkServiceProviderMsg;
    })();
    ApiHeader.APIGetNetworkServiceProviderMsg = APIGetNetworkServiceProviderMsg;
    var APIListNetworkServiceProviderMsg = (function () {
        function APIListNetworkServiceProviderMsg() {
        }
        APIListNetworkServiceProviderMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.service.APIListNetworkServiceProviderMsg': this
            };
            return msg;
        };
        return APIListNetworkServiceProviderMsg;
    })();
    ApiHeader.APIListNetworkServiceProviderMsg = APIListNetworkServiceProviderMsg;
    var APIAttachL2NetworkToClusterMsg = (function () {
        function APIAttachL2NetworkToClusterMsg() {
        }
        APIAttachL2NetworkToClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIAttachL2NetworkToClusterMsg': this
            };
            return msg;
        };
        return APIAttachL2NetworkToClusterMsg;
    })();
    ApiHeader.APIAttachL2NetworkToClusterMsg = APIAttachL2NetworkToClusterMsg;
    var APIQueryL2VlanNetworkMsg = (function () {
        function APIQueryL2VlanNetworkMsg() {
        }
        APIQueryL2VlanNetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIQueryL2VlanNetworkMsg': this
            };
            return msg;
        };
        return APIQueryL2VlanNetworkMsg;
    })();
    ApiHeader.APIQueryL2VlanNetworkMsg = APIQueryL2VlanNetworkMsg;
    var APIGetL2NetworkMsg = (function () {
        function APIGetL2NetworkMsg() {
        }
        APIGetL2NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIGetL2NetworkMsg': this
            };
            return msg;
        };
        return APIGetL2NetworkMsg;
    })();
    ApiHeader.APIGetL2NetworkMsg = APIGetL2NetworkMsg;
    var APIListL2NetworkMsg = (function () {
        function APIListL2NetworkMsg() {
        }
        APIListL2NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIListL2NetworkMsg': this
            };
            return msg;
        };
        return APIListL2NetworkMsg;
    })();
    ApiHeader.APIListL2NetworkMsg = APIListL2NetworkMsg;
    var APISearchL2VlanNetworkMsg = (function () {
        function APISearchL2VlanNetworkMsg() {
        }
        APISearchL2VlanNetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APISearchL2VlanNetworkMsg': this
            };
            return msg;
        };
        return APISearchL2VlanNetworkMsg;
    })();
    ApiHeader.APISearchL2VlanNetworkMsg = APISearchL2VlanNetworkMsg;
    var APICreateL2VlanNetworkMsg = (function () {
        function APICreateL2VlanNetworkMsg() {
        }
        APICreateL2VlanNetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APICreateL2VlanNetworkMsg': this
            };
            return msg;
        };
        return APICreateL2VlanNetworkMsg;
    })();
    ApiHeader.APICreateL2VlanNetworkMsg = APICreateL2VlanNetworkMsg;
    var APIDetachL2NetworkFromClusterMsg = (function () {
        function APIDetachL2NetworkFromClusterMsg() {
        }
        APIDetachL2NetworkFromClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIDetachL2NetworkFromClusterMsg': this
            };
            return msg;
        };
        return APIDetachL2NetworkFromClusterMsg;
    })();
    ApiHeader.APIDetachL2NetworkFromClusterMsg = APIDetachL2NetworkFromClusterMsg;
    var APIDeleteL2NetworkMsg = (function () {
        function APIDeleteL2NetworkMsg() {
        }
        APIDeleteL2NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIDeleteL2NetworkMsg': this
            };
            return msg;
        };
        return APIDeleteL2NetworkMsg;
    })();
    ApiHeader.APIDeleteL2NetworkMsg = APIDeleteL2NetworkMsg;
    var APISearchL2NetworkMsg = (function () {
        function APISearchL2NetworkMsg() {
        }
        APISearchL2NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APISearchL2NetworkMsg': this
            };
            return msg;
        };
        return APISearchL2NetworkMsg;
    })();
    ApiHeader.APISearchL2NetworkMsg = APISearchL2NetworkMsg;
    var APICreateL2NoVlanNetworkMsg = (function () {
        function APICreateL2NoVlanNetworkMsg() {
        }
        APICreateL2NoVlanNetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APICreateL2NoVlanNetworkMsg': this
            };
            return msg;
        };
        return APICreateL2NoVlanNetworkMsg;
    })();
    ApiHeader.APICreateL2NoVlanNetworkMsg = APICreateL2NoVlanNetworkMsg;
    var APIListL2VlanNetworkMsg = (function () {
        function APIListL2VlanNetworkMsg() {
        }
        APIListL2VlanNetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIListL2VlanNetworkMsg': this
            };
            return msg;
        };
        return APIListL2VlanNetworkMsg;
    })();
    ApiHeader.APIListL2VlanNetworkMsg = APIListL2VlanNetworkMsg;
    var APIUpdateL2NetworkMsg = (function () {
        function APIUpdateL2NetworkMsg() {
        }
        APIUpdateL2NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIUpdateL2NetworkMsg': this
            };
            return msg;
        };
        return APIUpdateL2NetworkMsg;
    })();
    ApiHeader.APIUpdateL2NetworkMsg = APIUpdateL2NetworkMsg;
    var APIGetL2VlanNetworkMsg = (function () {
        function APIGetL2VlanNetworkMsg() {
        }
        APIGetL2VlanNetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIGetL2VlanNetworkMsg': this
            };
            return msg;
        };
        return APIGetL2VlanNetworkMsg;
    })();
    ApiHeader.APIGetL2VlanNetworkMsg = APIGetL2VlanNetworkMsg;
    var APIGetL2NetworkTypesMsg = (function () {
        function APIGetL2NetworkTypesMsg() {
        }
        APIGetL2NetworkTypesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIGetL2NetworkTypesMsg': this
            };
            return msg;
        };
        return APIGetL2NetworkTypesMsg;
    })();
    ApiHeader.APIGetL2NetworkTypesMsg = APIGetL2NetworkTypesMsg;
    var APIQueryL2NetworkMsg = (function () {
        function APIQueryL2NetworkMsg() {
        }
        APIQueryL2NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.network.l2.APIQueryL2NetworkMsg': this
            };
            return msg;
        };
        return APIQueryL2NetworkMsg;
    })();
    ApiHeader.APIQueryL2NetworkMsg = APIQueryL2NetworkMsg;
    var APIDeleteSearchIndexMsg = (function () {
        function APIDeleteSearchIndexMsg() {
        }
        APIDeleteSearchIndexMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.search.APIDeleteSearchIndexMsg': this
            };
            return msg;
        };
        return APIDeleteSearchIndexMsg;
    })();
    ApiHeader.APIDeleteSearchIndexMsg = APIDeleteSearchIndexMsg;
    var APISearchGenerateSqlTriggerMsg = (function () {
        function APISearchGenerateSqlTriggerMsg() {
        }
        APISearchGenerateSqlTriggerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.search.APISearchGenerateSqlTriggerMsg': this
            };
            return msg;
        };
        return APISearchGenerateSqlTriggerMsg;
    })();
    ApiHeader.APISearchGenerateSqlTriggerMsg = APISearchGenerateSqlTriggerMsg;
    var APICreateSearchIndexMsg = (function () {
        function APICreateSearchIndexMsg() {
        }
        APICreateSearchIndexMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.search.APICreateSearchIndexMsg': this
            };
            return msg;
        };
        return APICreateSearchIndexMsg;
    })();
    ApiHeader.APICreateSearchIndexMsg = APICreateSearchIndexMsg;
    var APIQueryUserTagMsg = (function () {
        function APIQueryUserTagMsg() {
        }
        APIQueryUserTagMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.tag.APIQueryUserTagMsg': this
            };
            return msg;
        };
        return APIQueryUserTagMsg;
    })();
    ApiHeader.APIQueryUserTagMsg = APIQueryUserTagMsg;
    var APIQuerySystemTagMsg = (function () {
        function APIQuerySystemTagMsg() {
        }
        APIQuerySystemTagMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.tag.APIQuerySystemTagMsg': this
            };
            return msg;
        };
        return APIQuerySystemTagMsg;
    })();
    ApiHeader.APIQuerySystemTagMsg = APIQuerySystemTagMsg;
    var APIDeleteTagMsg = (function () {
        function APIDeleteTagMsg() {
        }
        APIDeleteTagMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.tag.APIDeleteTagMsg': this
            };
            return msg;
        };
        return APIDeleteTagMsg;
    })();
    ApiHeader.APIDeleteTagMsg = APIDeleteTagMsg;
    var APICreateUserTagMsg = (function () {
        function APICreateUserTagMsg() {
        }
        APICreateUserTagMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.tag.APICreateUserTagMsg': this
            };
            return msg;
        };
        return APICreateUserTagMsg;
    })();
    ApiHeader.APICreateUserTagMsg = APICreateUserTagMsg;
    var APICreateSystemTagMsg = (function () {
        function APICreateSystemTagMsg() {
        }
        APICreateSystemTagMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.tag.APICreateSystemTagMsg': this
            };
            return msg;
        };
        return APICreateSystemTagMsg;
    })();
    ApiHeader.APICreateSystemTagMsg = APICreateSystemTagMsg;
    var APIUpdateSystemTagMsg = (function () {
        function APIUpdateSystemTagMsg() {
        }
        APIUpdateSystemTagMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.tag.APIUpdateSystemTagMsg': this
            };
            return msg;
        };
        return APIUpdateSystemTagMsg;
    })();
    ApiHeader.APIUpdateSystemTagMsg = APIUpdateSystemTagMsg;
    var APIQueryTagMsg = (function () {
        function APIQueryTagMsg() {
        }
        APIQueryTagMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.tag.APIQueryTagMsg': this
            };
            return msg;
        };
        return APIQueryTagMsg;
    })();
    ApiHeader.APIQueryTagMsg = APIQueryTagMsg;
    var APIQueryManagementNodeMsg = (function () {
        function APIQueryManagementNodeMsg() {
        }
        APIQueryManagementNodeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.managementnode.APIQueryManagementNodeMsg': this
            };
            return msg;
        };
        return APIQueryManagementNodeMsg;
    })();
    ApiHeader.APIQueryManagementNodeMsg = APIQueryManagementNodeMsg;
    var APIListManagementNodeMsg = (function () {
        function APIListManagementNodeMsg() {
        }
        APIListManagementNodeMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.managementnode.APIListManagementNodeMsg': this
            };
            return msg;
        };
        return APIListManagementNodeMsg;
    })();
    ApiHeader.APIListManagementNodeMsg = APIListManagementNodeMsg;
    var APICreateMessage = (function () {
        function APICreateMessage() {
        }
        APICreateMessage.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.message.APICreateMessage': this
            };
            return msg;
        };
        return APICreateMessage;
    })();
    ApiHeader.APICreateMessage = APICreateMessage;
    var APIListClusterMsg = (function () {
        function APIListClusterMsg() {
        }
        APIListClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.cluster.APIListClusterMsg': this
            };
            return msg;
        };
        return APIListClusterMsg;
    })();
    ApiHeader.APIListClusterMsg = APIListClusterMsg;
    var APIGetClusterMsg = (function () {
        function APIGetClusterMsg() {
        }
        APIGetClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.cluster.APIGetClusterMsg': this
            };
            return msg;
        };
        return APIGetClusterMsg;
    })();
    ApiHeader.APIGetClusterMsg = APIGetClusterMsg;
    var APISearchClusterMsg = (function () {
        function APISearchClusterMsg() {
        }
        APISearchClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.cluster.APISearchClusterMsg': this
            };
            return msg;
        };
        return APISearchClusterMsg;
    })();
    ApiHeader.APISearchClusterMsg = APISearchClusterMsg;
    var APIQueryClusterMsg = (function () {
        function APIQueryClusterMsg() {
        }
        APIQueryClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.cluster.APIQueryClusterMsg': this
            };
            return msg;
        };
        return APIQueryClusterMsg;
    })();
    ApiHeader.APIQueryClusterMsg = APIQueryClusterMsg;
    var APIDeleteClusterMsg = (function () {
        function APIDeleteClusterMsg() {
        }
        APIDeleteClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.cluster.APIDeleteClusterMsg': this
            };
            return msg;
        };
        return APIDeleteClusterMsg;
    })();
    ApiHeader.APIDeleteClusterMsg = APIDeleteClusterMsg;
    var APIUpdateClusterMsg = (function () {
        function APIUpdateClusterMsg() {
        }
        APIUpdateClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.cluster.APIUpdateClusterMsg': this
            };
            return msg;
        };
        return APIUpdateClusterMsg;
    })();
    ApiHeader.APIUpdateClusterMsg = APIUpdateClusterMsg;
    var APICreateClusterMsg = (function () {
        function APICreateClusterMsg() {
        }
        APICreateClusterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.cluster.APICreateClusterMsg': this
            };
            return msg;
        };
        return APICreateClusterMsg;
    })();
    ApiHeader.APICreateClusterMsg = APICreateClusterMsg;
    var APIChangeClusterStateMsg = (function () {
        function APIChangeClusterStateMsg() {
        }
        APIChangeClusterStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.cluster.APIChangeClusterStateMsg': this
            };
            return msg;
        };
        return APIChangeClusterStateMsg;
    })();
    ApiHeader.APIChangeClusterStateMsg = APIChangeClusterStateMsg;
    var APIAttachPolicyToUserGroupMsg = (function () {
        function APIAttachPolicyToUserGroupMsg() {
        }
        APIAttachPolicyToUserGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIAttachPolicyToUserGroupMsg': this
            };
            return msg;
        };
        return APIAttachPolicyToUserGroupMsg;
    })();
    ApiHeader.APIAttachPolicyToUserGroupMsg = APIAttachPolicyToUserGroupMsg;
    var APIRemoveUserFromGroupMsg = (function () {
        function APIRemoveUserFromGroupMsg() {
        }
        APIRemoveUserFromGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIRemoveUserFromGroupMsg': this
            };
            return msg;
        };
        return APIRemoveUserFromGroupMsg;
    })();
    ApiHeader.APIRemoveUserFromGroupMsg = APIRemoveUserFromGroupMsg;
    var APIAttachPolicyToUserMsg = (function () {
        function APIAttachPolicyToUserMsg() {
        }
        APIAttachPolicyToUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIAttachPolicyToUserMsg': this
            };
            return msg;
        };
        return APIAttachPolicyToUserMsg;
    })();
    ApiHeader.APIAttachPolicyToUserMsg = APIAttachPolicyToUserMsg;
    var APIGetAccountMsg = (function () {
        function APIGetAccountMsg() {
        }
        APIGetAccountMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIGetAccountMsg': this
            };
            return msg;
        };
        return APIGetAccountMsg;
    })();
    ApiHeader.APIGetAccountMsg = APIGetAccountMsg;
    var APIListAccountMsg = (function () {
        function APIListAccountMsg() {
        }
        APIListAccountMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIListAccountMsg': this
            };
            return msg;
        };
        return APIListAccountMsg;
    })();
    ApiHeader.APIListAccountMsg = APIListAccountMsg;
    var APIAddUserToGroupMsg = (function () {
        function APIAddUserToGroupMsg() {
        }
        APIAddUserToGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIAddUserToGroupMsg': this
            };
            return msg;
        };
        return APIAddUserToGroupMsg;
    })();
    ApiHeader.APIAddUserToGroupMsg = APIAddUserToGroupMsg;
    var APIQueryQuotaMsg = (function () {
        function APIQueryQuotaMsg() {
        }
        APIQueryQuotaMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIQueryQuotaMsg': this
            };
            return msg;
        };
        return APIQueryQuotaMsg;
    })();
    ApiHeader.APIQueryQuotaMsg = APIQueryQuotaMsg;
    var APIShareResourceMsg = (function () {
        function APIShareResourceMsg() {
        }
        APIShareResourceMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIShareResourceMsg': this
            };
            return msg;
        };
        return APIShareResourceMsg;
    })();
    ApiHeader.APIShareResourceMsg = APIShareResourceMsg;
    var APIListPolicyMsg = (function () {
        function APIListPolicyMsg() {
        }
        APIListPolicyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIListPolicyMsg': this
            };
            return msg;
        };
        return APIListPolicyMsg;
    })();
    ApiHeader.APIListPolicyMsg = APIListPolicyMsg;
    var APICreateAccountMsg = (function () {
        function APICreateAccountMsg() {
        }
        APICreateAccountMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APICreateAccountMsg': this
            };
            return msg;
        };
        return APICreateAccountMsg;
    })();
    ApiHeader.APICreateAccountMsg = APICreateAccountMsg;
    var APIDeleteAccountMsg = (function () {
        function APIDeleteAccountMsg() {
        }
        APIDeleteAccountMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIDeleteAccountMsg': this
            };
            return msg;
        };
        return APIDeleteAccountMsg;
    })();
    ApiHeader.APIDeleteAccountMsg = APIDeleteAccountMsg;
    var APICreateUserGroupMsg = (function () {
        function APICreateUserGroupMsg() {
        }
        APICreateUserGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APICreateUserGroupMsg': this
            };
            return msg;
        };
        return APICreateUserGroupMsg;
    })();
    ApiHeader.APICreateUserGroupMsg = APICreateUserGroupMsg;
    var APICreateUserMsg = (function () {
        function APICreateUserMsg() {
        }
        APICreateUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APICreateUserMsg': this
            };
            return msg;
        };
        return APICreateUserMsg;
    })();
    ApiHeader.APICreateUserMsg = APICreateUserMsg;
    var APILogInByUserMsg = (function () {
        function APILogInByUserMsg() {
        }
        APILogInByUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APILogInByUserMsg': this
            };
            return msg;
        };
        return APILogInByUserMsg;
    })();
    ApiHeader.APILogInByUserMsg = APILogInByUserMsg;
    var APISearchAccountMsg = (function () {
        function APISearchAccountMsg() {
        }
        APISearchAccountMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APISearchAccountMsg': this
            };
            return msg;
        };
        return APISearchAccountMsg;
    })();
    ApiHeader.APISearchAccountMsg = APISearchAccountMsg;
    var APISearchPolicyMsg = (function () {
        function APISearchPolicyMsg() {
        }
        APISearchPolicyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APISearchPolicyMsg': this
            };
            return msg;
        };
        return APISearchPolicyMsg;
    })();
    ApiHeader.APISearchPolicyMsg = APISearchPolicyMsg;
    var APISessionMessage = (function () {
        function APISessionMessage() {
        }
        APISessionMessage.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APISessionMessage': this
            };
            return msg;
        };
        return APISessionMessage;
    })();
    ApiHeader.APISessionMessage = APISessionMessage;
    var APIGetUserMsg = (function () {
        function APIGetUserMsg() {
        }
        APIGetUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIGetUserMsg': this
            };
            return msg;
        };
        return APIGetUserMsg;
    })();
    ApiHeader.APIGetUserMsg = APIGetUserMsg;
    var APIGetUserGroupMsg = (function () {
        function APIGetUserGroupMsg() {
        }
        APIGetUserGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIGetUserGroupMsg': this
            };
            return msg;
        };
        return APIGetUserGroupMsg;
    })();
    ApiHeader.APIGetUserGroupMsg = APIGetUserGroupMsg;
    var APIDetachPolicyFromUserGroupMsg = (function () {
        function APIDetachPolicyFromUserGroupMsg() {
        }
        APIDetachPolicyFromUserGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIDetachPolicyFromUserGroupMsg': this
            };
            return msg;
        };
        return APIDetachPolicyFromUserGroupMsg;
    })();
    ApiHeader.APIDetachPolicyFromUserGroupMsg = APIDetachPolicyFromUserGroupMsg;
    var APIUpdateQuotaMsg = (function () {
        function APIUpdateQuotaMsg() {
        }
        APIUpdateQuotaMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIUpdateQuotaMsg': this
            };
            return msg;
        };
        return APIUpdateQuotaMsg;
    })();
    ApiHeader.APIUpdateQuotaMsg = APIUpdateQuotaMsg;
    var APIQueryAccountMsg = (function () {
        function APIQueryAccountMsg() {
        }
        APIQueryAccountMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIQueryAccountMsg': this
            };
            return msg;
        };
        return APIQueryAccountMsg;
    })();
    ApiHeader.APIQueryAccountMsg = APIQueryAccountMsg;
    var APIQueryPolicyMsg = (function () {
        function APIQueryPolicyMsg() {
        }
        APIQueryPolicyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIQueryPolicyMsg': this
            };
            return msg;
        };
        return APIQueryPolicyMsg;
    })();
    ApiHeader.APIQueryPolicyMsg = APIQueryPolicyMsg;
    var APIQueryUserMsg = (function () {
        function APIQueryUserMsg() {
        }
        APIQueryUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIQueryUserMsg': this
            };
            return msg;
        };
        return APIQueryUserMsg;
    })();
    ApiHeader.APIQueryUserMsg = APIQueryUserMsg;
    var APIDeletePolicyMsg = (function () {
        function APIDeletePolicyMsg() {
        }
        APIDeletePolicyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIDeletePolicyMsg': this
            };
            return msg;
        };
        return APIDeletePolicyMsg;
    })();
    ApiHeader.APIDeletePolicyMsg = APIDeletePolicyMsg;
    var APIRevokeResourceSharingMsg = (function () {
        function APIRevokeResourceSharingMsg() {
        }
        APIRevokeResourceSharingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIRevokeResourceSharingMsg': this
            };
            return msg;
        };
        return APIRevokeResourceSharingMsg;
    })();
    ApiHeader.APIRevokeResourceSharingMsg = APIRevokeResourceSharingMsg;
    var APILogInByAccountMsg = (function () {
        function APILogInByAccountMsg() {
        }
        APILogInByAccountMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APILogInByAccountMsg': this
            };
            return msg;
        };
        return APILogInByAccountMsg;
    })();
    ApiHeader.APILogInByAccountMsg = APILogInByAccountMsg;
    var APIValidateSessionMsg = (function () {
        function APIValidateSessionMsg() {
        }
        APIValidateSessionMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIValidateSessionMsg': this
            };
            return msg;
        };
        return APIValidateSessionMsg;
    })();
    ApiHeader.APIValidateSessionMsg = APIValidateSessionMsg;
    var APISearchUserGroupMsg = (function () {
        function APISearchUserGroupMsg() {
        }
        APISearchUserGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APISearchUserGroupMsg': this
            };
            return msg;
        };
        return APISearchUserGroupMsg;
    })();
    ApiHeader.APISearchUserGroupMsg = APISearchUserGroupMsg;
    var APIListUserMsg = (function () {
        function APIListUserMsg() {
        }
        APIListUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIListUserMsg': this
            };
            return msg;
        };
        return APIListUserMsg;
    })();
    ApiHeader.APIListUserMsg = APIListUserMsg;
    var APIDeleteUserMsg = (function () {
        function APIDeleteUserMsg() {
        }
        APIDeleteUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIDeleteUserMsg': this
            };
            return msg;
        };
        return APIDeleteUserMsg;
    })();
    ApiHeader.APIDeleteUserMsg = APIDeleteUserMsg;
    var APIUpdateUserMsg = (function () {
        function APIUpdateUserMsg() {
        }
        APIUpdateUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIUpdateUserMsg': this
            };
            return msg;
        };
        return APIUpdateUserMsg;
    })();
    ApiHeader.APIUpdateUserMsg = APIUpdateUserMsg;
    var APISearchUserMsg = (function () {
        function APISearchUserMsg() {
        }
        APISearchUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APISearchUserMsg': this
            };
            return msg;
        };
        return APISearchUserMsg;
    })();
    ApiHeader.APISearchUserMsg = APISearchUserMsg;
    var APIUpdateAccountMsg = (function () {
        function APIUpdateAccountMsg() {
        }
        APIUpdateAccountMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIUpdateAccountMsg': this
            };
            return msg;
        };
        return APIUpdateAccountMsg;
    })();
    ApiHeader.APIUpdateAccountMsg = APIUpdateAccountMsg;
    var APIDeleteUserGroupMsg = (function () {
        function APIDeleteUserGroupMsg() {
        }
        APIDeleteUserGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIDeleteUserGroupMsg': this
            };
            return msg;
        };
        return APIDeleteUserGroupMsg;
    })();
    ApiHeader.APIDeleteUserGroupMsg = APIDeleteUserGroupMsg;
    var APILogOutMsg = (function () {
        function APILogOutMsg() {
        }
        APILogOutMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APILogOutMsg': this
            };
            return msg;
        };
        return APILogOutMsg;
    })();
    ApiHeader.APILogOutMsg = APILogOutMsg;
    var APIGetPolicyMsg = (function () {
        function APIGetPolicyMsg() {
        }
        APIGetPolicyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIGetPolicyMsg': this
            };
            return msg;
        };
        return APIGetPolicyMsg;
    })();
    ApiHeader.APIGetPolicyMsg = APIGetPolicyMsg;
    (function (StatementEffect) {
        StatementEffect[StatementEffect["Allow"] = 0] = "Allow";
        StatementEffect[StatementEffect["Deny"] = 1] = "Deny";
    })(ApiHeader.StatementEffect || (ApiHeader.StatementEffect = {}));
    var StatementEffect = ApiHeader.StatementEffect;
    var Statement = (function () {
        function Statement() {
        }
        return Statement;
    })();
    ApiHeader.Statement = Statement;
    var APICreatePolicyMsg = (function () {
        function APICreatePolicyMsg() {
        }
        APICreatePolicyMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APICreatePolicyMsg': this
            };
            return msg;
        };
        return APICreatePolicyMsg;
    })();
    ApiHeader.APICreatePolicyMsg = APICreatePolicyMsg;
    var APIDetachPolicyFromUserMsg = (function () {
        function APIDetachPolicyFromUserMsg() {
        }
        APIDetachPolicyFromUserMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIDetachPolicyFromUserMsg': this
            };
            return msg;
        };
        return APIDetachPolicyFromUserMsg;
    })();
    ApiHeader.APIDetachPolicyFromUserMsg = APIDetachPolicyFromUserMsg;
    var APIQueryUserGroupMsg = (function () {
        function APIQueryUserGroupMsg() {
        }
        APIQueryUserGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.identity.APIQueryUserGroupMsg': this
            };
            return msg;
        };
        return APIQueryUserGroupMsg;
    })();
    ApiHeader.APIQueryUserGroupMsg = APIQueryUserGroupMsg;
    var APIUpdateZoneMsg = (function () {
        function APIUpdateZoneMsg() {
        }
        APIUpdateZoneMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.zone.APIUpdateZoneMsg': this
            };
            return msg;
        };
        return APIUpdateZoneMsg;
    })();
    ApiHeader.APIUpdateZoneMsg = APIUpdateZoneMsg;
    var APIGetZoneMsg = (function () {
        function APIGetZoneMsg() {
        }
        APIGetZoneMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.zone.APIGetZoneMsg': this
            };
            return msg;
        };
        return APIGetZoneMsg;
    })();
    ApiHeader.APIGetZoneMsg = APIGetZoneMsg;
    var APIDeleteZoneMsg = (function () {
        function APIDeleteZoneMsg() {
        }
        APIDeleteZoneMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.zone.APIDeleteZoneMsg': this
            };
            return msg;
        };
        return APIDeleteZoneMsg;
    })();
    ApiHeader.APIDeleteZoneMsg = APIDeleteZoneMsg;
    var APICreateZoneMsg = (function () {
        function APICreateZoneMsg() {
        }
        APICreateZoneMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.zone.APICreateZoneMsg': this
            };
            return msg;
        };
        return APICreateZoneMsg;
    })();
    ApiHeader.APICreateZoneMsg = APICreateZoneMsg;
    var APISearchZoneMsg = (function () {
        function APISearchZoneMsg() {
        }
        APISearchZoneMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.zone.APISearchZoneMsg': this
            };
            return msg;
        };
        return APISearchZoneMsg;
    })();
    ApiHeader.APISearchZoneMsg = APISearchZoneMsg;
    var APIQueryZoneMsg = (function () {
        function APIQueryZoneMsg() {
        }
        APIQueryZoneMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.zone.APIQueryZoneMsg': this
            };
            return msg;
        };
        return APIQueryZoneMsg;
    })();
    ApiHeader.APIQueryZoneMsg = APIQueryZoneMsg;
    var APIListZonesMsg = (function () {
        function APIListZonesMsg() {
        }
        APIListZonesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.zone.APIListZonesMsg': this
            };
            return msg;
        };
        return APIListZonesMsg;
    })();
    ApiHeader.APIListZonesMsg = APIListZonesMsg;
    var APIChangeZoneStateMsg = (function () {
        function APIChangeZoneStateMsg() {
        }
        APIChangeZoneStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.zone.APIChangeZoneStateMsg': this
            };
            return msg;
        };
        return APIChangeZoneStateMsg;
    })();
    ApiHeader.APIChangeZoneStateMsg = APIChangeZoneStateMsg;
    var APIChangeHostStateMsg = (function () {
        function APIChangeHostStateMsg() {
        }
        APIChangeHostStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APIChangeHostStateMsg': this
            };
            return msg;
        };
        return APIChangeHostStateMsg;
    })();
    ApiHeader.APIChangeHostStateMsg = APIChangeHostStateMsg;
    var APIReconnectHostMsg = (function () {
        function APIReconnectHostMsg() {
        }
        APIReconnectHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APIReconnectHostMsg': this
            };
            return msg;
        };
        return APIReconnectHostMsg;
    })();
    ApiHeader.APIReconnectHostMsg = APIReconnectHostMsg;
    var APIListHostMsg = (function () {
        function APIListHostMsg() {
        }
        APIListHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APIListHostMsg': this
            };
            return msg;
        };
        return APIListHostMsg;
    })();
    ApiHeader.APIListHostMsg = APIListHostMsg;
    var APIUpdateHostMsg = (function () {
        function APIUpdateHostMsg() {
        }
        APIUpdateHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APIUpdateHostMsg': this
            };
            return msg;
        };
        return APIUpdateHostMsg;
    })();
    ApiHeader.APIUpdateHostMsg = APIUpdateHostMsg;
    var APIDeleteHostMsg = (function () {
        function APIDeleteHostMsg() {
        }
        APIDeleteHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APIDeleteHostMsg': this
            };
            return msg;
        };
        return APIDeleteHostMsg;
    })();
    ApiHeader.APIDeleteHostMsg = APIDeleteHostMsg;
    var APIGetHostMsg = (function () {
        function APIGetHostMsg() {
        }
        APIGetHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APIGetHostMsg': this
            };
            return msg;
        };
        return APIGetHostMsg;
    })();
    ApiHeader.APIGetHostMsg = APIGetHostMsg;
    var APISearchHostMsg = (function () {
        function APISearchHostMsg() {
        }
        APISearchHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APISearchHostMsg': this
            };
            return msg;
        };
        return APISearchHostMsg;
    })();
    ApiHeader.APISearchHostMsg = APISearchHostMsg;
    var APIGetHypervisorTypesMsg = (function () {
        function APIGetHypervisorTypesMsg() {
        }
        APIGetHypervisorTypesMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APIGetHypervisorTypesMsg': this
            };
            return msg;
        };
        return APIGetHypervisorTypesMsg;
    })();
    ApiHeader.APIGetHypervisorTypesMsg = APIGetHypervisorTypesMsg;
    var APIQueryHostMsg = (function () {
        function APIQueryHostMsg() {
        }
        APIQueryHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.host.APIQueryHostMsg': this
            };
            return msg;
        };
        return APIQueryHostMsg;
    })();
    ApiHeader.APIQueryHostMsg = APIQueryHostMsg;
    var APIAddSimulatorHostMsg = (function () {
        function APIAddSimulatorHostMsg() {
        }
        APIAddSimulatorHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.simulator.APIAddSimulatorHostMsg': this
            };
            return msg;
        };
        return APIAddSimulatorHostMsg;
    })();
    ApiHeader.APIAddSimulatorHostMsg = APIAddSimulatorHostMsg;
    var APIAddSimulatorPrimaryStorageMsg = (function () {
        function APIAddSimulatorPrimaryStorageMsg() {
        }
        APIAddSimulatorPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.simulator.storage.primary.APIAddSimulatorPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIAddSimulatorPrimaryStorageMsg;
    })();
    ApiHeader.APIAddSimulatorPrimaryStorageMsg = APIAddSimulatorPrimaryStorageMsg;
    var APIAddSimulatorBackupStorageMsg = (function () {
        function APIAddSimulatorBackupStorageMsg() {
        }
        APIAddSimulatorBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.header.simulator.storage.backup.APIAddSimulatorBackupStorageMsg': this
            };
            return msg;
        };
        return APIAddSimulatorBackupStorageMsg;
    })();
    ApiHeader.APIAddSimulatorBackupStorageMsg = APIAddSimulatorBackupStorageMsg;
    var APIListApplianceVmMsg = (function () {
        function APIListApplianceVmMsg() {
        }
        APIListApplianceVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.appliancevm.APIListApplianceVmMsg': this
            };
            return msg;
        };
        return APIListApplianceVmMsg;
    })();
    ApiHeader.APIListApplianceVmMsg = APIListApplianceVmMsg;
    var APIQueryApplianceVmMsg = (function () {
        function APIQueryApplianceVmMsg() {
        }
        APIQueryApplianceVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.appliancevm.APIQueryApplianceVmMsg': this
            };
            return msg;
        };
        return APIQueryApplianceVmMsg;
    })();
    ApiHeader.APIQueryApplianceVmMsg = APIQueryApplianceVmMsg;
    var APIAddIscsiFileSystemBackendPrimaryStorageMsg = (function () {
        function APIAddIscsiFileSystemBackendPrimaryStorageMsg() {
        }
        APIAddIscsiFileSystemBackendPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.primary.iscsi.APIAddIscsiFileSystemBackendPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIAddIscsiFileSystemBackendPrimaryStorageMsg;
    })();
    ApiHeader.APIAddIscsiFileSystemBackendPrimaryStorageMsg = APIAddIscsiFileSystemBackendPrimaryStorageMsg;
    var APIQueryIscsiFileSystemBackendPrimaryStorageMsg = (function () {
        function APIQueryIscsiFileSystemBackendPrimaryStorageMsg() {
        }
        APIQueryIscsiFileSystemBackendPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.primary.iscsi.APIQueryIscsiFileSystemBackendPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIQueryIscsiFileSystemBackendPrimaryStorageMsg;
    })();
    ApiHeader.APIQueryIscsiFileSystemBackendPrimaryStorageMsg = APIQueryIscsiFileSystemBackendPrimaryStorageMsg;
    var APIUpdateIscsiFileSystemBackendPrimaryStorageMsg = (function () {
        function APIUpdateIscsiFileSystemBackendPrimaryStorageMsg() {
        }
        APIUpdateIscsiFileSystemBackendPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.primary.iscsi.APIUpdateIscsiFileSystemBackendPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIUpdateIscsiFileSystemBackendPrimaryStorageMsg;
    })();
    ApiHeader.APIUpdateIscsiFileSystemBackendPrimaryStorageMsg = APIUpdateIscsiFileSystemBackendPrimaryStorageMsg;
    var APIAddLocalPrimaryStorageMsg = (function () {
        function APIAddLocalPrimaryStorageMsg() {
        }
        APIAddLocalPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.primary.local.APIAddLocalPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIAddLocalPrimaryStorageMsg;
    })();
    ApiHeader.APIAddLocalPrimaryStorageMsg = APIAddLocalPrimaryStorageMsg;
    var APIQueryCephPrimaryStorageMsg = (function () {
        function APIQueryCephPrimaryStorageMsg() {
        }
        APIQueryCephPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.ceph.primary.APIQueryCephPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIQueryCephPrimaryStorageMsg;
    })();
    ApiHeader.APIQueryCephPrimaryStorageMsg = APIQueryCephPrimaryStorageMsg;
    var APIAddCephPrimaryStorageMsg = (function () {
        function APIAddCephPrimaryStorageMsg() {
        }
        APIAddCephPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.ceph.primary.APIAddCephPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIAddCephPrimaryStorageMsg;
    })();
    ApiHeader.APIAddCephPrimaryStorageMsg = APIAddCephPrimaryStorageMsg;
    var APIAddMonToCephPrimaryStorageMsg = (function () {
        function APIAddMonToCephPrimaryStorageMsg() {
        }
        APIAddMonToCephPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.ceph.primary.APIAddMonToCephPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIAddMonToCephPrimaryStorageMsg;
    })();
    ApiHeader.APIAddMonToCephPrimaryStorageMsg = APIAddMonToCephPrimaryStorageMsg;
    var APIRemoveMonFromCephPrimaryStorageMsg = (function () {
        function APIRemoveMonFromCephPrimaryStorageMsg() {
        }
        APIRemoveMonFromCephPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.ceph.primary.APIRemoveMonFromCephPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIRemoveMonFromCephPrimaryStorageMsg;
    })();
    ApiHeader.APIRemoveMonFromCephPrimaryStorageMsg = APIRemoveMonFromCephPrimaryStorageMsg;
    var APIAddCephBackupStorageMsg = (function () {
        function APIAddCephBackupStorageMsg() {
        }
        APIAddCephBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.ceph.backup.APIAddCephBackupStorageMsg': this
            };
            return msg;
        };
        return APIAddCephBackupStorageMsg;
    })();
    ApiHeader.APIAddCephBackupStorageMsg = APIAddCephBackupStorageMsg;
    var APIAddMonToCephBackupStorageMsg = (function () {
        function APIAddMonToCephBackupStorageMsg() {
        }
        APIAddMonToCephBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.ceph.backup.APIAddMonToCephBackupStorageMsg': this
            };
            return msg;
        };
        return APIAddMonToCephBackupStorageMsg;
    })();
    ApiHeader.APIAddMonToCephBackupStorageMsg = APIAddMonToCephBackupStorageMsg;
    var APIQueryCephBackupStorageMsg = (function () {
        function APIQueryCephBackupStorageMsg() {
        }
        APIQueryCephBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.ceph.backup.APIQueryCephBackupStorageMsg': this
            };
            return msg;
        };
        return APIQueryCephBackupStorageMsg;
    })();
    ApiHeader.APIQueryCephBackupStorageMsg = APIQueryCephBackupStorageMsg;
    var APIRemoveMonFromCephBackupStorageMsg = (function () {
        function APIRemoveMonFromCephBackupStorageMsg() {
        }
        APIRemoveMonFromCephBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.ceph.backup.APIRemoveMonFromCephBackupStorageMsg': this
            };
            return msg;
        };
        return APIRemoveMonFromCephBackupStorageMsg;
    })();
    ApiHeader.APIRemoveMonFromCephBackupStorageMsg = APIRemoveMonFromCephBackupStorageMsg;
    var APIUpdateKVMHostMsg = (function () {
        function APIUpdateKVMHostMsg() {
        }
        APIUpdateKVMHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.kvm.APIUpdateKVMHostMsg': this
            };
            return msg;
        };
        return APIUpdateKVMHostMsg;
    })();
    ApiHeader.APIUpdateKVMHostMsg = APIUpdateKVMHostMsg;
    var APIAddKVMHostMsg = (function () {
        function APIAddKVMHostMsg() {
        }
        APIAddKVMHostMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.kvm.APIAddKVMHostMsg': this
            };
            return msg;
        };
        return APIAddKVMHostMsg;
    })();
    ApiHeader.APIAddKVMHostMsg = APIAddKVMHostMsg;
    var APIAddNfsPrimaryStorageMsg = (function () {
        function APIAddNfsPrimaryStorageMsg() {
        }
        APIAddNfsPrimaryStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.primary.nfs.APIAddNfsPrimaryStorageMsg': this
            };
            return msg;
        };
        return APIAddNfsPrimaryStorageMsg;
    })();
    ApiHeader.APIAddNfsPrimaryStorageMsg = APIAddNfsPrimaryStorageMsg;
    var APIGetSftpBackupStorageMsg = (function () {
        function APIGetSftpBackupStorageMsg() {
        }
        APIGetSftpBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.backup.sftp.APIGetSftpBackupStorageMsg': this
            };
            return msg;
        };
        return APIGetSftpBackupStorageMsg;
    })();
    ApiHeader.APIGetSftpBackupStorageMsg = APIGetSftpBackupStorageMsg;
    var APISearchSftpBackupStorageMsg = (function () {
        function APISearchSftpBackupStorageMsg() {
        }
        APISearchSftpBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.backup.sftp.APISearchSftpBackupStorageMsg': this
            };
            return msg;
        };
        return APISearchSftpBackupStorageMsg;
    })();
    ApiHeader.APISearchSftpBackupStorageMsg = APISearchSftpBackupStorageMsg;
    var APIQuerySftpBackupStorageMsg = (function () {
        function APIQuerySftpBackupStorageMsg() {
        }
        APIQuerySftpBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.backup.sftp.APIQuerySftpBackupStorageMsg': this
            };
            return msg;
        };
        return APIQuerySftpBackupStorageMsg;
    })();
    ApiHeader.APIQuerySftpBackupStorageMsg = APIQuerySftpBackupStorageMsg;
    var APIReconnectSftpBackupStorageMsg = (function () {
        function APIReconnectSftpBackupStorageMsg() {
        }
        APIReconnectSftpBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.backup.sftp.APIReconnectSftpBackupStorageMsg': this
            };
            return msg;
        };
        return APIReconnectSftpBackupStorageMsg;
    })();
    ApiHeader.APIReconnectSftpBackupStorageMsg = APIReconnectSftpBackupStorageMsg;
    var APIUpdateSftpBackupStorageMsg = (function () {
        function APIUpdateSftpBackupStorageMsg() {
        }
        APIUpdateSftpBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.backup.sftp.APIUpdateSftpBackupStorageMsg': this
            };
            return msg;
        };
        return APIUpdateSftpBackupStorageMsg;
    })();
    ApiHeader.APIUpdateSftpBackupStorageMsg = APIUpdateSftpBackupStorageMsg;
    var APIAddSftpBackupStorageMsg = (function () {
        function APIAddSftpBackupStorageMsg() {
        }
        APIAddSftpBackupStorageMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.storage.backup.sftp.APIAddSftpBackupStorageMsg': this
            };
            return msg;
        };
        return APIAddSftpBackupStorageMsg;
    })();
    ApiHeader.APIAddSftpBackupStorageMsg = APIAddSftpBackupStorageMsg;
    var APIReconnectVirtualRouterMsg = (function () {
        function APIReconnectVirtualRouterMsg() {
        }
        APIReconnectVirtualRouterMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APIReconnectVirtualRouterMsg': this
            };
            return msg;
        };
        return APIReconnectVirtualRouterMsg;
    })();
    ApiHeader.APIReconnectVirtualRouterMsg = APIReconnectVirtualRouterMsg;
    var APICreateVirtualRouterVmMsg = (function () {
        function APICreateVirtualRouterVmMsg() {
        }
        APICreateVirtualRouterVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APICreateVirtualRouterVmMsg': this
            };
            return msg;
        };
        return APICreateVirtualRouterVmMsg;
    })();
    ApiHeader.APICreateVirtualRouterVmMsg = APICreateVirtualRouterVmMsg;
    var APIGetVirtualRouterOfferingMsg = (function () {
        function APIGetVirtualRouterOfferingMsg() {
        }
        APIGetVirtualRouterOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APIGetVirtualRouterOfferingMsg': this
            };
            return msg;
        };
        return APIGetVirtualRouterOfferingMsg;
    })();
    ApiHeader.APIGetVirtualRouterOfferingMsg = APIGetVirtualRouterOfferingMsg;
    var APISearchVirtualRouterVmMsg = (function () {
        function APISearchVirtualRouterVmMsg() {
        }
        APISearchVirtualRouterVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APISearchVirtualRouterVmMsg': this
            };
            return msg;
        };
        return APISearchVirtualRouterVmMsg;
    })();
    ApiHeader.APISearchVirtualRouterVmMsg = APISearchVirtualRouterVmMsg;
    var APIQueryVirtualRouterOfferingMsg = (function () {
        function APIQueryVirtualRouterOfferingMsg() {
        }
        APIQueryVirtualRouterOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APIQueryVirtualRouterOfferingMsg': this
            };
            return msg;
        };
        return APIQueryVirtualRouterOfferingMsg;
    })();
    ApiHeader.APIQueryVirtualRouterOfferingMsg = APIQueryVirtualRouterOfferingMsg;
    var APICreateVirtualRouterOfferingMsg = (function () {
        function APICreateVirtualRouterOfferingMsg() {
        }
        APICreateVirtualRouterOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APICreateVirtualRouterOfferingMsg': this
            };
            return msg;
        };
        return APICreateVirtualRouterOfferingMsg;
    })();
    ApiHeader.APICreateVirtualRouterOfferingMsg = APICreateVirtualRouterOfferingMsg;
    var APIQueryVirtualRouterVmMsg = (function () {
        function APIQueryVirtualRouterVmMsg() {
        }
        APIQueryVirtualRouterVmMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APIQueryVirtualRouterVmMsg': this
            };
            return msg;
        };
        return APIQueryVirtualRouterVmMsg;
    })();
    ApiHeader.APIQueryVirtualRouterVmMsg = APIQueryVirtualRouterVmMsg;
    var APISearchVirtualRouterOffingMsg = (function () {
        function APISearchVirtualRouterOffingMsg() {
        }
        APISearchVirtualRouterOffingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APISearchVirtualRouterOffingMsg': this
            };
            return msg;
        };
        return APISearchVirtualRouterOffingMsg;
    })();
    ApiHeader.APISearchVirtualRouterOffingMsg = APISearchVirtualRouterOffingMsg;
    var APIUpdateVirtualRouterOfferingMsg = (function () {
        function APIUpdateVirtualRouterOfferingMsg() {
        }
        APIUpdateVirtualRouterOfferingMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.virtualrouter.APIUpdateVirtualRouterOfferingMsg': this
            };
            return msg;
        };
        return APIUpdateVirtualRouterOfferingMsg;
    })();
    ApiHeader.APIUpdateVirtualRouterOfferingMsg = APIUpdateVirtualRouterOfferingMsg;
    var APIAttachPortForwardingRuleMsg = (function () {
        function APIAttachPortForwardingRuleMsg() {
        }
        APIAttachPortForwardingRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APIAttachPortForwardingRuleMsg': this
            };
            return msg;
        };
        return APIAttachPortForwardingRuleMsg;
    })();
    ApiHeader.APIAttachPortForwardingRuleMsg = APIAttachPortForwardingRuleMsg;
    var APIDetachPortForwardingRuleMsg = (function () {
        function APIDetachPortForwardingRuleMsg() {
        }
        APIDetachPortForwardingRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APIDetachPortForwardingRuleMsg': this
            };
            return msg;
        };
        return APIDetachPortForwardingRuleMsg;
    })();
    ApiHeader.APIDetachPortForwardingRuleMsg = APIDetachPortForwardingRuleMsg;
    var APIGetPortForwardingAttachableVmNicsMsg = (function () {
        function APIGetPortForwardingAttachableVmNicsMsg() {
        }
        APIGetPortForwardingAttachableVmNicsMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APIGetPortForwardingAttachableVmNicsMsg': this
            };
            return msg;
        };
        return APIGetPortForwardingAttachableVmNicsMsg;
    })();
    ApiHeader.APIGetPortForwardingAttachableVmNicsMsg = APIGetPortForwardingAttachableVmNicsMsg;
    var APIChangePortForwardingRuleStateMsg = (function () {
        function APIChangePortForwardingRuleStateMsg() {
        }
        APIChangePortForwardingRuleStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APIChangePortForwardingRuleStateMsg': this
            };
            return msg;
        };
        return APIChangePortForwardingRuleStateMsg;
    })();
    ApiHeader.APIChangePortForwardingRuleStateMsg = APIChangePortForwardingRuleStateMsg;
    var APIUpdatePortForwardingRuleMsg = (function () {
        function APIUpdatePortForwardingRuleMsg() {
        }
        APIUpdatePortForwardingRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APIUpdatePortForwardingRuleMsg': this
            };
            return msg;
        };
        return APIUpdatePortForwardingRuleMsg;
    })();
    ApiHeader.APIUpdatePortForwardingRuleMsg = APIUpdatePortForwardingRuleMsg;
    var APIListPortForwardingRuleMsg = (function () {
        function APIListPortForwardingRuleMsg() {
        }
        APIListPortForwardingRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APIListPortForwardingRuleMsg': this
            };
            return msg;
        };
        return APIListPortForwardingRuleMsg;
    })();
    ApiHeader.APIListPortForwardingRuleMsg = APIListPortForwardingRuleMsg;
    var APICreatePortForwardingRuleMsg = (function () {
        function APICreatePortForwardingRuleMsg() {
        }
        APICreatePortForwardingRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APICreatePortForwardingRuleMsg': this
            };
            return msg;
        };
        return APICreatePortForwardingRuleMsg;
    })();
    ApiHeader.APICreatePortForwardingRuleMsg = APICreatePortForwardingRuleMsg;
    var APIQueryPortForwardingRuleMsg = (function () {
        function APIQueryPortForwardingRuleMsg() {
        }
        APIQueryPortForwardingRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APIQueryPortForwardingRuleMsg': this
            };
            return msg;
        };
        return APIQueryPortForwardingRuleMsg;
    })();
    ApiHeader.APIQueryPortForwardingRuleMsg = APIQueryPortForwardingRuleMsg;
    var APIDeletePortForwardingRuleMsg = (function () {
        function APIDeletePortForwardingRuleMsg() {
        }
        APIDeletePortForwardingRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.portforwarding.APIDeletePortForwardingRuleMsg': this
            };
            return msg;
        };
        return APIDeletePortForwardingRuleMsg;
    })();
    ApiHeader.APIDeletePortForwardingRuleMsg = APIDeletePortForwardingRuleMsg;
    var APIDetachEipMsg = (function () {
        function APIDetachEipMsg() {
        }
        APIDetachEipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.eip.APIDetachEipMsg': this
            };
            return msg;
        };
        return APIDetachEipMsg;
    })();
    ApiHeader.APIDetachEipMsg = APIDetachEipMsg;
    var APIGetEipAttachableVmNicsMsg = (function () {
        function APIGetEipAttachableVmNicsMsg() {
        }
        APIGetEipAttachableVmNicsMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.eip.APIGetEipAttachableVmNicsMsg': this
            };
            return msg;
        };
        return APIGetEipAttachableVmNicsMsg;
    })();
    ApiHeader.APIGetEipAttachableVmNicsMsg = APIGetEipAttachableVmNicsMsg;
    var APIUpdateEipMsg = (function () {
        function APIUpdateEipMsg() {
        }
        APIUpdateEipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.eip.APIUpdateEipMsg': this
            };
            return msg;
        };
        return APIUpdateEipMsg;
    })();
    ApiHeader.APIUpdateEipMsg = APIUpdateEipMsg;
    var APIQueryEipMsg = (function () {
        function APIQueryEipMsg() {
        }
        APIQueryEipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.eip.APIQueryEipMsg': this
            };
            return msg;
        };
        return APIQueryEipMsg;
    })();
    ApiHeader.APIQueryEipMsg = APIQueryEipMsg;
    var APIChangeEipStateMsg = (function () {
        function APIChangeEipStateMsg() {
        }
        APIChangeEipStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.eip.APIChangeEipStateMsg': this
            };
            return msg;
        };
        return APIChangeEipStateMsg;
    })();
    ApiHeader.APIChangeEipStateMsg = APIChangeEipStateMsg;
    var APIDeleteEipMsg = (function () {
        function APIDeleteEipMsg() {
        }
        APIDeleteEipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.eip.APIDeleteEipMsg': this
            };
            return msg;
        };
        return APIDeleteEipMsg;
    })();
    ApiHeader.APIDeleteEipMsg = APIDeleteEipMsg;
    var APICreateEipMsg = (function () {
        function APICreateEipMsg() {
        }
        APICreateEipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.eip.APICreateEipMsg': this
            };
            return msg;
        };
        return APICreateEipMsg;
    })();
    ApiHeader.APICreateEipMsg = APICreateEipMsg;
    var APIAttachEipMsg = (function () {
        function APIAttachEipMsg() {
        }
        APIAttachEipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.eip.APIAttachEipMsg': this
            };
            return msg;
        };
        return APIAttachEipMsg;
    })();
    ApiHeader.APIAttachEipMsg = APIAttachEipMsg;
    var APIQueryLoadBalancerListenerMsg = (function () {
        function APIQueryLoadBalancerListenerMsg() {
        }
        APIQueryLoadBalancerListenerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APIQueryLoadBalancerListenerMsg': this
            };
            return msg;
        };
        return APIQueryLoadBalancerListenerMsg;
    })();
    ApiHeader.APIQueryLoadBalancerListenerMsg = APIQueryLoadBalancerListenerMsg;
    var APIDeleteLoadBalancerMsg = (function () {
        function APIDeleteLoadBalancerMsg() {
        }
        APIDeleteLoadBalancerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APIDeleteLoadBalancerMsg': this
            };
            return msg;
        };
        return APIDeleteLoadBalancerMsg;
    })();
    ApiHeader.APIDeleteLoadBalancerMsg = APIDeleteLoadBalancerMsg;
    var APICreateLoadBalancerListenerMsg = (function () {
        function APICreateLoadBalancerListenerMsg() {
        }
        APICreateLoadBalancerListenerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APICreateLoadBalancerListenerMsg': this
            };
            return msg;
        };
        return APICreateLoadBalancerListenerMsg;
    })();
    ApiHeader.APICreateLoadBalancerListenerMsg = APICreateLoadBalancerListenerMsg;
    var APIRemoveVmNicFromLoadBalancerMsg = (function () {
        function APIRemoveVmNicFromLoadBalancerMsg() {
        }
        APIRemoveVmNicFromLoadBalancerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APIRemoveVmNicFromLoadBalancerMsg': this
            };
            return msg;
        };
        return APIRemoveVmNicFromLoadBalancerMsg;
    })();
    ApiHeader.APIRemoveVmNicFromLoadBalancerMsg = APIRemoveVmNicFromLoadBalancerMsg;
    var APIAddVmNicToLoadBalancerMsg = (function () {
        function APIAddVmNicToLoadBalancerMsg() {
        }
        APIAddVmNicToLoadBalancerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APIAddVmNicToLoadBalancerMsg': this
            };
            return msg;
        };
        return APIAddVmNicToLoadBalancerMsg;
    })();
    ApiHeader.APIAddVmNicToLoadBalancerMsg = APIAddVmNicToLoadBalancerMsg;
    var APICreateLoadBalancerMsg = (function () {
        function APICreateLoadBalancerMsg() {
        }
        APICreateLoadBalancerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APICreateLoadBalancerMsg': this
            };
            return msg;
        };
        return APICreateLoadBalancerMsg;
    })();
    ApiHeader.APICreateLoadBalancerMsg = APICreateLoadBalancerMsg;
    var APIRefreshLoadBalancerMsg = (function () {
        function APIRefreshLoadBalancerMsg() {
        }
        APIRefreshLoadBalancerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APIRefreshLoadBalancerMsg': this
            };
            return msg;
        };
        return APIRefreshLoadBalancerMsg;
    })();
    ApiHeader.APIRefreshLoadBalancerMsg = APIRefreshLoadBalancerMsg;
    var APIDeleteLoadBalancerListenerMsg = (function () {
        function APIDeleteLoadBalancerListenerMsg() {
        }
        APIDeleteLoadBalancerListenerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APIDeleteLoadBalancerListenerMsg': this
            };
            return msg;
        };
        return APIDeleteLoadBalancerListenerMsg;
    })();
    ApiHeader.APIDeleteLoadBalancerListenerMsg = APIDeleteLoadBalancerListenerMsg;
    var APIQueryLoadBalancerMsg = (function () {
        function APIQueryLoadBalancerMsg() {
        }
        APIQueryLoadBalancerMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.lb.APIQueryLoadBalancerMsg': this
            };
            return msg;
        };
        return APIQueryLoadBalancerMsg;
    })();
    ApiHeader.APIQueryLoadBalancerMsg = APIQueryLoadBalancerMsg;
    var APIChangeSecurityGroupStateMsg = (function () {
        function APIChangeSecurityGroupStateMsg() {
        }
        APIChangeSecurityGroupStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIChangeSecurityGroupStateMsg': this
            };
            return msg;
        };
        return APIChangeSecurityGroupStateMsg;
    })();
    ApiHeader.APIChangeSecurityGroupStateMsg = APIChangeSecurityGroupStateMsg;
    var APIDetachSecurityGroupFromL3NetworkMsg = (function () {
        function APIDetachSecurityGroupFromL3NetworkMsg() {
        }
        APIDetachSecurityGroupFromL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIDetachSecurityGroupFromL3NetworkMsg': this
            };
            return msg;
        };
        return APIDetachSecurityGroupFromL3NetworkMsg;
    })();
    ApiHeader.APIDetachSecurityGroupFromL3NetworkMsg = APIDetachSecurityGroupFromL3NetworkMsg;
    var APIDeleteSecurityGroupRuleMsg = (function () {
        function APIDeleteSecurityGroupRuleMsg() {
        }
        APIDeleteSecurityGroupRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIDeleteSecurityGroupRuleMsg': this
            };
            return msg;
        };
        return APIDeleteSecurityGroupRuleMsg;
    })();
    ApiHeader.APIDeleteSecurityGroupRuleMsg = APIDeleteSecurityGroupRuleMsg;
    var APICreateSecurityGroupMsg = (function () {
        function APICreateSecurityGroupMsg() {
        }
        APICreateSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APICreateSecurityGroupMsg': this
            };
            return msg;
        };
        return APICreateSecurityGroupMsg;
    })();
    ApiHeader.APICreateSecurityGroupMsg = APICreateSecurityGroupMsg;
    var APIListVmNicInSecurityGroupMsg = (function () {
        function APIListVmNicInSecurityGroupMsg() {
        }
        APIListVmNicInSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIListVmNicInSecurityGroupMsg': this
            };
            return msg;
        };
        return APIListVmNicInSecurityGroupMsg;
    })();
    ApiHeader.APIListVmNicInSecurityGroupMsg = APIListVmNicInSecurityGroupMsg;
    var APIQueryVmNicInSecurityGroupMsg = (function () {
        function APIQueryVmNicInSecurityGroupMsg() {
        }
        APIQueryVmNicInSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIQueryVmNicInSecurityGroupMsg': this
            };
            return msg;
        };
        return APIQueryVmNicInSecurityGroupMsg;
    })();
    ApiHeader.APIQueryVmNicInSecurityGroupMsg = APIQueryVmNicInSecurityGroupMsg;
    var APIQuerySecurityGroupMsg = (function () {
        function APIQuerySecurityGroupMsg() {
        }
        APIQuerySecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIQuerySecurityGroupMsg': this
            };
            return msg;
        };
        return APIQuerySecurityGroupMsg;
    })();
    ApiHeader.APIQuerySecurityGroupMsg = APIQuerySecurityGroupMsg;
    var SecurityGroupRuleAO = (function () {
        function SecurityGroupRuleAO() {
        }
        return SecurityGroupRuleAO;
    })();
    ApiHeader.SecurityGroupRuleAO = SecurityGroupRuleAO;
    var APIAddSecurityGroupRuleMsg = (function () {
        function APIAddSecurityGroupRuleMsg() {
        }
        APIAddSecurityGroupRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIAddSecurityGroupRuleMsg': this
            };
            return msg;
        };
        return APIAddSecurityGroupRuleMsg;
    })();
    ApiHeader.APIAddSecurityGroupRuleMsg = APIAddSecurityGroupRuleMsg;
    var APIListSecurityGroupMsg = (function () {
        function APIListSecurityGroupMsg() {
        }
        APIListSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIListSecurityGroupMsg': this
            };
            return msg;
        };
        return APIListSecurityGroupMsg;
    })();
    ApiHeader.APIListSecurityGroupMsg = APIListSecurityGroupMsg;
    var APIQuerySecurityGroupRuleMsg = (function () {
        function APIQuerySecurityGroupRuleMsg() {
        }
        APIQuerySecurityGroupRuleMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIQuerySecurityGroupRuleMsg': this
            };
            return msg;
        };
        return APIQuerySecurityGroupRuleMsg;
    })();
    ApiHeader.APIQuerySecurityGroupRuleMsg = APIQuerySecurityGroupRuleMsg;
    var APIDeleteSecurityGroupMsg = (function () {
        function APIDeleteSecurityGroupMsg() {
        }
        APIDeleteSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIDeleteSecurityGroupMsg': this
            };
            return msg;
        };
        return APIDeleteSecurityGroupMsg;
    })();
    ApiHeader.APIDeleteSecurityGroupMsg = APIDeleteSecurityGroupMsg;
    var APIUpdateSecurityGroupMsg = (function () {
        function APIUpdateSecurityGroupMsg() {
        }
        APIUpdateSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIUpdateSecurityGroupMsg': this
            };
            return msg;
        };
        return APIUpdateSecurityGroupMsg;
    })();
    ApiHeader.APIUpdateSecurityGroupMsg = APIUpdateSecurityGroupMsg;
    var APIDeleteVmNicFromSecurityGroupMsg = (function () {
        function APIDeleteVmNicFromSecurityGroupMsg() {
        }
        APIDeleteVmNicFromSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIDeleteVmNicFromSecurityGroupMsg': this
            };
            return msg;
        };
        return APIDeleteVmNicFromSecurityGroupMsg;
    })();
    ApiHeader.APIDeleteVmNicFromSecurityGroupMsg = APIDeleteVmNicFromSecurityGroupMsg;
    var APIGetCandidateVmNicForSecurityGroupMsg = (function () {
        function APIGetCandidateVmNicForSecurityGroupMsg() {
        }
        APIGetCandidateVmNicForSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIGetCandidateVmNicForSecurityGroupMsg': this
            };
            return msg;
        };
        return APIGetCandidateVmNicForSecurityGroupMsg;
    })();
    ApiHeader.APIGetCandidateVmNicForSecurityGroupMsg = APIGetCandidateVmNicForSecurityGroupMsg;
    var APIAttachSecurityGroupToL3NetworkMsg = (function () {
        function APIAttachSecurityGroupToL3NetworkMsg() {
        }
        APIAttachSecurityGroupToL3NetworkMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIAttachSecurityGroupToL3NetworkMsg': this
            };
            return msg;
        };
        return APIAttachSecurityGroupToL3NetworkMsg;
    })();
    ApiHeader.APIAttachSecurityGroupToL3NetworkMsg = APIAttachSecurityGroupToL3NetworkMsg;
    var APIAddVmNicToSecurityGroupMsg = (function () {
        function APIAddVmNicToSecurityGroupMsg() {
        }
        APIAddVmNicToSecurityGroupMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.securitygroup.APIAddVmNicToSecurityGroupMsg': this
            };
            return msg;
        };
        return APIAddVmNicToSecurityGroupMsg;
    })();
    ApiHeader.APIAddVmNicToSecurityGroupMsg = APIAddVmNicToSecurityGroupMsg;
    var APIDeleteVipMsg = (function () {
        function APIDeleteVipMsg() {
        }
        APIDeleteVipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.vip.APIDeleteVipMsg': this
            };
            return msg;
        };
        return APIDeleteVipMsg;
    })();
    ApiHeader.APIDeleteVipMsg = APIDeleteVipMsg;
    var APIUpdateVipMsg = (function () {
        function APIUpdateVipMsg() {
        }
        APIUpdateVipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.vip.APIUpdateVipMsg': this
            };
            return msg;
        };
        return APIUpdateVipMsg;
    })();
    ApiHeader.APIUpdateVipMsg = APIUpdateVipMsg;
    var APIChangeVipStateMsg = (function () {
        function APIChangeVipStateMsg() {
        }
        APIChangeVipStateMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.vip.APIChangeVipStateMsg': this
            };
            return msg;
        };
        return APIChangeVipStateMsg;
    })();
    ApiHeader.APIChangeVipStateMsg = APIChangeVipStateMsg;
    var APICreateVipMsg = (function () {
        function APICreateVipMsg() {
        }
        APICreateVipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.vip.APICreateVipMsg': this
            };
            return msg;
        };
        return APICreateVipMsg;
    })();
    ApiHeader.APICreateVipMsg = APICreateVipMsg;
    var APIQueryVipMsg = (function () {
        function APIQueryVipMsg() {
        }
        APIQueryVipMsg.prototype.toApiMap = function () {
            var msg = {
                'org.zstack.network.service.vip.APIQueryVipMsg': this
            };
            return msg;
        };
        return APIQueryVipMsg;
    })();
    ApiHeader.APIQueryVipMsg = APIQueryVipMsg;
    var ErrorCode = (function () {
        function ErrorCode() {
        }
        return ErrorCode;
    })();
    ApiHeader.ErrorCode = ErrorCode;
    var FakeApiEvent = (function () {
        function FakeApiEvent() {
        }
        return FakeApiEvent;
    })();
    ApiHeader.FakeApiEvent = FakeApiEvent;
    var GlobalConfigInventory = (function () {
        function GlobalConfigInventory() {
        }
        return GlobalConfigInventory;
    })();
    ApiHeader.GlobalConfigInventory = GlobalConfigInventory;
    var APIUpdateGlobalConfigEvent = (function () {
        function APIUpdateGlobalConfigEvent() {
        }
        return APIUpdateGlobalConfigEvent;
    })();
    ApiHeader.APIUpdateGlobalConfigEvent = APIUpdateGlobalConfigEvent;
    var InProgressEvent = (function () {
        function InProgressEvent() {
        }
        return InProgressEvent;
    })();
    ApiHeader.InProgressEvent = InProgressEvent;
    var FixedInProgressEvent = (function () {
        function FixedInProgressEvent() {
        }
        return FixedInProgressEvent;
    })();
    ApiHeader.FixedInProgressEvent = FixedInProgressEvent;
    var APIGenerateInventoryQueryDetailsEvent = (function () {
        function APIGenerateInventoryQueryDetailsEvent() {
        }
        return APIGenerateInventoryQueryDetailsEvent;
    })();
    ApiHeader.APIGenerateInventoryQueryDetailsEvent = APIGenerateInventoryQueryDetailsEvent;
    var APIGenerateQueryableFieldsEvent = (function () {
        function APIGenerateQueryableFieldsEvent() {
        }
        return APIGenerateQueryableFieldsEvent;
    })();
    ApiHeader.APIGenerateQueryableFieldsEvent = APIGenerateQueryableFieldsEvent;
    var VmNicInventory = (function () {
        function VmNicInventory() {
        }
        return VmNicInventory;
    })();
    ApiHeader.VmNicInventory = VmNicInventory;
    var VolumeInventory = (function () {
        function VolumeInventory() {
        }
        return VolumeInventory;
    })();
    ApiHeader.VolumeInventory = VolumeInventory;
    var VmInstanceInventory = (function () {
        function VmInstanceInventory() {
        }
        return VmInstanceInventory;
    })();
    ApiHeader.VmInstanceInventory = VmInstanceInventory;
    var APIDetachL3NetworkFromVmEvent = (function () {
        function APIDetachL3NetworkFromVmEvent() {
        }
        return APIDetachL3NetworkFromVmEvent;
    })();
    ApiHeader.APIDetachL3NetworkFromVmEvent = APIDetachL3NetworkFromVmEvent;
    var APIStartVmInstanceEvent = (function () {
        function APIStartVmInstanceEvent() {
        }
        return APIStartVmInstanceEvent;
    })();
    ApiHeader.APIStartVmInstanceEvent = APIStartVmInstanceEvent;
    var APIAttachL3NetworkToVmEvent = (function () {
        function APIAttachL3NetworkToVmEvent() {
        }
        return APIAttachL3NetworkToVmEvent;
    })();
    ApiHeader.APIAttachL3NetworkToVmEvent = APIAttachL3NetworkToVmEvent;
    var APIStopVmInstanceEvent = (function () {
        function APIStopVmInstanceEvent() {
        }
        return APIStopVmInstanceEvent;
    })();
    ApiHeader.APIStopVmInstanceEvent = APIStopVmInstanceEvent;
    var APIMigrateVmEvent = (function () {
        function APIMigrateVmEvent() {
        }
        return APIMigrateVmEvent;
    })();
    ApiHeader.APIMigrateVmEvent = APIMigrateVmEvent;
    var APIUpdateVmInstanceEvent = (function () {
        function APIUpdateVmInstanceEvent() {
        }
        return APIUpdateVmInstanceEvent;
    })();
    ApiHeader.APIUpdateVmInstanceEvent = APIUpdateVmInstanceEvent;
    var APIDestroyVmInstanceEvent = (function () {
        function APIDestroyVmInstanceEvent() {
        }
        return APIDestroyVmInstanceEvent;
    })();
    ApiHeader.APIDestroyVmInstanceEvent = APIDestroyVmInstanceEvent;
    var APIChangeInstanceOfferingEvent = (function () {
        function APIChangeInstanceOfferingEvent() {
        }
        return APIChangeInstanceOfferingEvent;
    })();
    ApiHeader.APIChangeInstanceOfferingEvent = APIChangeInstanceOfferingEvent;
    var APICreateVmInstanceEvent = (function () {
        function APICreateVmInstanceEvent() {
        }
        return APICreateVmInstanceEvent;
    })();
    ApiHeader.APICreateVmInstanceEvent = APICreateVmInstanceEvent;
    var APIRebootVmInstanceEvent = (function () {
        function APIRebootVmInstanceEvent() {
        }
        return APIRebootVmInstanceEvent;
    })();
    ApiHeader.APIRebootVmInstanceEvent = APIRebootVmInstanceEvent;
    var ImageBackupStorageRefInventory = (function () {
        function ImageBackupStorageRefInventory() {
        }
        return ImageBackupStorageRefInventory;
    })();
    ApiHeader.ImageBackupStorageRefInventory = ImageBackupStorageRefInventory;
    var ImageInventory = (function () {
        function ImageInventory() {
        }
        return ImageInventory;
    })();
    ApiHeader.ImageInventory = ImageInventory;
    var APICreateRootVolumeTemplateFromRootVolumeEvent = (function () {
        function APICreateRootVolumeTemplateFromRootVolumeEvent() {
        }
        return APICreateRootVolumeTemplateFromRootVolumeEvent;
    })();
    ApiHeader.APICreateRootVolumeTemplateFromRootVolumeEvent = APICreateRootVolumeTemplateFromRootVolumeEvent;
    var APIChangeImageStateEvent = (function () {
        function APIChangeImageStateEvent() {
        }
        return APIChangeImageStateEvent;
    })();
    ApiHeader.APIChangeImageStateEvent = APIChangeImageStateEvent;
    var APIUpdateImageEvent = (function () {
        function APIUpdateImageEvent() {
        }
        return APIUpdateImageEvent;
    })();
    ApiHeader.APIUpdateImageEvent = APIUpdateImageEvent;
    var APICreateDataVolumeTemplateFromVolumeEvent = (function () {
        function APICreateDataVolumeTemplateFromVolumeEvent() {
        }
        return APICreateDataVolumeTemplateFromVolumeEvent;
    })();
    ApiHeader.APICreateDataVolumeTemplateFromVolumeEvent = APICreateDataVolumeTemplateFromVolumeEvent;
    var APICreateRootVolumeTemplateFromVolumeSnapshotEvent = (function () {
        function APICreateRootVolumeTemplateFromVolumeSnapshotEvent() {
        }
        return APICreateRootVolumeTemplateFromVolumeSnapshotEvent;
    })();
    ApiHeader.APICreateRootVolumeTemplateFromVolumeSnapshotEvent = APICreateRootVolumeTemplateFromVolumeSnapshotEvent;
    var APIAddImageEvent = (function () {
        function APIAddImageEvent() {
        }
        return APIAddImageEvent;
    })();
    ApiHeader.APIAddImageEvent = APIAddImageEvent;
    var APIDeleteImageEvent = (function () {
        function APIDeleteImageEvent() {
        }
        return APIDeleteImageEvent;
    })();
    ApiHeader.APIDeleteImageEvent = APIDeleteImageEvent;
    var ConsoleInventory = (function () {
        function ConsoleInventory() {
        }
        return ConsoleInventory;
    })();
    ApiHeader.ConsoleInventory = ConsoleInventory;
    var APIRequestConsoleAccessEvent = (function () {
        function APIRequestConsoleAccessEvent() {
        }
        return APIRequestConsoleAccessEvent;
    })();
    ApiHeader.APIRequestConsoleAccessEvent = APIRequestConsoleAccessEvent;
    var APICreateDataVolumeEvent = (function () {
        function APICreateDataVolumeEvent() {
        }
        return APICreateDataVolumeEvent;
    })();
    ApiHeader.APICreateDataVolumeEvent = APICreateDataVolumeEvent;
    var APIDetachDataVolumeFromVmEvent = (function () {
        function APIDetachDataVolumeFromVmEvent() {
        }
        return APIDetachDataVolumeFromVmEvent;
    })();
    ApiHeader.APIDetachDataVolumeFromVmEvent = APIDetachDataVolumeFromVmEvent;
    var APIUpdateVolumeEvent = (function () {
        function APIUpdateVolumeEvent() {
        }
        return APIUpdateVolumeEvent;
    })();
    ApiHeader.APIUpdateVolumeEvent = APIUpdateVolumeEvent;
    var APIDeleteDataVolumeEvent = (function () {
        function APIDeleteDataVolumeEvent() {
        }
        return APIDeleteDataVolumeEvent;
    })();
    ApiHeader.APIDeleteDataVolumeEvent = APIDeleteDataVolumeEvent;
    var APICreateDataVolumeFromVolumeSnapshotEvent = (function () {
        function APICreateDataVolumeFromVolumeSnapshotEvent() {
        }
        return APICreateDataVolumeFromVolumeSnapshotEvent;
    })();
    ApiHeader.APICreateDataVolumeFromVolumeSnapshotEvent = APICreateDataVolumeFromVolumeSnapshotEvent;
    var APIBackupDataVolumeEvent = (function () {
        function APIBackupDataVolumeEvent() {
        }
        return APIBackupDataVolumeEvent;
    })();
    ApiHeader.APIBackupDataVolumeEvent = APIBackupDataVolumeEvent;
    var APICreateDataVolumeFromVolumeTemplateEvent = (function () {
        function APICreateDataVolumeFromVolumeTemplateEvent() {
        }
        return APICreateDataVolumeFromVolumeTemplateEvent;
    })();
    ApiHeader.APICreateDataVolumeFromVolumeTemplateEvent = APICreateDataVolumeFromVolumeTemplateEvent;
    var APIChangeVolumeStateEvent = (function () {
        function APIChangeVolumeStateEvent() {
        }
        return APIChangeVolumeStateEvent;
    })();
    ApiHeader.APIChangeVolumeStateEvent = APIChangeVolumeStateEvent;
    var VolumeSnapshotBackupStorageRefInventory = (function () {
        function VolumeSnapshotBackupStorageRefInventory() {
        }
        return VolumeSnapshotBackupStorageRefInventory;
    })();
    ApiHeader.VolumeSnapshotBackupStorageRefInventory = VolumeSnapshotBackupStorageRefInventory;
    var VolumeSnapshotInventory = (function () {
        function VolumeSnapshotInventory() {
        }
        return VolumeSnapshotInventory;
    })();
    ApiHeader.VolumeSnapshotInventory = VolumeSnapshotInventory;
    var APICreateVolumeSnapshotEvent = (function () {
        function APICreateVolumeSnapshotEvent() {
        }
        return APICreateVolumeSnapshotEvent;
    })();
    ApiHeader.APICreateVolumeSnapshotEvent = APICreateVolumeSnapshotEvent;
    var APIAttachDataVolumeToVmEvent = (function () {
        function APIAttachDataVolumeToVmEvent() {
        }
        return APIAttachDataVolumeToVmEvent;
    })();
    ApiHeader.APIAttachDataVolumeToVmEvent = APIAttachDataVolumeToVmEvent;
    var DiskOfferingInventory = (function () {
        function DiskOfferingInventory() {
        }
        return DiskOfferingInventory;
    })();
    ApiHeader.DiskOfferingInventory = DiskOfferingInventory;
    var APICreateDiskOfferingEvent = (function () {
        function APICreateDiskOfferingEvent() {
        }
        return APICreateDiskOfferingEvent;
    })();
    ApiHeader.APICreateDiskOfferingEvent = APICreateDiskOfferingEvent;
    var APIChangeDiskOfferingStateEvent = (function () {
        function APIChangeDiskOfferingStateEvent() {
        }
        return APIChangeDiskOfferingStateEvent;
    })();
    ApiHeader.APIChangeDiskOfferingStateEvent = APIChangeDiskOfferingStateEvent;
    var APIUpdateDiskOfferingEvent = (function () {
        function APIUpdateDiskOfferingEvent() {
        }
        return APIUpdateDiskOfferingEvent;
    })();
    ApiHeader.APIUpdateDiskOfferingEvent = APIUpdateDiskOfferingEvent;
    var APIDeleteInstanceOfferingEvent = (function () {
        function APIDeleteInstanceOfferingEvent() {
        }
        return APIDeleteInstanceOfferingEvent;
    })();
    ApiHeader.APIDeleteInstanceOfferingEvent = APIDeleteInstanceOfferingEvent;
    var APIGenerateSqlForeignKeyEvent = (function () {
        function APIGenerateSqlForeignKeyEvent() {
        }
        return APIGenerateSqlForeignKeyEvent;
    })();
    ApiHeader.APIGenerateSqlForeignKeyEvent = APIGenerateSqlForeignKeyEvent;
    var APIDeleteDiskOfferingEvent = (function () {
        function APIDeleteDiskOfferingEvent() {
        }
        return APIDeleteDiskOfferingEvent;
    })();
    ApiHeader.APIDeleteDiskOfferingEvent = APIDeleteDiskOfferingEvent;
    var APIGenerateGroovyClassEvent = (function () {
        function APIGenerateGroovyClassEvent() {
        }
        return APIGenerateGroovyClassEvent;
    })();
    ApiHeader.APIGenerateGroovyClassEvent = APIGenerateGroovyClassEvent;
    var APIGenerateSqlIndexEvent = (function () {
        function APIGenerateSqlIndexEvent() {
        }
        return APIGenerateSqlIndexEvent;
    })();
    ApiHeader.APIGenerateSqlIndexEvent = APIGenerateSqlIndexEvent;
    var InstanceOfferingInventory = (function () {
        function InstanceOfferingInventory() {
        }
        return InstanceOfferingInventory;
    })();
    ApiHeader.InstanceOfferingInventory = InstanceOfferingInventory;
    var APIUpdateInstanceOfferingEvent = (function () {
        function APIUpdateInstanceOfferingEvent() {
        }
        return APIUpdateInstanceOfferingEvent;
    })();
    ApiHeader.APIUpdateInstanceOfferingEvent = APIUpdateInstanceOfferingEvent;
    var APIGenerateApiTypeScriptDefinitionEvent = (function () {
        function APIGenerateApiTypeScriptDefinitionEvent() {
        }
        return APIGenerateApiTypeScriptDefinitionEvent;
    })();
    ApiHeader.APIGenerateApiTypeScriptDefinitionEvent = APIGenerateApiTypeScriptDefinitionEvent;
    var APIGenerateSqlVOViewEvent = (function () {
        function APIGenerateSqlVOViewEvent() {
        }
        return APIGenerateSqlVOViewEvent;
    })();
    ApiHeader.APIGenerateSqlVOViewEvent = APIGenerateSqlVOViewEvent;
    var APICreateInstanceOfferingEvent = (function () {
        function APICreateInstanceOfferingEvent() {
        }
        return APICreateInstanceOfferingEvent;
    })();
    ApiHeader.APICreateInstanceOfferingEvent = APICreateInstanceOfferingEvent;
    var APIChangeInstanceOfferingStateEvent = (function () {
        function APIChangeInstanceOfferingStateEvent() {
        }
        return APIChangeInstanceOfferingStateEvent;
    })();
    ApiHeader.APIChangeInstanceOfferingStateEvent = APIChangeInstanceOfferingStateEvent;
    var APIGenerateTestLinkDocumentEvent = (function () {
        function APIGenerateTestLinkDocumentEvent() {
        }
        return APIGenerateTestLinkDocumentEvent;
    })();
    ApiHeader.APIGenerateTestLinkDocumentEvent = APIGenerateTestLinkDocumentEvent;
    var APIGenerateApiJsonTemplateEvent = (function () {
        function APIGenerateApiJsonTemplateEvent() {
        }
        return APIGenerateApiJsonTemplateEvent;
    })();
    ApiHeader.APIGenerateApiJsonTemplateEvent = APIGenerateApiJsonTemplateEvent;
    var PrimaryStorageInventory = (function () {
        function PrimaryStorageInventory() {
        }
        return PrimaryStorageInventory;
    })();
    ApiHeader.PrimaryStorageInventory = PrimaryStorageInventory;
    var APISyncPrimaryStorageCapacityEvent = (function () {
        function APISyncPrimaryStorageCapacityEvent() {
        }
        return APISyncPrimaryStorageCapacityEvent;
    })();
    ApiHeader.APISyncPrimaryStorageCapacityEvent = APISyncPrimaryStorageCapacityEvent;
    var APIDeletePrimaryStorageEvent = (function () {
        function APIDeletePrimaryStorageEvent() {
        }
        return APIDeletePrimaryStorageEvent;
    })();
    ApiHeader.APIDeletePrimaryStorageEvent = APIDeletePrimaryStorageEvent;
    var APIDetachPrimaryStorageFromClusterEvent = (function () {
        function APIDetachPrimaryStorageFromClusterEvent() {
        }
        return APIDetachPrimaryStorageFromClusterEvent;
    })();
    ApiHeader.APIDetachPrimaryStorageFromClusterEvent = APIDetachPrimaryStorageFromClusterEvent;
    var APIChangePrimaryStorageStateEvent = (function () {
        function APIChangePrimaryStorageStateEvent() {
        }
        return APIChangePrimaryStorageStateEvent;
    })();
    ApiHeader.APIChangePrimaryStorageStateEvent = APIChangePrimaryStorageStateEvent;
    var APIUpdatePrimaryStorageEvent = (function () {
        function APIUpdatePrimaryStorageEvent() {
        }
        return APIUpdatePrimaryStorageEvent;
    })();
    ApiHeader.APIUpdatePrimaryStorageEvent = APIUpdatePrimaryStorageEvent;
    var APIReconnectPrimaryStorageEvent = (function () {
        function APIReconnectPrimaryStorageEvent() {
        }
        return APIReconnectPrimaryStorageEvent;
    })();
    ApiHeader.APIReconnectPrimaryStorageEvent = APIReconnectPrimaryStorageEvent;
    var APIAttachPrimaryStorageToClusterEvent = (function () {
        function APIAttachPrimaryStorageToClusterEvent() {
        }
        return APIAttachPrimaryStorageToClusterEvent;
    })();
    ApiHeader.APIAttachPrimaryStorageToClusterEvent = APIAttachPrimaryStorageToClusterEvent;
    var APIAddPrimaryStorageEvent = (function () {
        function APIAddPrimaryStorageEvent() {
        }
        return APIAddPrimaryStorageEvent;
    })();
    ApiHeader.APIAddPrimaryStorageEvent = APIAddPrimaryStorageEvent;
    var APIDeleteVolumeSnapshotEvent = (function () {
        function APIDeleteVolumeSnapshotEvent() {
        }
        return APIDeleteVolumeSnapshotEvent;
    })();
    ApiHeader.APIDeleteVolumeSnapshotEvent = APIDeleteVolumeSnapshotEvent;
    var APIUpdateVolumeSnapshotEvent = (function () {
        function APIUpdateVolumeSnapshotEvent() {
        }
        return APIUpdateVolumeSnapshotEvent;
    })();
    ApiHeader.APIUpdateVolumeSnapshotEvent = APIUpdateVolumeSnapshotEvent;
    var APIRevertVolumeFromSnapshotEvent = (function () {
        function APIRevertVolumeFromSnapshotEvent() {
        }
        return APIRevertVolumeFromSnapshotEvent;
    })();
    ApiHeader.APIRevertVolumeFromSnapshotEvent = APIRevertVolumeFromSnapshotEvent;
    var APIDeleteVolumeSnapshotFromBackupStorageEvent = (function () {
        function APIDeleteVolumeSnapshotFromBackupStorageEvent() {
        }
        return APIDeleteVolumeSnapshotFromBackupStorageEvent;
    })();
    ApiHeader.APIDeleteVolumeSnapshotFromBackupStorageEvent = APIDeleteVolumeSnapshotFromBackupStorageEvent;
    var APIBackupVolumeSnapshotEvent = (function () {
        function APIBackupVolumeSnapshotEvent() {
        }
        return APIBackupVolumeSnapshotEvent;
    })();
    ApiHeader.APIBackupVolumeSnapshotEvent = APIBackupVolumeSnapshotEvent;
    var BackupStorageInventory = (function () {
        function BackupStorageInventory() {
        }
        return BackupStorageInventory;
    })();
    ApiHeader.BackupStorageInventory = BackupStorageInventory;
    var APIUpdateBackupStorageEvent = (function () {
        function APIUpdateBackupStorageEvent() {
        }
        return APIUpdateBackupStorageEvent;
    })();
    ApiHeader.APIUpdateBackupStorageEvent = APIUpdateBackupStorageEvent;
    var APIDetachBackupStorageFromZoneEvent = (function () {
        function APIDetachBackupStorageFromZoneEvent() {
        }
        return APIDetachBackupStorageFromZoneEvent;
    })();
    ApiHeader.APIDetachBackupStorageFromZoneEvent = APIDetachBackupStorageFromZoneEvent;
    var APIScanBackupStorageEvent = (function () {
        function APIScanBackupStorageEvent() {
        }
        return APIScanBackupStorageEvent;
    })();
    ApiHeader.APIScanBackupStorageEvent = APIScanBackupStorageEvent;
    var APIAddBackupStorageEvent = (function () {
        function APIAddBackupStorageEvent() {
        }
        return APIAddBackupStorageEvent;
    })();
    ApiHeader.APIAddBackupStorageEvent = APIAddBackupStorageEvent;
    var APIAttachBackupStorageToZoneEvent = (function () {
        function APIAttachBackupStorageToZoneEvent() {
        }
        return APIAttachBackupStorageToZoneEvent;
    })();
    ApiHeader.APIAttachBackupStorageToZoneEvent = APIAttachBackupStorageToZoneEvent;
    var APIChangeBackupStorageStateEvent = (function () {
        function APIChangeBackupStorageStateEvent() {
        }
        return APIChangeBackupStorageStateEvent;
    })();
    ApiHeader.APIChangeBackupStorageStateEvent = APIChangeBackupStorageStateEvent;
    var APIDeleteBackupStorageEvent = (function () {
        function APIDeleteBackupStorageEvent() {
        }
        return APIDeleteBackupStorageEvent;
    })();
    ApiHeader.APIDeleteBackupStorageEvent = APIDeleteBackupStorageEvent;
    var IpRangeInventory = (function () {
        function IpRangeInventory() {
        }
        return IpRangeInventory;
    })();
    ApiHeader.IpRangeInventory = IpRangeInventory;
    var APIAddIpRangeEvent = (function () {
        function APIAddIpRangeEvent() {
        }
        return APIAddIpRangeEvent;
    })();
    ApiHeader.APIAddIpRangeEvent = APIAddIpRangeEvent;
    var NetworkServiceL3NetworkRefInventory = (function () {
        function NetworkServiceL3NetworkRefInventory() {
        }
        return NetworkServiceL3NetworkRefInventory;
    })();
    ApiHeader.NetworkServiceL3NetworkRefInventory = NetworkServiceL3NetworkRefInventory;
    var L3NetworkInventory = (function () {
        function L3NetworkInventory() {
        }
        return L3NetworkInventory;
    })();
    ApiHeader.L3NetworkInventory = L3NetworkInventory;
    var APIRemoveDnsFromL3NetworkEvent = (function () {
        function APIRemoveDnsFromL3NetworkEvent() {
        }
        return APIRemoveDnsFromL3NetworkEvent;
    })();
    ApiHeader.APIRemoveDnsFromL3NetworkEvent = APIRemoveDnsFromL3NetworkEvent;
    var APIDeleteL3NetworkEvent = (function () {
        function APIDeleteL3NetworkEvent() {
        }
        return APIDeleteL3NetworkEvent;
    })();
    ApiHeader.APIDeleteL3NetworkEvent = APIDeleteL3NetworkEvent;
    var APIChangeL3NetworkStateEvent = (function () {
        function APIChangeL3NetworkStateEvent() {
        }
        return APIChangeL3NetworkStateEvent;
    })();
    ApiHeader.APIChangeL3NetworkStateEvent = APIChangeL3NetworkStateEvent;
    var APIDeleteIpRangeEvent = (function () {
        function APIDeleteIpRangeEvent() {
        }
        return APIDeleteIpRangeEvent;
    })();
    ApiHeader.APIDeleteIpRangeEvent = APIDeleteIpRangeEvent;
    var APIAddIpRangeByNetworkCidrEvent = (function () {
        function APIAddIpRangeByNetworkCidrEvent() {
        }
        return APIAddIpRangeByNetworkCidrEvent;
    })();
    ApiHeader.APIAddIpRangeByNetworkCidrEvent = APIAddIpRangeByNetworkCidrEvent;
    var APIUpdateIpRangeEvent = (function () {
        function APIUpdateIpRangeEvent() {
        }
        return APIUpdateIpRangeEvent;
    })();
    ApiHeader.APIUpdateIpRangeEvent = APIUpdateIpRangeEvent;
    var APIUpdateL3NetworkEvent = (function () {
        function APIUpdateL3NetworkEvent() {
        }
        return APIUpdateL3NetworkEvent;
    })();
    ApiHeader.APIUpdateL3NetworkEvent = APIUpdateL3NetworkEvent;
    var APIAddDnsToL3NetworkEvent = (function () {
        function APIAddDnsToL3NetworkEvent() {
        }
        return APIAddDnsToL3NetworkEvent;
    })();
    ApiHeader.APIAddDnsToL3NetworkEvent = APIAddDnsToL3NetworkEvent;
    var APICreateL3NetworkEvent = (function () {
        function APICreateL3NetworkEvent() {
        }
        return APICreateL3NetworkEvent;
    })();
    ApiHeader.APICreateL3NetworkEvent = APICreateL3NetworkEvent;
    var NetworkServiceProviderInventory = (function () {
        function NetworkServiceProviderInventory() {
        }
        return NetworkServiceProviderInventory;
    })();
    ApiHeader.NetworkServiceProviderInventory = NetworkServiceProviderInventory;
    var APIDetachNetworkServiceProviderFromL2NetworkEvent = (function () {
        function APIDetachNetworkServiceProviderFromL2NetworkEvent() {
        }
        return APIDetachNetworkServiceProviderFromL2NetworkEvent;
    })();
    ApiHeader.APIDetachNetworkServiceProviderFromL2NetworkEvent = APIDetachNetworkServiceProviderFromL2NetworkEvent;
    var APIAddNetworkServiceProviderEvent = (function () {
        function APIAddNetworkServiceProviderEvent() {
        }
        return APIAddNetworkServiceProviderEvent;
    })();
    ApiHeader.APIAddNetworkServiceProviderEvent = APIAddNetworkServiceProviderEvent;
    var APIAttachNetworkServiceProviderToL2NetworkEvent = (function () {
        function APIAttachNetworkServiceProviderToL2NetworkEvent() {
        }
        return APIAttachNetworkServiceProviderToL2NetworkEvent;
    })();
    ApiHeader.APIAttachNetworkServiceProviderToL2NetworkEvent = APIAttachNetworkServiceProviderToL2NetworkEvent;
    var APIAttachNetworkServiceToL3NetworkEvent = (function () {
        function APIAttachNetworkServiceToL3NetworkEvent() {
        }
        return APIAttachNetworkServiceToL3NetworkEvent;
    })();
    ApiHeader.APIAttachNetworkServiceToL3NetworkEvent = APIAttachNetworkServiceToL3NetworkEvent;
    var L2NetworkInventory = (function () {
        function L2NetworkInventory() {
        }
        return L2NetworkInventory;
    })();
    ApiHeader.L2NetworkInventory = L2NetworkInventory;
    var APIAttachL2NetworkToClusterEvent = (function () {
        function APIAttachL2NetworkToClusterEvent() {
        }
        return APIAttachL2NetworkToClusterEvent;
    })();
    ApiHeader.APIAttachL2NetworkToClusterEvent = APIAttachL2NetworkToClusterEvent;
    var L2VlanNetworkInventory = (function () {
        function L2VlanNetworkInventory() {
        }
        return L2VlanNetworkInventory;
    })();
    ApiHeader.L2VlanNetworkInventory = L2VlanNetworkInventory;
    var APICreateL2VlanNetworkEvent = (function () {
        function APICreateL2VlanNetworkEvent() {
        }
        return APICreateL2VlanNetworkEvent;
    })();
    ApiHeader.APICreateL2VlanNetworkEvent = APICreateL2VlanNetworkEvent;
    var APIDetachL2NetworkFromClusterEvent = (function () {
        function APIDetachL2NetworkFromClusterEvent() {
        }
        return APIDetachL2NetworkFromClusterEvent;
    })();
    ApiHeader.APIDetachL2NetworkFromClusterEvent = APIDetachL2NetworkFromClusterEvent;
    var APIDeleteL2NetworkEvent = (function () {
        function APIDeleteL2NetworkEvent() {
        }
        return APIDeleteL2NetworkEvent;
    })();
    ApiHeader.APIDeleteL2NetworkEvent = APIDeleteL2NetworkEvent;
    var APICreateL2NetworkEvent = (function () {
        function APICreateL2NetworkEvent() {
        }
        return APICreateL2NetworkEvent;
    })();
    ApiHeader.APICreateL2NetworkEvent = APICreateL2NetworkEvent;
    var APIUpdateL2NetworkEvent = (function () {
        function APIUpdateL2NetworkEvent() {
        }
        return APIUpdateL2NetworkEvent;
    })();
    ApiHeader.APIUpdateL2NetworkEvent = APIUpdateL2NetworkEvent;
    var APIDeleteSearchIndexEvent = (function () {
        function APIDeleteSearchIndexEvent() {
        }
        return APIDeleteSearchIndexEvent;
    })();
    ApiHeader.APIDeleteSearchIndexEvent = APIDeleteSearchIndexEvent;
    var APISearchGenerateSqlTriggerEvent = (function () {
        function APISearchGenerateSqlTriggerEvent() {
        }
        return APISearchGenerateSqlTriggerEvent;
    })();
    ApiHeader.APISearchGenerateSqlTriggerEvent = APISearchGenerateSqlTriggerEvent;
    var APICreateSearchIndexEvent = (function () {
        function APICreateSearchIndexEvent() {
        }
        return APICreateSearchIndexEvent;
    })();
    ApiHeader.APICreateSearchIndexEvent = APICreateSearchIndexEvent;
    var UserTagInventory = (function () {
        function UserTagInventory() {
        }
        return UserTagInventory;
    })();
    ApiHeader.UserTagInventory = UserTagInventory;
    var APICreateUserTagEvent = (function () {
        function APICreateUserTagEvent() {
        }
        return APICreateUserTagEvent;
    })();
    ApiHeader.APICreateUserTagEvent = APICreateUserTagEvent;
    var APIDeleteTagEvent = (function () {
        function APIDeleteTagEvent() {
        }
        return APIDeleteTagEvent;
    })();
    ApiHeader.APIDeleteTagEvent = APIDeleteTagEvent;
    var TagInventory = (function () {
        function TagInventory() {
        }
        return TagInventory;
    })();
    ApiHeader.TagInventory = TagInventory;
    var APICreateTagEvent = (function () {
        function APICreateTagEvent() {
        }
        return APICreateTagEvent;
    })();
    ApiHeader.APICreateTagEvent = APICreateTagEvent;
    var SystemTagInventory = (function () {
        function SystemTagInventory() {
        }
        return SystemTagInventory;
    })();
    ApiHeader.SystemTagInventory = SystemTagInventory;
    var APICreateSystemTagEvent = (function () {
        function APICreateSystemTagEvent() {
        }
        return APICreateSystemTagEvent;
    })();
    ApiHeader.APICreateSystemTagEvent = APICreateSystemTagEvent;
    var APIUpdateSystemTagEvent = (function () {
        function APIUpdateSystemTagEvent() {
        }
        return APIUpdateSystemTagEvent;
    })();
    ApiHeader.APIUpdateSystemTagEvent = APIUpdateSystemTagEvent;
    var APIEvent = (function () {
        function APIEvent() {
        }
        return APIEvent;
    })();
    ApiHeader.APIEvent = APIEvent;
    var APIDeleteClusterEvent = (function () {
        function APIDeleteClusterEvent() {
        }
        return APIDeleteClusterEvent;
    })();
    ApiHeader.APIDeleteClusterEvent = APIDeleteClusterEvent;
    var ClusterInventory = (function () {
        function ClusterInventory() {
        }
        return ClusterInventory;
    })();
    ApiHeader.ClusterInventory = ClusterInventory;
    var APICreateClusterEvent = (function () {
        function APICreateClusterEvent() {
        }
        return APICreateClusterEvent;
    })();
    ApiHeader.APICreateClusterEvent = APICreateClusterEvent;
    var APIChangeClusterStateEvent = (function () {
        function APIChangeClusterStateEvent() {
        }
        return APIChangeClusterStateEvent;
    })();
    ApiHeader.APIChangeClusterStateEvent = APIChangeClusterStateEvent;
    var APIUpdateClusterEvent = (function () {
        function APIUpdateClusterEvent() {
        }
        return APIUpdateClusterEvent;
    })();
    ApiHeader.APIUpdateClusterEvent = APIUpdateClusterEvent;
    var APIRemoveUserFromGroupEvent = (function () {
        function APIRemoveUserFromGroupEvent() {
        }
        return APIRemoveUserFromGroupEvent;
    })();
    ApiHeader.APIRemoveUserFromGroupEvent = APIRemoveUserFromGroupEvent;
    var AccountInventory = (function () {
        function AccountInventory() {
        }
        return AccountInventory;
    })();
    ApiHeader.AccountInventory = AccountInventory;
    var APICreateAccountEvent = (function () {
        function APICreateAccountEvent() {
        }
        return APICreateAccountEvent;
    })();
    ApiHeader.APICreateAccountEvent = APICreateAccountEvent;
    var APIDeleteUserGroupEvent = (function () {
        function APIDeleteUserGroupEvent() {
        }
        return APIDeleteUserGroupEvent;
    })();
    ApiHeader.APIDeleteUserGroupEvent = APIDeleteUserGroupEvent;
    var APIAttachPolicyToUserEvent = (function () {
        function APIAttachPolicyToUserEvent() {
        }
        return APIAttachPolicyToUserEvent;
    })();
    ApiHeader.APIAttachPolicyToUserEvent = APIAttachPolicyToUserEvent;
    var APIShareResourceEvent = (function () {
        function APIShareResourceEvent() {
        }
        return APIShareResourceEvent;
    })();
    ApiHeader.APIShareResourceEvent = APIShareResourceEvent;
    var APIDetachPolicyFromUserGroupEvent = (function () {
        function APIDetachPolicyFromUserGroupEvent() {
        }
        return APIDetachPolicyFromUserGroupEvent;
    })();
    ApiHeader.APIDetachPolicyFromUserGroupEvent = APIDetachPolicyFromUserGroupEvent;
    var APIDeletePolicyEvent = (function () {
        function APIDeletePolicyEvent() {
        }
        return APIDeletePolicyEvent;
    })();
    ApiHeader.APIDeletePolicyEvent = APIDeletePolicyEvent;
    var APIAddUserToGroupEvent = (function () {
        function APIAddUserToGroupEvent() {
        }
        return APIAddUserToGroupEvent;
    })();
    ApiHeader.APIAddUserToGroupEvent = APIAddUserToGroupEvent;
    var APIUpdateUserEvent = (function () {
        function APIUpdateUserEvent() {
        }
        return APIUpdateUserEvent;
    })();
    ApiHeader.APIUpdateUserEvent = APIUpdateUserEvent;
    var APIDeleteAccountEvent = (function () {
        function APIDeleteAccountEvent() {
        }
        return APIDeleteAccountEvent;
    })();
    ApiHeader.APIDeleteAccountEvent = APIDeleteAccountEvent;
    var APIUpdateAccountEvent = (function () {
        function APIUpdateAccountEvent() {
        }
        return APIUpdateAccountEvent;
    })();
    ApiHeader.APIUpdateAccountEvent = APIUpdateAccountEvent;
    var QuotaInventory = (function () {
        function QuotaInventory() {
        }
        return QuotaInventory;
    })();
    ApiHeader.QuotaInventory = QuotaInventory;
    var APIUpdateQuotaEvent = (function () {
        function APIUpdateQuotaEvent() {
        }
        return APIUpdateQuotaEvent;
    })();
    ApiHeader.APIUpdateQuotaEvent = APIUpdateQuotaEvent;
    var PolicyInventory = (function () {
        function PolicyInventory() {
        }
        return PolicyInventory;
    })();
    ApiHeader.PolicyInventory = PolicyInventory;
    var APICreatePolicyEvent = (function () {
        function APICreatePolicyEvent() {
        }
        return APICreatePolicyEvent;
    })();
    ApiHeader.APICreatePolicyEvent = APICreatePolicyEvent;
    var UserInventory = (function () {
        function UserInventory() {
        }
        return UserInventory;
    })();
    ApiHeader.UserInventory = UserInventory;
    var APICreateUserEvent = (function () {
        function APICreateUserEvent() {
        }
        return APICreateUserEvent;
    })();
    ApiHeader.APICreateUserEvent = APICreateUserEvent;
    var APIDetachPolicyFromUserEvent = (function () {
        function APIDetachPolicyFromUserEvent() {
        }
        return APIDetachPolicyFromUserEvent;
    })();
    ApiHeader.APIDetachPolicyFromUserEvent = APIDetachPolicyFromUserEvent;
    var APIDeleteUserEvent = (function () {
        function APIDeleteUserEvent() {
        }
        return APIDeleteUserEvent;
    })();
    ApiHeader.APIDeleteUserEvent = APIDeleteUserEvent;
    var UserGroupInventory = (function () {
        function UserGroupInventory() {
        }
        return UserGroupInventory;
    })();
    ApiHeader.UserGroupInventory = UserGroupInventory;
    var APICreateUserGroupEvent = (function () {
        function APICreateUserGroupEvent() {
        }
        return APICreateUserGroupEvent;
    })();
    ApiHeader.APICreateUserGroupEvent = APICreateUserGroupEvent;
    var APIAttachPolicyToUserGroupEvent = (function () {
        function APIAttachPolicyToUserGroupEvent() {
        }
        return APIAttachPolicyToUserGroupEvent;
    })();
    ApiHeader.APIAttachPolicyToUserGroupEvent = APIAttachPolicyToUserGroupEvent;
    var APIRevokeResourceSharingEvent = (function () {
        function APIRevokeResourceSharingEvent() {
        }
        return APIRevokeResourceSharingEvent;
    })();
    ApiHeader.APIRevokeResourceSharingEvent = APIRevokeResourceSharingEvent;
    var ZoneInventory = (function () {
        function ZoneInventory() {
        }
        return ZoneInventory;
    })();
    ApiHeader.ZoneInventory = ZoneInventory;
    var APIUpdateZoneEvent = (function () {
        function APIUpdateZoneEvent() {
        }
        return APIUpdateZoneEvent;
    })();
    ApiHeader.APIUpdateZoneEvent = APIUpdateZoneEvent;
    var APIChangeZoneStateEvent = (function () {
        function APIChangeZoneStateEvent() {
        }
        return APIChangeZoneStateEvent;
    })();
    ApiHeader.APIChangeZoneStateEvent = APIChangeZoneStateEvent;
    var APICreateZoneEvent = (function () {
        function APICreateZoneEvent() {
        }
        return APICreateZoneEvent;
    })();
    ApiHeader.APICreateZoneEvent = APICreateZoneEvent;
    var APIDeleteZoneEvent = (function () {
        function APIDeleteZoneEvent() {
        }
        return APIDeleteZoneEvent;
    })();
    ApiHeader.APIDeleteZoneEvent = APIDeleteZoneEvent;
    var HostInventory = (function () {
        function HostInventory() {
        }
        return HostInventory;
    })();
    ApiHeader.HostInventory = HostInventory;
    var APIAddHostEvent = (function () {
        function APIAddHostEvent() {
        }
        return APIAddHostEvent;
    })();
    ApiHeader.APIAddHostEvent = APIAddHostEvent;
    var APIChangeHostStateEvent = (function () {
        function APIChangeHostStateEvent() {
        }
        return APIChangeHostStateEvent;
    })();
    ApiHeader.APIChangeHostStateEvent = APIChangeHostStateEvent;
    var APIDeleteHostEvent = (function () {
        function APIDeleteHostEvent() {
        }
        return APIDeleteHostEvent;
    })();
    ApiHeader.APIDeleteHostEvent = APIDeleteHostEvent;
    var APIReconnectHostEvent = (function () {
        function APIReconnectHostEvent() {
        }
        return APIReconnectHostEvent;
    })();
    ApiHeader.APIReconnectHostEvent = APIReconnectHostEvent;
    var APIUpdateHostEvent = (function () {
        function APIUpdateHostEvent() {
        }
        return APIUpdateHostEvent;
    })();
    ApiHeader.APIUpdateHostEvent = APIUpdateHostEvent;
    var CephPrimaryStorageMonInventory = (function () {
        function CephPrimaryStorageMonInventory() {
        }
        return CephPrimaryStorageMonInventory;
    })();
    ApiHeader.CephPrimaryStorageMonInventory = CephPrimaryStorageMonInventory;
    var CephPrimaryStorageInventory = (function () {
        function CephPrimaryStorageInventory() {
        }
        return CephPrimaryStorageInventory;
    })();
    ApiHeader.CephPrimaryStorageInventory = CephPrimaryStorageInventory;
    var APIRemoveMonFromCephPrimaryStorageEvent = (function () {
        function APIRemoveMonFromCephPrimaryStorageEvent() {
        }
        return APIRemoveMonFromCephPrimaryStorageEvent;
    })();
    ApiHeader.APIRemoveMonFromCephPrimaryStorageEvent = APIRemoveMonFromCephPrimaryStorageEvent;
    var APIAddMonToCephPrimaryStorageEvent = (function () {
        function APIAddMonToCephPrimaryStorageEvent() {
        }
        return APIAddMonToCephPrimaryStorageEvent;
    })();
    ApiHeader.APIAddMonToCephPrimaryStorageEvent = APIAddMonToCephPrimaryStorageEvent;
    var CephBackupStorageMonInventory = (function () {
        function CephBackupStorageMonInventory() {
        }
        return CephBackupStorageMonInventory;
    })();
    ApiHeader.CephBackupStorageMonInventory = CephBackupStorageMonInventory;
    var CephBackupStorageInventory = (function () {
        function CephBackupStorageInventory() {
        }
        return CephBackupStorageInventory;
    })();
    ApiHeader.CephBackupStorageInventory = CephBackupStorageInventory;
    var APIRemoveMonFromCephBackupStorageEvent = (function () {
        function APIRemoveMonFromCephBackupStorageEvent() {
        }
        return APIRemoveMonFromCephBackupStorageEvent;
    })();
    ApiHeader.APIRemoveMonFromCephBackupStorageEvent = APIRemoveMonFromCephBackupStorageEvent;
    var APIAddMonToCephBackupStorageEvent = (function () {
        function APIAddMonToCephBackupStorageEvent() {
        }
        return APIAddMonToCephBackupStorageEvent;
    })();
    ApiHeader.APIAddMonToCephBackupStorageEvent = APIAddMonToCephBackupStorageEvent;
    var SftpBackupStorageInventory = (function () {
        function SftpBackupStorageInventory() {
        }
        return SftpBackupStorageInventory;
    })();
    ApiHeader.SftpBackupStorageInventory = SftpBackupStorageInventory;
    var APIAddSftpBackupStorageEvent = (function () {
        function APIAddSftpBackupStorageEvent() {
        }
        return APIAddSftpBackupStorageEvent;
    })();
    ApiHeader.APIAddSftpBackupStorageEvent = APIAddSftpBackupStorageEvent;
    var APIReconnectSftpBackupStorageEvent = (function () {
        function APIReconnectSftpBackupStorageEvent() {
        }
        return APIReconnectSftpBackupStorageEvent;
    })();
    ApiHeader.APIReconnectSftpBackupStorageEvent = APIReconnectSftpBackupStorageEvent;
    var ApplianceVmInventory = (function () {
        function ApplianceVmInventory() {
        }
        return ApplianceVmInventory;
    })();
    ApiHeader.ApplianceVmInventory = ApplianceVmInventory;
    var APIReconnectVirtualRouterEvent = (function () {
        function APIReconnectVirtualRouterEvent() {
        }
        return APIReconnectVirtualRouterEvent;
    })();
    ApiHeader.APIReconnectVirtualRouterEvent = APIReconnectVirtualRouterEvent;
    var APIDeletePortForwardingRuleEvent = (function () {
        function APIDeletePortForwardingRuleEvent() {
        }
        return APIDeletePortForwardingRuleEvent;
    })();
    ApiHeader.APIDeletePortForwardingRuleEvent = APIDeletePortForwardingRuleEvent;
    var PortForwardingRuleInventory = (function () {
        function PortForwardingRuleInventory() {
        }
        return PortForwardingRuleInventory;
    })();
    ApiHeader.PortForwardingRuleInventory = PortForwardingRuleInventory;
    var APIChangePortForwardingRuleStateEvent = (function () {
        function APIChangePortForwardingRuleStateEvent() {
        }
        return APIChangePortForwardingRuleStateEvent;
    })();
    ApiHeader.APIChangePortForwardingRuleStateEvent = APIChangePortForwardingRuleStateEvent;
    var APIDetachPortForwardingRuleEvent = (function () {
        function APIDetachPortForwardingRuleEvent() {
        }
        return APIDetachPortForwardingRuleEvent;
    })();
    ApiHeader.APIDetachPortForwardingRuleEvent = APIDetachPortForwardingRuleEvent;
    var APIAttachPortForwardingRuleEvent = (function () {
        function APIAttachPortForwardingRuleEvent() {
        }
        return APIAttachPortForwardingRuleEvent;
    })();
    ApiHeader.APIAttachPortForwardingRuleEvent = APIAttachPortForwardingRuleEvent;
    var APICreatePortForwardingRuleEvent = (function () {
        function APICreatePortForwardingRuleEvent() {
        }
        return APICreatePortForwardingRuleEvent;
    })();
    ApiHeader.APICreatePortForwardingRuleEvent = APICreatePortForwardingRuleEvent;
    var APIUpdatePortForwardingRuleEvent = (function () {
        function APIUpdatePortForwardingRuleEvent() {
        }
        return APIUpdatePortForwardingRuleEvent;
    })();
    ApiHeader.APIUpdatePortForwardingRuleEvent = APIUpdatePortForwardingRuleEvent;
    var EipInventory = (function () {
        function EipInventory() {
        }
        return EipInventory;
    })();
    ApiHeader.EipInventory = EipInventory;
    var APIChangeEipStateEvent = (function () {
        function APIChangeEipStateEvent() {
        }
        return APIChangeEipStateEvent;
    })();
    ApiHeader.APIChangeEipStateEvent = APIChangeEipStateEvent;
    var APIUpdateEipEvent = (function () {
        function APIUpdateEipEvent() {
        }
        return APIUpdateEipEvent;
    })();
    ApiHeader.APIUpdateEipEvent = APIUpdateEipEvent;
    var APICreateEipEvent = (function () {
        function APICreateEipEvent() {
        }
        return APICreateEipEvent;
    })();
    ApiHeader.APICreateEipEvent = APICreateEipEvent;
    var APIDetachEipEvent = (function () {
        function APIDetachEipEvent() {
        }
        return APIDetachEipEvent;
    })();
    ApiHeader.APIDetachEipEvent = APIDetachEipEvent;
    var APIAttachEipEvent = (function () {
        function APIAttachEipEvent() {
        }
        return APIAttachEipEvent;
    })();
    ApiHeader.APIAttachEipEvent = APIAttachEipEvent;
    var APIDeleteEipEvent = (function () {
        function APIDeleteEipEvent() {
        }
        return APIDeleteEipEvent;
    })();
    ApiHeader.APIDeleteEipEvent = APIDeleteEipEvent;
    var LoadBalancerListenerVmNicRefInventory = (function () {
        function LoadBalancerListenerVmNicRefInventory() {
        }
        return LoadBalancerListenerVmNicRefInventory;
    })();
    ApiHeader.LoadBalancerListenerVmNicRefInventory = LoadBalancerListenerVmNicRefInventory;
    var LoadBalancerListenerInventory = (function () {
        function LoadBalancerListenerInventory() {
        }
        return LoadBalancerListenerInventory;
    })();
    ApiHeader.LoadBalancerListenerInventory = LoadBalancerListenerInventory;
    var LoadBalancerInventory = (function () {
        function LoadBalancerInventory() {
        }
        return LoadBalancerInventory;
    })();
    ApiHeader.LoadBalancerInventory = LoadBalancerInventory;
    var APIRefreshLoadBalancerEvent = (function () {
        function APIRefreshLoadBalancerEvent() {
        }
        return APIRefreshLoadBalancerEvent;
    })();
    ApiHeader.APIRefreshLoadBalancerEvent = APIRefreshLoadBalancerEvent;
    var APICreateLoadBalancerEvent = (function () {
        function APICreateLoadBalancerEvent() {
        }
        return APICreateLoadBalancerEvent;
    })();
    ApiHeader.APICreateLoadBalancerEvent = APICreateLoadBalancerEvent;
    var APIRemoveVmNicFromLoadBalancerEvent = (function () {
        function APIRemoveVmNicFromLoadBalancerEvent() {
        }
        return APIRemoveVmNicFromLoadBalancerEvent;
    })();
    ApiHeader.APIRemoveVmNicFromLoadBalancerEvent = APIRemoveVmNicFromLoadBalancerEvent;
    var APIAddVmNicToLoadBalancerEvent = (function () {
        function APIAddVmNicToLoadBalancerEvent() {
        }
        return APIAddVmNicToLoadBalancerEvent;
    })();
    ApiHeader.APIAddVmNicToLoadBalancerEvent = APIAddVmNicToLoadBalancerEvent;
    var APIDeleteLoadBalancerListenerEvent = (function () {
        function APIDeleteLoadBalancerListenerEvent() {
        }
        return APIDeleteLoadBalancerListenerEvent;
    })();
    ApiHeader.APIDeleteLoadBalancerListenerEvent = APIDeleteLoadBalancerListenerEvent;
    var APICreateLoadBalancerListenerEvent = (function () {
        function APICreateLoadBalancerListenerEvent() {
        }
        return APICreateLoadBalancerListenerEvent;
    })();
    ApiHeader.APICreateLoadBalancerListenerEvent = APICreateLoadBalancerListenerEvent;
    var APIDeleteLoadBalancerEvent = (function () {
        function APIDeleteLoadBalancerEvent() {
        }
        return APIDeleteLoadBalancerEvent;
    })();
    ApiHeader.APIDeleteLoadBalancerEvent = APIDeleteLoadBalancerEvent;
    var SecurityGroupRuleInventory = (function () {
        function SecurityGroupRuleInventory() {
        }
        return SecurityGroupRuleInventory;
    })();
    ApiHeader.SecurityGroupRuleInventory = SecurityGroupRuleInventory;
    var SecurityGroupInventory = (function () {
        function SecurityGroupInventory() {
        }
        return SecurityGroupInventory;
    })();
    ApiHeader.SecurityGroupInventory = SecurityGroupInventory;
    var APIAttachSecurityGroupToL3NetworkEvent = (function () {
        function APIAttachSecurityGroupToL3NetworkEvent() {
        }
        return APIAttachSecurityGroupToL3NetworkEvent;
    })();
    ApiHeader.APIAttachSecurityGroupToL3NetworkEvent = APIAttachSecurityGroupToL3NetworkEvent;
    var APIDeleteSecurityGroupRuleEvent = (function () {
        function APIDeleteSecurityGroupRuleEvent() {
        }
        return APIDeleteSecurityGroupRuleEvent;
    })();
    ApiHeader.APIDeleteSecurityGroupRuleEvent = APIDeleteSecurityGroupRuleEvent;
    var APIAddVmNicToSecurityGroupEvent = (function () {
        function APIAddVmNicToSecurityGroupEvent() {
        }
        return APIAddVmNicToSecurityGroupEvent;
    })();
    ApiHeader.APIAddVmNicToSecurityGroupEvent = APIAddVmNicToSecurityGroupEvent;
    var APIChangeSecurityGroupStateEvent = (function () {
        function APIChangeSecurityGroupStateEvent() {
        }
        return APIChangeSecurityGroupStateEvent;
    })();
    ApiHeader.APIChangeSecurityGroupStateEvent = APIChangeSecurityGroupStateEvent;
    var APIUpdateSecurityGroupEvent = (function () {
        function APIUpdateSecurityGroupEvent() {
        }
        return APIUpdateSecurityGroupEvent;
    })();
    ApiHeader.APIUpdateSecurityGroupEvent = APIUpdateSecurityGroupEvent;
    var APIDeleteVmNicFromSecurityGroupEvent = (function () {
        function APIDeleteVmNicFromSecurityGroupEvent() {
        }
        return APIDeleteVmNicFromSecurityGroupEvent;
    })();
    ApiHeader.APIDeleteVmNicFromSecurityGroupEvent = APIDeleteVmNicFromSecurityGroupEvent;
    var APIAddSecurityGroupRuleEvent = (function () {
        function APIAddSecurityGroupRuleEvent() {
        }
        return APIAddSecurityGroupRuleEvent;
    })();
    ApiHeader.APIAddSecurityGroupRuleEvent = APIAddSecurityGroupRuleEvent;
    var APICreateSecurityGroupEvent = (function () {
        function APICreateSecurityGroupEvent() {
        }
        return APICreateSecurityGroupEvent;
    })();
    ApiHeader.APICreateSecurityGroupEvent = APICreateSecurityGroupEvent;
    var APIDetachSecurityGroupFromL3NetworkEvent = (function () {
        function APIDetachSecurityGroupFromL3NetworkEvent() {
        }
        return APIDetachSecurityGroupFromL3NetworkEvent;
    })();
    ApiHeader.APIDetachSecurityGroupFromL3NetworkEvent = APIDetachSecurityGroupFromL3NetworkEvent;
    var APIDeleteSecurityGroupEvent = (function () {
        function APIDeleteSecurityGroupEvent() {
        }
        return APIDeleteSecurityGroupEvent;
    })();
    ApiHeader.APIDeleteSecurityGroupEvent = APIDeleteSecurityGroupEvent;
    var VipInventory = (function () {
        function VipInventory() {
        }
        return VipInventory;
    })();
    ApiHeader.VipInventory = VipInventory;
    var APICreateVipEvent = (function () {
        function APICreateVipEvent() {
        }
        return APICreateVipEvent;
    })();
    ApiHeader.APICreateVipEvent = APICreateVipEvent;
    var APIUpdateVipEvent = (function () {
        function APIUpdateVipEvent() {
        }
        return APIUpdateVipEvent;
    })();
    ApiHeader.APIUpdateVipEvent = APIUpdateVipEvent;
    var APIDeleteVipEvent = (function () {
        function APIDeleteVipEvent() {
        }
        return APIDeleteVipEvent;
    })();
    ApiHeader.APIDeleteVipEvent = APIDeleteVipEvent;
    var APIChangeVipStateEvent = (function () {
        function APIChangeVipStateEvent() {
        }
        return APIChangeVipStateEvent;
    })();
    ApiHeader.APIChangeVipStateEvent = APIChangeVipStateEvent;
    var APIGetGlobalConfigReply = (function () {
        function APIGetGlobalConfigReply() {
        }
        return APIGetGlobalConfigReply;
    })();
    ApiHeader.APIGetGlobalConfigReply = APIGetGlobalConfigReply;
    var APIQueryGlobalConfigReply = (function () {
        function APIQueryGlobalConfigReply() {
        }
        return APIQueryGlobalConfigReply;
    })();
    ApiHeader.APIQueryGlobalConfigReply = APIQueryGlobalConfigReply;
    var APIListGlobalConfigReply = (function () {
        function APIListGlobalConfigReply() {
        }
        return APIListGlobalConfigReply;
    })();
    ApiHeader.APIListGlobalConfigReply = APIListGlobalConfigReply;
    var APIQueryReply = (function () {
        function APIQueryReply() {
        }
        return APIQueryReply;
    })();
    ApiHeader.APIQueryReply = APIQueryReply;
    var APIGetCpuMemoryCapacityReply = (function () {
        function APIGetCpuMemoryCapacityReply() {
        }
        return APIGetCpuMemoryCapacityReply;
    })();
    ApiHeader.APIGetCpuMemoryCapacityReply = APIGetCpuMemoryCapacityReply;
    var APIGetHostAllocatorStrategiesReply = (function () {
        function APIGetHostAllocatorStrategiesReply() {
        }
        return APIGetHostAllocatorStrategiesReply;
    })();
    ApiHeader.APIGetHostAllocatorStrategiesReply = APIGetHostAllocatorStrategiesReply;
    var APISearchVmInstanceReply = (function () {
        function APISearchVmInstanceReply() {
        }
        return APISearchVmInstanceReply;
    })();
    ApiHeader.APISearchVmInstanceReply = APISearchVmInstanceReply;
    var APIGetVmInstanceReply = (function () {
        function APIGetVmInstanceReply() {
        }
        return APIGetVmInstanceReply;
    })();
    ApiHeader.APIGetVmInstanceReply = APIGetVmInstanceReply;
    var APIGetVmAttachableDataVolumeReply = (function () {
        function APIGetVmAttachableDataVolumeReply() {
        }
        return APIGetVmAttachableDataVolumeReply;
    })();
    ApiHeader.APIGetVmAttachableDataVolumeReply = APIGetVmAttachableDataVolumeReply;
    var APIGetVmMigrationCandidateHostsReply = (function () {
        function APIGetVmMigrationCandidateHostsReply() {
        }
        return APIGetVmMigrationCandidateHostsReply;
    })();
    ApiHeader.APIGetVmMigrationCandidateHostsReply = APIGetVmMigrationCandidateHostsReply;
    var APIListVmInstanceReply = (function () {
        function APIListVmInstanceReply() {
        }
        return APIListVmInstanceReply;
    })();
    ApiHeader.APIListVmInstanceReply = APIListVmInstanceReply;
    var APIListVmNicReply = (function () {
        function APIListVmNicReply() {
        }
        return APIListVmNicReply;
    })();
    ApiHeader.APIListVmNicReply = APIListVmNicReply;
    var APIQueryVmInstanceReply = (function () {
        function APIQueryVmInstanceReply() {
        }
        return APIQueryVmInstanceReply;
    })();
    ApiHeader.APIQueryVmInstanceReply = APIQueryVmInstanceReply;
    var APIQueryVmNicReply = (function () {
        function APIQueryVmNicReply() {
        }
        return APIQueryVmNicReply;
    })();
    ApiHeader.APIQueryVmNicReply = APIQueryVmNicReply;
    var APIGetVmAttachableL3NetworkReply = (function () {
        function APIGetVmAttachableL3NetworkReply() {
        }
        return APIGetVmAttachableL3NetworkReply;
    })();
    ApiHeader.APIGetVmAttachableL3NetworkReply = APIGetVmAttachableL3NetworkReply;
    var APIGetImageReply = (function () {
        function APIGetImageReply() {
        }
        return APIGetImageReply;
    })();
    ApiHeader.APIGetImageReply = APIGetImageReply;
    var APIQueryImageReply = (function () {
        function APIQueryImageReply() {
        }
        return APIQueryImageReply;
    })();
    ApiHeader.APIQueryImageReply = APIQueryImageReply;
    var APIListImageReply = (function () {
        function APIListImageReply() {
        }
        return APIListImageReply;
    })();
    ApiHeader.APIListImageReply = APIListImageReply;
    var APISearchImageReply = (function () {
        function APISearchImageReply() {
        }
        return APISearchImageReply;
    })();
    ApiHeader.APISearchImageReply = APISearchImageReply;
    var VolumeFormatReplyStruct = (function () {
        function VolumeFormatReplyStruct() {
        }
        return VolumeFormatReplyStruct;
    })();
    ApiHeader.VolumeFormatReplyStruct = VolumeFormatReplyStruct;
    var APIGetVolumeFormatReply = (function () {
        function APIGetVolumeFormatReply() {
        }
        return APIGetVolumeFormatReply;
    })();
    ApiHeader.APIGetVolumeFormatReply = APIGetVolumeFormatReply;
    var APIGetDataVolumeAttachableVmReply = (function () {
        function APIGetDataVolumeAttachableVmReply() {
        }
        return APIGetDataVolumeAttachableVmReply;
    })();
    ApiHeader.APIGetDataVolumeAttachableVmReply = APIGetDataVolumeAttachableVmReply;
    var APIQueryVolumeReply = (function () {
        function APIQueryVolumeReply() {
        }
        return APIQueryVolumeReply;
    })();
    ApiHeader.APIQueryVolumeReply = APIQueryVolumeReply;
    var APIGetVolumeReply = (function () {
        function APIGetVolumeReply() {
        }
        return APIGetVolumeReply;
    })();
    ApiHeader.APIGetVolumeReply = APIGetVolumeReply;
    var APIListVolumeReply = (function () {
        function APIListVolumeReply() {
        }
        return APIListVolumeReply;
    })();
    ApiHeader.APIListVolumeReply = APIListVolumeReply;
    var APISearchVolumeReply = (function () {
        function APISearchVolumeReply() {
        }
        return APISearchVolumeReply;
    })();
    ApiHeader.APISearchVolumeReply = APISearchVolumeReply;
    var APIIsReadyToGoReply = (function () {
        function APIIsReadyToGoReply() {
        }
        return APIIsReadyToGoReply;
    })();
    ApiHeader.APIIsReadyToGoReply = APIIsReadyToGoReply;
    var APISearchInstanceOfferingReply = (function () {
        function APISearchInstanceOfferingReply() {
        }
        return APISearchInstanceOfferingReply;
    })();
    ApiHeader.APISearchInstanceOfferingReply = APISearchInstanceOfferingReply;
    var APIGetGlobalPropertyReply = (function () {
        function APIGetGlobalPropertyReply() {
        }
        return APIGetGlobalPropertyReply;
    })();
    ApiHeader.APIGetGlobalPropertyReply = APIGetGlobalPropertyReply;
    var APIListDiskOfferingReply = (function () {
        function APIListDiskOfferingReply() {
        }
        return APIListDiskOfferingReply;
    })();
    ApiHeader.APIListDiskOfferingReply = APIListDiskOfferingReply;
    var APIListInstanceOfferingReply = (function () {
        function APIListInstanceOfferingReply() {
        }
        return APIListInstanceOfferingReply;
    })();
    ApiHeader.APIListInstanceOfferingReply = APIListInstanceOfferingReply;
    var APISearchDnsReply = (function () {
        function APISearchDnsReply() {
        }
        return APISearchDnsReply;
    })();
    ApiHeader.APISearchDnsReply = APISearchDnsReply;
    var APIGetInstanceOfferingReply = (function () {
        function APIGetInstanceOfferingReply() {
        }
        return APIGetInstanceOfferingReply;
    })();
    ApiHeader.APIGetInstanceOfferingReply = APIGetInstanceOfferingReply;
    var APIQueryDiskOfferingReply = (function () {
        function APIQueryDiskOfferingReply() {
        }
        return APIQueryDiskOfferingReply;
    })();
    ApiHeader.APIQueryDiskOfferingReply = APIQueryDiskOfferingReply;
    var APISearchDiskOfferingReply = (function () {
        function APISearchDiskOfferingReply() {
        }
        return APISearchDiskOfferingReply;
    })();
    ApiHeader.APISearchDiskOfferingReply = APISearchDiskOfferingReply;
    var APIGetDiskOfferingReply = (function () {
        function APIGetDiskOfferingReply() {
        }
        return APIGetDiskOfferingReply;
    })();
    ApiHeader.APIGetDiskOfferingReply = APIGetDiskOfferingReply;
    var APIQueryInstanceOfferingReply = (function () {
        function APIQueryInstanceOfferingReply() {
        }
        return APIQueryInstanceOfferingReply;
    })();
    ApiHeader.APIQueryInstanceOfferingReply = APIQueryInstanceOfferingReply;
    var APIListPrimaryStorageReply = (function () {
        function APIListPrimaryStorageReply() {
        }
        return APIListPrimaryStorageReply;
    })();
    ApiHeader.APIListPrimaryStorageReply = APIListPrimaryStorageReply;
    var APIGetPrimaryStorageTypesReply = (function () {
        function APIGetPrimaryStorageTypesReply() {
        }
        return APIGetPrimaryStorageTypesReply;
    })();
    ApiHeader.APIGetPrimaryStorageTypesReply = APIGetPrimaryStorageTypesReply;
    var CreateTemplateFromVolumeOnPrimaryStorageReply = (function () {
        function CreateTemplateFromVolumeOnPrimaryStorageReply() {
        }
        return CreateTemplateFromVolumeOnPrimaryStorageReply;
    })();
    ApiHeader.CreateTemplateFromVolumeOnPrimaryStorageReply = CreateTemplateFromVolumeOnPrimaryStorageReply;
    var APIGetPrimaryStorageReply = (function () {
        function APIGetPrimaryStorageReply() {
        }
        return APIGetPrimaryStorageReply;
    })();
    ApiHeader.APIGetPrimaryStorageReply = APIGetPrimaryStorageReply;
    var APISearchPrimaryStorageReply = (function () {
        function APISearchPrimaryStorageReply() {
        }
        return APISearchPrimaryStorageReply;
    })();
    ApiHeader.APISearchPrimaryStorageReply = APISearchPrimaryStorageReply;
    var APIGetPrimaryStorageAllocatorStrategiesReply = (function () {
        function APIGetPrimaryStorageAllocatorStrategiesReply() {
        }
        return APIGetPrimaryStorageAllocatorStrategiesReply;
    })();
    ApiHeader.APIGetPrimaryStorageAllocatorStrategiesReply = APIGetPrimaryStorageAllocatorStrategiesReply;
    var APIQueryPrimaryStorageReply = (function () {
        function APIQueryPrimaryStorageReply() {
        }
        return APIQueryPrimaryStorageReply;
    })();
    ApiHeader.APIQueryPrimaryStorageReply = APIQueryPrimaryStorageReply;
    var APIGetPrimaryStorageCapacityReply = (function () {
        function APIGetPrimaryStorageCapacityReply() {
        }
        return APIGetPrimaryStorageCapacityReply;
    })();
    ApiHeader.APIGetPrimaryStorageCapacityReply = APIGetPrimaryStorageCapacityReply;
    var APIQueryVolumeSnapshotReply = (function () {
        function APIQueryVolumeSnapshotReply() {
        }
        return APIQueryVolumeSnapshotReply;
    })();
    ApiHeader.APIQueryVolumeSnapshotReply = APIQueryVolumeSnapshotReply;
    var SnapshotLeafInventory = (function () {
        function SnapshotLeafInventory() {
        }
        return SnapshotLeafInventory;
    })();
    ApiHeader.SnapshotLeafInventory = SnapshotLeafInventory;
    var VolumeSnapshotTreeInventory = (function () {
        function VolumeSnapshotTreeInventory() {
        }
        return VolumeSnapshotTreeInventory;
    })();
    ApiHeader.VolumeSnapshotTreeInventory = VolumeSnapshotTreeInventory;
    var APIQueryVolumeSnapshotTreeReply = (function () {
        function APIQueryVolumeSnapshotTreeReply() {
        }
        return APIQueryVolumeSnapshotTreeReply;
    })();
    ApiHeader.APIQueryVolumeSnapshotTreeReply = APIQueryVolumeSnapshotTreeReply;
    var APIGetVolumeSnapshotTreeReply = (function () {
        function APIGetVolumeSnapshotTreeReply() {
        }
        return APIGetVolumeSnapshotTreeReply;
    })();
    ApiHeader.APIGetVolumeSnapshotTreeReply = APIGetVolumeSnapshotTreeReply;
    var APISearchBackupStorageReply = (function () {
        function APISearchBackupStorageReply() {
        }
        return APISearchBackupStorageReply;
    })();
    ApiHeader.APISearchBackupStorageReply = APISearchBackupStorageReply;
    var APIGetBackupStorageCapacityReply = (function () {
        function APIGetBackupStorageCapacityReply() {
        }
        return APIGetBackupStorageCapacityReply;
    })();
    ApiHeader.APIGetBackupStorageCapacityReply = APIGetBackupStorageCapacityReply;
    var APIQueryBackupStorageReply = (function () {
        function APIQueryBackupStorageReply() {
        }
        return APIQueryBackupStorageReply;
    })();
    ApiHeader.APIQueryBackupStorageReply = APIQueryBackupStorageReply;
    var APIGetBackupStorageTypesReply = (function () {
        function APIGetBackupStorageTypesReply() {
        }
        return APIGetBackupStorageTypesReply;
    })();
    ApiHeader.APIGetBackupStorageTypesReply = APIGetBackupStorageTypesReply;
    var APIGetBackupStorageReply = (function () {
        function APIGetBackupStorageReply() {
        }
        return APIGetBackupStorageReply;
    })();
    ApiHeader.APIGetBackupStorageReply = APIGetBackupStorageReply;
    var APIListBackupStorageReply = (function () {
        function APIListBackupStorageReply() {
        }
        return APIListBackupStorageReply;
    })();
    ApiHeader.APIListBackupStorageReply = APIListBackupStorageReply;
    var APIListIpRangeReply = (function () {
        function APIListIpRangeReply() {
        }
        return APIListIpRangeReply;
    })();
    ApiHeader.APIListIpRangeReply = APIListIpRangeReply;
    var APISearchL3NetworkReply = (function () {
        function APISearchL3NetworkReply() {
        }
        return APISearchL3NetworkReply;
    })();
    ApiHeader.APISearchL3NetworkReply = APISearchL3NetworkReply;
    var APIGetL3NetworkTypesReply = (function () {
        function APIGetL3NetworkTypesReply() {
        }
        return APIGetL3NetworkTypesReply;
    })();
    ApiHeader.APIGetL3NetworkTypesReply = APIGetL3NetworkTypesReply;
    var APIGetL3NetworkReply = (function () {
        function APIGetL3NetworkReply() {
        }
        return APIGetL3NetworkReply;
    })();
    ApiHeader.APIGetL3NetworkReply = APIGetL3NetworkReply;
    var APIGetIpAddressCapacityReply = (function () {
        function APIGetIpAddressCapacityReply() {
        }
        return APIGetIpAddressCapacityReply;
    })();
    ApiHeader.APIGetIpAddressCapacityReply = APIGetIpAddressCapacityReply;
    var APIQueryL3NetworkReply = (function () {
        function APIQueryL3NetworkReply() {
        }
        return APIQueryL3NetworkReply;
    })();
    ApiHeader.APIQueryL3NetworkReply = APIQueryL3NetworkReply;
    var FreeIpInventory = (function () {
        function FreeIpInventory() {
        }
        return FreeIpInventory;
    })();
    ApiHeader.FreeIpInventory = FreeIpInventory;
    var APIGetFreeIpReply = (function () {
        function APIGetFreeIpReply() {
        }
        return APIGetFreeIpReply;
    })();
    ApiHeader.APIGetFreeIpReply = APIGetFreeIpReply;
    var APIQueryIpRangeReply = (function () {
        function APIQueryIpRangeReply() {
        }
        return APIQueryIpRangeReply;
    })();
    ApiHeader.APIQueryIpRangeReply = APIQueryIpRangeReply;
    var APIListL3NetworkReply = (function () {
        function APIListL3NetworkReply() {
        }
        return APIListL3NetworkReply;
    })();
    ApiHeader.APIListL3NetworkReply = APIListL3NetworkReply;
    var APIQueryNetworkServiceL3NetworkRefReply = (function () {
        function APIQueryNetworkServiceL3NetworkRefReply() {
        }
        return APIQueryNetworkServiceL3NetworkRefReply;
    })();
    ApiHeader.APIQueryNetworkServiceL3NetworkRefReply = APIQueryNetworkServiceL3NetworkRefReply;
    var APISearchNetworkServiceProviderReply = (function () {
        function APISearchNetworkServiceProviderReply() {
        }
        return APISearchNetworkServiceProviderReply;
    })();
    ApiHeader.APISearchNetworkServiceProviderReply = APISearchNetworkServiceProviderReply;
    var APIGetNetworkServiceProviderReply = (function () {
        function APIGetNetworkServiceProviderReply() {
        }
        return APIGetNetworkServiceProviderReply;
    })();
    ApiHeader.APIGetNetworkServiceProviderReply = APIGetNetworkServiceProviderReply;
    var APIGetNetworkServiceTypesReply = (function () {
        function APIGetNetworkServiceTypesReply() {
        }
        return APIGetNetworkServiceTypesReply;
    })();
    ApiHeader.APIGetNetworkServiceTypesReply = APIGetNetworkServiceTypesReply;
    var APIListNetworkServiceProviderReply = (function () {
        function APIListNetworkServiceProviderReply() {
        }
        return APIListNetworkServiceProviderReply;
    })();
    ApiHeader.APIListNetworkServiceProviderReply = APIListNetworkServiceProviderReply;
    var APIQueryNetworkServiceProviderReply = (function () {
        function APIQueryNetworkServiceProviderReply() {
        }
        return APIQueryNetworkServiceProviderReply;
    })();
    ApiHeader.APIQueryNetworkServiceProviderReply = APIQueryNetworkServiceProviderReply;
    var APIGetL2VlanNetworkReply = (function () {
        function APIGetL2VlanNetworkReply() {
        }
        return APIGetL2VlanNetworkReply;
    })();
    ApiHeader.APIGetL2VlanNetworkReply = APIGetL2VlanNetworkReply;
    var APIGetL2NetworkReply = (function () {
        function APIGetL2NetworkReply() {
        }
        return APIGetL2NetworkReply;
    })();
    ApiHeader.APIGetL2NetworkReply = APIGetL2NetworkReply;
    var APIQueryL2VlanNetworkReply = (function () {
        function APIQueryL2VlanNetworkReply() {
        }
        return APIQueryL2VlanNetworkReply;
    })();
    ApiHeader.APIQueryL2VlanNetworkReply = APIQueryL2VlanNetworkReply;
    var APIGetL2NetworkTypesReply = (function () {
        function APIGetL2NetworkTypesReply() {
        }
        return APIGetL2NetworkTypesReply;
    })();
    ApiHeader.APIGetL2NetworkTypesReply = APIGetL2NetworkTypesReply;
    var APIListL2VlanNetworkReply = (function () {
        function APIListL2VlanNetworkReply() {
        }
        return APIListL2VlanNetworkReply;
    })();
    ApiHeader.APIListL2VlanNetworkReply = APIListL2VlanNetworkReply;
    var APISearchL2VlanNetworkReply = (function () {
        function APISearchL2VlanNetworkReply() {
        }
        return APISearchL2VlanNetworkReply;
    })();
    ApiHeader.APISearchL2VlanNetworkReply = APISearchL2VlanNetworkReply;
    var APIQueryL2NetworkReply = (function () {
        function APIQueryL2NetworkReply() {
        }
        return APIQueryL2NetworkReply;
    })();
    ApiHeader.APIQueryL2NetworkReply = APIQueryL2NetworkReply;
    var APISearchL2NetworkReply = (function () {
        function APISearchL2NetworkReply() {
        }
        return APISearchL2NetworkReply;
    })();
    ApiHeader.APISearchL2NetworkReply = APISearchL2NetworkReply;
    var APIListL2NetworkReply = (function () {
        function APIListL2NetworkReply() {
        }
        return APIListL2NetworkReply;
    })();
    ApiHeader.APIListL2NetworkReply = APIListL2NetworkReply;
    var APISearchReply = (function () {
        function APISearchReply() {
        }
        return APISearchReply;
    })();
    ApiHeader.APISearchReply = APISearchReply;
    var APIQueryUserTagReply = (function () {
        function APIQueryUserTagReply() {
        }
        return APIQueryUserTagReply;
    })();
    ApiHeader.APIQueryUserTagReply = APIQueryUserTagReply;
    var APIQuerySystemTagReply = (function () {
        function APIQuerySystemTagReply() {
        }
        return APIQuerySystemTagReply;
    })();
    ApiHeader.APIQuerySystemTagReply = APIQuerySystemTagReply;
    var APIQueryTagReply = (function () {
        function APIQueryTagReply() {
        }
        return APIQueryTagReply;
    })();
    ApiHeader.APIQueryTagReply = APIQueryTagReply;
    var ManagementNodeInventory = (function () {
        function ManagementNodeInventory() {
        }
        return ManagementNodeInventory;
    })();
    ApiHeader.ManagementNodeInventory = ManagementNodeInventory;
    var APIQueryManagementNodeReply = (function () {
        function APIQueryManagementNodeReply() {
        }
        return APIQueryManagementNodeReply;
    })();
    ApiHeader.APIQueryManagementNodeReply = APIQueryManagementNodeReply;
    var APIListManagementNodeReply = (function () {
        function APIListManagementNodeReply() {
        }
        return APIListManagementNodeReply;
    })();
    ApiHeader.APIListManagementNodeReply = APIListManagementNodeReply;
    var APIReply = (function () {
        function APIReply() {
        }
        return APIReply;
    })();
    ApiHeader.APIReply = APIReply;
    var APISearchClusterReply = (function () {
        function APISearchClusterReply() {
        }
        return APISearchClusterReply;
    })();
    ApiHeader.APISearchClusterReply = APISearchClusterReply;
    var APIListClusterReply = (function () {
        function APIListClusterReply() {
        }
        return APIListClusterReply;
    })();
    ApiHeader.APIListClusterReply = APIListClusterReply;
    var APIGetClusterReply = (function () {
        function APIGetClusterReply() {
        }
        return APIGetClusterReply;
    })();
    ApiHeader.APIGetClusterReply = APIGetClusterReply;
    var APIQueryClusterReply = (function () {
        function APIQueryClusterReply() {
        }
        return APIQueryClusterReply;
    })();
    ApiHeader.APIQueryClusterReply = APIQueryClusterReply;
    var APIListUserReply = (function () {
        function APIListUserReply() {
        }
        return APIListUserReply;
    })();
    ApiHeader.APIListUserReply = APIListUserReply;
    var APIQueryUserGroupReply = (function () {
        function APIQueryUserGroupReply() {
        }
        return APIQueryUserGroupReply;
    })();
    ApiHeader.APIQueryUserGroupReply = APIQueryUserGroupReply;
    var APIGetUserReply = (function () {
        function APIGetUserReply() {
        }
        return APIGetUserReply;
    })();
    ApiHeader.APIGetUserReply = APIGetUserReply;
    var APIGetAccountReply = (function () {
        function APIGetAccountReply() {
        }
        return APIGetAccountReply;
    })();
    ApiHeader.APIGetAccountReply = APIGetAccountReply;
    var APIQueryUserReply = (function () {
        function APIQueryUserReply() {
        }
        return APIQueryUserReply;
    })();
    ApiHeader.APIQueryUserReply = APIQueryUserReply;
    var APIListAccountReply = (function () {
        function APIListAccountReply() {
        }
        return APIListAccountReply;
    })();
    ApiHeader.APIListAccountReply = APIListAccountReply;
    var APISearchPolicyReply = (function () {
        function APISearchPolicyReply() {
        }
        return APISearchPolicyReply;
    })();
    ApiHeader.APISearchPolicyReply = APISearchPolicyReply;
    var APIQueryAccountReply = (function () {
        function APIQueryAccountReply() {
        }
        return APIQueryAccountReply;
    })();
    ApiHeader.APIQueryAccountReply = APIQueryAccountReply;
    var APILogOutReply = (function () {
        function APILogOutReply() {
        }
        return APILogOutReply;
    })();
    ApiHeader.APILogOutReply = APILogOutReply;
    var APISearchUserGroupReply = (function () {
        function APISearchUserGroupReply() {
        }
        return APISearchUserGroupReply;
    })();
    ApiHeader.APISearchUserGroupReply = APISearchUserGroupReply;
    var APIGetPolicyReply = (function () {
        function APIGetPolicyReply() {
        }
        return APIGetPolicyReply;
    })();
    ApiHeader.APIGetPolicyReply = APIGetPolicyReply;
    var APILogInReply = (function () {
        function APILogInReply() {
        }
        return APILogInReply;
    })();
    ApiHeader.APILogInReply = APILogInReply;
    var APIListPolicyReply = (function () {
        function APIListPolicyReply() {
        }
        return APIListPolicyReply;
    })();
    ApiHeader.APIListPolicyReply = APIListPolicyReply;
    var APIQueryQuotaReply = (function () {
        function APIQueryQuotaReply() {
        }
        return APIQueryQuotaReply;
    })();
    ApiHeader.APIQueryQuotaReply = APIQueryQuotaReply;
    var APIGetUserGroupReply = (function () {
        function APIGetUserGroupReply() {
        }
        return APIGetUserGroupReply;
    })();
    ApiHeader.APIGetUserGroupReply = APIGetUserGroupReply;
    var APIQueryPolicyReply = (function () {
        function APIQueryPolicyReply() {
        }
        return APIQueryPolicyReply;
    })();
    ApiHeader.APIQueryPolicyReply = APIQueryPolicyReply;
    var APISearchAccountReply = (function () {
        function APISearchAccountReply() {
        }
        return APISearchAccountReply;
    })();
    ApiHeader.APISearchAccountReply = APISearchAccountReply;
    var APISearchUserReply = (function () {
        function APISearchUserReply() {
        }
        return APISearchUserReply;
    })();
    ApiHeader.APISearchUserReply = APISearchUserReply;
    var APIValidateSessionReply = (function () {
        function APIValidateSessionReply() {
        }
        return APIValidateSessionReply;
    })();
    ApiHeader.APIValidateSessionReply = APIValidateSessionReply;
    var APIGetZoneReply = (function () {
        function APIGetZoneReply() {
        }
        return APIGetZoneReply;
    })();
    ApiHeader.APIGetZoneReply = APIGetZoneReply;
    var APISearchZoneReply = (function () {
        function APISearchZoneReply() {
        }
        return APISearchZoneReply;
    })();
    ApiHeader.APISearchZoneReply = APISearchZoneReply;
    var APIListZonesReply = (function () {
        function APIListZonesReply() {
        }
        return APIListZonesReply;
    })();
    ApiHeader.APIListZonesReply = APIListZonesReply;
    var APIQueryZoneReply = (function () {
        function APIQueryZoneReply() {
        }
        return APIQueryZoneReply;
    })();
    ApiHeader.APIQueryZoneReply = APIQueryZoneReply;
    var APIGetHypervisorTypesReply = (function () {
        function APIGetHypervisorTypesReply() {
        }
        return APIGetHypervisorTypesReply;
    })();
    ApiHeader.APIGetHypervisorTypesReply = APIGetHypervisorTypesReply;
    var APIGetHostReply = (function () {
        function APIGetHostReply() {
        }
        return APIGetHostReply;
    })();
    ApiHeader.APIGetHostReply = APIGetHostReply;
    var APIListHostReply = (function () {
        function APIListHostReply() {
        }
        return APIListHostReply;
    })();
    ApiHeader.APIListHostReply = APIListHostReply;
    var APISearchHostReply = (function () {
        function APISearchHostReply() {
        }
        return APISearchHostReply;
    })();
    ApiHeader.APISearchHostReply = APISearchHostReply;
    var APIQueryHostReply = (function () {
        function APIQueryHostReply() {
        }
        return APIQueryHostReply;
    })();
    ApiHeader.APIQueryHostReply = APIQueryHostReply;
    var APIQueryApplianceVmReply = (function () {
        function APIQueryApplianceVmReply() {
        }
        return APIQueryApplianceVmReply;
    })();
    ApiHeader.APIQueryApplianceVmReply = APIQueryApplianceVmReply;
    var APIListApplianceVmReply = (function () {
        function APIListApplianceVmReply() {
        }
        return APIListApplianceVmReply;
    })();
    ApiHeader.APIListApplianceVmReply = APIListApplianceVmReply;
    var IscsiFileSystemBackendPrimaryStorageInventory = (function () {
        function IscsiFileSystemBackendPrimaryStorageInventory() {
        }
        return IscsiFileSystemBackendPrimaryStorageInventory;
    })();
    ApiHeader.IscsiFileSystemBackendPrimaryStorageInventory = IscsiFileSystemBackendPrimaryStorageInventory;
    var APIQueryIscsiFileSystemBackendPrimaryStorageReply = (function () {
        function APIQueryIscsiFileSystemBackendPrimaryStorageReply() {
        }
        return APIQueryIscsiFileSystemBackendPrimaryStorageReply;
    })();
    ApiHeader.APIQueryIscsiFileSystemBackendPrimaryStorageReply = APIQueryIscsiFileSystemBackendPrimaryStorageReply;
    var APIGetSftpBackupStorageReply = (function () {
        function APIGetSftpBackupStorageReply() {
        }
        return APIGetSftpBackupStorageReply;
    })();
    ApiHeader.APIGetSftpBackupStorageReply = APIGetSftpBackupStorageReply;
    var APIQuerySftpBackupStorageReply = (function () {
        function APIQuerySftpBackupStorageReply() {
        }
        return APIQuerySftpBackupStorageReply;
    })();
    ApiHeader.APIQuerySftpBackupStorageReply = APIQuerySftpBackupStorageReply;
    var APISearchSftpBackupStorageReply = (function () {
        function APISearchSftpBackupStorageReply() {
        }
        return APISearchSftpBackupStorageReply;
    })();
    ApiHeader.APISearchSftpBackupStorageReply = APISearchSftpBackupStorageReply;
    var APISearchVirtualRouterVmReply = (function () {
        function APISearchVirtualRouterVmReply() {
        }
        return APISearchVirtualRouterVmReply;
    })();
    ApiHeader.APISearchVirtualRouterVmReply = APISearchVirtualRouterVmReply;
    var APIGetVirtualRouterOfferingReply = (function () {
        function APIGetVirtualRouterOfferingReply() {
        }
        return APIGetVirtualRouterOfferingReply;
    })();
    ApiHeader.APIGetVirtualRouterOfferingReply = APIGetVirtualRouterOfferingReply;
    var APISearchVirtualRouterOffingReply = (function () {
        function APISearchVirtualRouterOffingReply() {
        }
        return APISearchVirtualRouterOffingReply;
    })();
    ApiHeader.APISearchVirtualRouterOffingReply = APISearchVirtualRouterOffingReply;
    var VirtualRouterOfferingInventory = (function () {
        function VirtualRouterOfferingInventory() {
        }
        return VirtualRouterOfferingInventory;
    })();
    ApiHeader.VirtualRouterOfferingInventory = VirtualRouterOfferingInventory;
    var APIQueryVirtualRouterOfferingReply = (function () {
        function APIQueryVirtualRouterOfferingReply() {
        }
        return APIQueryVirtualRouterOfferingReply;
    })();
    ApiHeader.APIQueryVirtualRouterOfferingReply = APIQueryVirtualRouterOfferingReply;
    var VirtualRouterVmInventory = (function () {
        function VirtualRouterVmInventory() {
        }
        return VirtualRouterVmInventory;
    })();
    ApiHeader.VirtualRouterVmInventory = VirtualRouterVmInventory;
    var APIQueryVirtualRouterVmReply = (function () {
        function APIQueryVirtualRouterVmReply() {
        }
        return APIQueryVirtualRouterVmReply;
    })();
    ApiHeader.APIQueryVirtualRouterVmReply = APIQueryVirtualRouterVmReply;
    var APIQueryPortForwardingRuleReply = (function () {
        function APIQueryPortForwardingRuleReply() {
        }
        return APIQueryPortForwardingRuleReply;
    })();
    ApiHeader.APIQueryPortForwardingRuleReply = APIQueryPortForwardingRuleReply;
    var APIListPortForwardingRuleReply = (function () {
        function APIListPortForwardingRuleReply() {
        }
        return APIListPortForwardingRuleReply;
    })();
    ApiHeader.APIListPortForwardingRuleReply = APIListPortForwardingRuleReply;
    var APIGetPortForwardingAttachableVmNicsReply = (function () {
        function APIGetPortForwardingAttachableVmNicsReply() {
        }
        return APIGetPortForwardingAttachableVmNicsReply;
    })();
    ApiHeader.APIGetPortForwardingAttachableVmNicsReply = APIGetPortForwardingAttachableVmNicsReply;
    var APIQueryEipReply = (function () {
        function APIQueryEipReply() {
        }
        return APIQueryEipReply;
    })();
    ApiHeader.APIQueryEipReply = APIQueryEipReply;
    var APIGetEipAttachableVmNicsReply = (function () {
        function APIGetEipAttachableVmNicsReply() {
        }
        return APIGetEipAttachableVmNicsReply;
    })();
    ApiHeader.APIGetEipAttachableVmNicsReply = APIGetEipAttachableVmNicsReply;
    var APIQueryLoadBalancerListenerReply = (function () {
        function APIQueryLoadBalancerListenerReply() {
        }
        return APIQueryLoadBalancerListenerReply;
    })();
    ApiHeader.APIQueryLoadBalancerListenerReply = APIQueryLoadBalancerListenerReply;
    var APIQueryLoadBalancerReply = (function () {
        function APIQueryLoadBalancerReply() {
        }
        return APIQueryLoadBalancerReply;
    })();
    ApiHeader.APIQueryLoadBalancerReply = APIQueryLoadBalancerReply;
    var APIListSecurityGroupReply = (function () {
        function APIListSecurityGroupReply() {
        }
        return APIListSecurityGroupReply;
    })();
    ApiHeader.APIListSecurityGroupReply = APIListSecurityGroupReply;
    var APIQuerySecurityGroupRuleReply = (function () {
        function APIQuerySecurityGroupRuleReply() {
        }
        return APIQuerySecurityGroupRuleReply;
    })();
    ApiHeader.APIQuerySecurityGroupRuleReply = APIQuerySecurityGroupRuleReply;
    var APIGetCandidateVmNicForSecurityGroupReply = (function () {
        function APIGetCandidateVmNicForSecurityGroupReply() {
        }
        return APIGetCandidateVmNicForSecurityGroupReply;
    })();
    ApiHeader.APIGetCandidateVmNicForSecurityGroupReply = APIGetCandidateVmNicForSecurityGroupReply;
    var VmNicSecurityGroupRefInventory = (function () {
        function VmNicSecurityGroupRefInventory() {
        }
        return VmNicSecurityGroupRefInventory;
    })();
    ApiHeader.VmNicSecurityGroupRefInventory = VmNicSecurityGroupRefInventory;
    var APIListVmNicInSecurityGroupReply = (function () {
        function APIListVmNicInSecurityGroupReply() {
        }
        return APIListVmNicInSecurityGroupReply;
    })();
    ApiHeader.APIListVmNicInSecurityGroupReply = APIListVmNicInSecurityGroupReply;
    var APIQuerySecurityGroupReply = (function () {
        function APIQuerySecurityGroupReply() {
        }
        return APIQuerySecurityGroupReply;
    })();
    ApiHeader.APIQuerySecurityGroupReply = APIQuerySecurityGroupReply;
    var APIQueryVmNicInSecurityGroupReply = (function () {
        function APIQueryVmNicInSecurityGroupReply() {
        }
        return APIQueryVmNicInSecurityGroupReply;
    })();
    ApiHeader.APIQueryVmNicInSecurityGroupReply = APIQueryVmNicInSecurityGroupReply;
    var APIQueryVipReply = (function () {
        function APIQueryVipReply() {
        }
        return APIQueryVipReply;
    })();
    ApiHeader.APIQueryVipReply = APIQueryVipReply;
    var HostCapacityInventory = (function () {
        function HostCapacityInventory() {
        }
        return HostCapacityInventory;
    })();
    ApiHeader.HostCapacityInventory = HostCapacityInventory;
    var ConsoleProxyInventory = (function () {
        function ConsoleProxyInventory() {
        }
        return ConsoleProxyInventory;
    })();
    ApiHeader.ConsoleProxyInventory = ConsoleProxyInventory;
    var PrimaryStorageClusterRefInventory = (function () {
        function PrimaryStorageClusterRefInventory() {
        }
        return PrimaryStorageClusterRefInventory;
    })();
    ApiHeader.PrimaryStorageClusterRefInventory = PrimaryStorageClusterRefInventory;
    var PrimaryStorageCapacityInventory = (function () {
        function PrimaryStorageCapacityInventory() {
        }
        return PrimaryStorageCapacityInventory;
    })();
    ApiHeader.PrimaryStorageCapacityInventory = PrimaryStorageCapacityInventory;
    var BackupStorageZoneRefInventory = (function () {
        function BackupStorageZoneRefInventory() {
        }
        return BackupStorageZoneRefInventory;
    })();
    ApiHeader.BackupStorageZoneRefInventory = BackupStorageZoneRefInventory;
    var IpUseInventory = (function () {
        function IpUseInventory() {
        }
        return IpUseInventory;
    })();
    ApiHeader.IpUseInventory = IpUseInventory;
    var L3NetworkDnsInventory = (function () {
        function L3NetworkDnsInventory() {
        }
        return L3NetworkDnsInventory;
    })();
    ApiHeader.L3NetworkDnsInventory = L3NetworkDnsInventory;
    var NetworkServiceTypeInventory = (function () {
        function NetworkServiceTypeInventory() {
        }
        return NetworkServiceTypeInventory;
    })();
    ApiHeader.NetworkServiceTypeInventory = NetworkServiceTypeInventory;
    var NetworkServiceProviderL2NetworkRefInventory = (function () {
        function NetworkServiceProviderL2NetworkRefInventory() {
        }
        return NetworkServiceProviderL2NetworkRefInventory;
    })();
    ApiHeader.NetworkServiceProviderL2NetworkRefInventory = NetworkServiceProviderL2NetworkRefInventory;
    var L2NetworkClusterRefInventory = (function () {
        function L2NetworkClusterRefInventory() {
        }
        return L2NetworkClusterRefInventory;
    })();
    ApiHeader.L2NetworkClusterRefInventory = L2NetworkClusterRefInventory;
    var AccountResourceRefInventory = (function () {
        function AccountResourceRefInventory() {
        }
        return AccountResourceRefInventory;
    })();
    ApiHeader.AccountResourceRefInventory = AccountResourceRefInventory;
    var UserGroupPolicyRefInventory = (function () {
        function UserGroupPolicyRefInventory() {
        }
        return UserGroupPolicyRefInventory;
    })();
    ApiHeader.UserGroupPolicyRefInventory = UserGroupPolicyRefInventory;
    var UserPolicyRefInventory = (function () {
        function UserPolicyRefInventory() {
        }
        return UserPolicyRefInventory;
    })();
    ApiHeader.UserPolicyRefInventory = UserPolicyRefInventory;
    var UserGroupUserRefInventory = (function () {
        function UserGroupUserRefInventory() {
        }
        return UserGroupUserRefInventory;
    })();
    ApiHeader.UserGroupUserRefInventory = UserGroupUserRefInventory;
    var SimulatorHostInventory = (function () {
        function SimulatorHostInventory() {
        }
        return SimulatorHostInventory;
    })();
    ApiHeader.SimulatorHostInventory = SimulatorHostInventory;
    var ApplianceVmFirewallRuleInventory = (function () {
        function ApplianceVmFirewallRuleInventory() {
        }
        return ApplianceVmFirewallRuleInventory;
    })();
    ApiHeader.ApplianceVmFirewallRuleInventory = ApplianceVmFirewallRuleInventory;
    var KVMHostInventory = (function () {
        function KVMHostInventory() {
        }
        return KVMHostInventory;
    })();
    ApiHeader.KVMHostInventory = KVMHostInventory;
    var VirtualRouterEipRefInventory = (function () {
        function VirtualRouterEipRefInventory() {
        }
        return VirtualRouterEipRefInventory;
    })();
    ApiHeader.VirtualRouterEipRefInventory = VirtualRouterEipRefInventory;
    var VirtualRouterLoadBalancerRefInventory = (function () {
        function VirtualRouterLoadBalancerRefInventory() {
        }
        return VirtualRouterLoadBalancerRefInventory;
    })();
    ApiHeader.VirtualRouterLoadBalancerRefInventory = VirtualRouterLoadBalancerRefInventory;
    var VirtualRouterVipInventory = (function () {
        function VirtualRouterVipInventory() {
        }
        return VirtualRouterVipInventory;
    })();
    ApiHeader.VirtualRouterVipInventory = VirtualRouterVipInventory;
    var VirtualRouterPortForwardingRuleRefInventory = (function () {
        function VirtualRouterPortForwardingRuleRefInventory() {
        }
        return VirtualRouterPortForwardingRuleRefInventory;
    })();
    ApiHeader.VirtualRouterPortForwardingRuleRefInventory = VirtualRouterPortForwardingRuleRefInventory;
    var SecurityGroupL3NetworkRefInventory = (function () {
        function SecurityGroupL3NetworkRefInventory() {
        }
        return SecurityGroupL3NetworkRefInventory;
    })();
    ApiHeader.SecurityGroupL3NetworkRefInventory = SecurityGroupL3NetworkRefInventory;
    ApiHeader.GlobalConfigInventoryQueryable = ['name', 'category', 'description', 'defaultValue', 'value'];
    ApiHeader.TagResourceTypeGlobalConfigVO = 'GlobalConfigVO';
    ApiHeader.HostCapacityInventoryQueryable = ['uuid', 'totalMemory', 'totalCpu', 'availableMemory', 'availableCpu'];
    ApiHeader.TagResourceTypeHostCapacityVO = 'HostCapacityVO';
    ApiHeader.VmNicInventoryQueryable = ['uuid', 'vmInstanceUuid', 'l3NetworkUuid', 'ip', 'mac', 'netmask', 'gateway', 'metaData', 'deviceId', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeVmNicVO = 'VmNicVO';
    ApiHeader.VmInstanceInventoryQueryable = ['uuid', 'name', 'description', 'zoneUuid', 'clusterUuid', 'imageUuid', 'hostUuid', 'lastHostUuid', 'instanceOfferingUuid', 'rootVolumeUuid', 'platform', 'defaultL3NetworkUuid', 'type', 'hypervisorType', 'memorySize', 'cpuNum', 'cpuSpeed', 'allocatorStrategy', 'createDate', 'lastOpDate', 'state', 'vmNics.uuid', 'vmNics.vmInstanceUuid', 'vmNics.l3NetworkUuid', 'vmNics.ip', 'vmNics.mac', 'vmNics.netmask', 'vmNics.gateway', 'vmNics.metaData', 'vmNics.deviceId', 'vmNics.createDate', 'vmNics.lastOpDate', 'allVolumes.uuid', 'allVolumes.name', 'allVolumes.description', 'allVolumes.primaryStorageUuid', 'allVolumes.vmInstanceUuid', 'allVolumes.diskOfferingUuid', 'allVolumes.rootImageUuid', 'allVolumes.installPath', 'allVolumes.type', 'allVolumes.format', 'allVolumes.size', 'allVolumes.deviceId', 'allVolumes.state', 'allVolumes.status', 'allVolumes.createDate', 'allVolumes.lastOpDate'];
    ApiHeader.TagResourceTypeVmInstanceVO = 'VmInstanceVO';
    ApiHeader.ImageInventoryQueryable = ['uuid', 'name', 'description', 'state', 'status', 'size', 'md5Sum', 'url', 'mediaType', 'guestOsType', 'type', 'platform', 'format', 'system', 'createDate', 'lastOpDate', 'backupStorageRefs.imageUuid', 'backupStorageRefs.backupStorageUuid', 'backupStorageRefs.installPath', 'backupStorageRefs.createDate', 'backupStorageRefs.lastOpDate'];
    ApiHeader.TagResourceTypeImageVO = 'ImageVO';
    ApiHeader.ImageBackupStorageRefInventoryQueryable = ['imageUuid', 'backupStorageUuid', 'installPath', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeImageBackupStorageRefVO = 'ImageBackupStorageRefVO';
    ApiHeader.ConsoleProxyInventoryQueryable = ['uuid', 'vmInstanceUuid', 'agentIp', 'token', 'agentType', 'proxyHostname', 'proxyPort', 'targetHostname', 'targetPort', 'scheme', 'proxyIdentity', 'status', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeConsoleProxyVO = 'ConsoleProxyVO';
    ApiHeader.VolumeInventoryQueryable = ['uuid', 'name', 'description', 'primaryStorageUuid', 'vmInstanceUuid', 'diskOfferingUuid', 'rootImageUuid', 'installPath', 'type', 'format', 'size', 'deviceId', 'state', 'status', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeVolumeVO = 'VolumeVO';
    ApiHeader.InstanceOfferingInventoryQueryable = ['uuid', 'name', 'description', 'cpuNum', 'cpuSpeed', 'memorySize', 'type', 'allocatorStrategy', 'sortKey', 'createDate', 'lastOpDate', 'state'];
    ApiHeader.TagResourceTypeInstanceOfferingVO = 'InstanceOfferingVO';
    ApiHeader.DiskOfferingInventoryQueryable = ['uuid', 'name', 'description', 'diskSize', 'sortKey', 'state', 'type', 'createDate', 'lastOpDate', 'allocatorStrategy'];
    ApiHeader.TagResourceTypeDiskOfferingVO = 'DiskOfferingVO';
    ApiHeader.PrimaryStorageInventoryQueryable = ['uuid', 'zoneUuid', 'name', 'url', 'description', 'totalCapacity', 'availableCapacity', 'totalPhysicalCapacity', 'availablePhysicalCapacity', 'type', 'state', 'status', 'mountPath', 'createDate', 'lastOpDate', 'attachedClusterUuids'];
    ApiHeader.TagResourceTypePrimaryStorageVO = 'PrimaryStorageVO';
    ApiHeader.PrimaryStorageClusterRefInventoryQueryable = ['id', 'clusterUuid', 'primaryStorageUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypePrimaryStorageClusterRefVO = 'PrimaryStorageClusterRefVO';
    ApiHeader.PrimaryStorageCapacityInventoryQueryable = ['uuid', 'totalCapacity', 'availableCapacity', 'totalPhysicalCapacity', 'availablePhsicalCapacity', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypePrimaryStorageCapacityVO = 'PrimaryStorageCapacityVO';
    ApiHeader.VolumeSnapshotInventoryQueryable = ['uuid', 'name', 'description', 'type', 'volumeUuid', 'treeUuid', 'parentUuid', 'primaryStorageUuid', 'primaryStorageInstallPath', 'volumeType', 'format', 'latest', 'size', 'state', 'status', 'createDate', 'lastOpDate', 'backupStorageRefs.volumeSnapshotUuid', 'backupStorageRefs.backupStorageUuid', 'backupStorageRefs.installPath'];
    ApiHeader.TagResourceTypeVolumeSnapshotVO = 'VolumeSnapshotVO';
    ApiHeader.VolumeSnapshotBackupStorageRefInventoryQueryable = ['volumeSnapshotUuid', 'backupStorageUuid', 'installPath'];
    ApiHeader.TagResourceTypeVolumeSnapshotBackupStorageRefVO = 'VolumeSnapshotBackupStorageRefVO';
    ApiHeader.VolumeSnapshotTreeInventoryQueryable = ['uuid', 'volumeUuid', 'current', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeVolumeSnapshotTreeVO = 'VolumeSnapshotTreeVO';
    ApiHeader.BackupStorageInventoryQueryable = ['uuid', 'name', 'url', 'description', 'totalCapacity', 'availableCapacity', 'type', 'state', 'status', 'createDate', 'lastOpDate', 'attachedZoneUuids'];
    ApiHeader.TagResourceTypeBackupStorageVO = 'BackupStorageVO';
    ApiHeader.BackupStorageZoneRefInventoryQueryable = ['id', 'backupStorageUuid', 'zoneUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeBackupStorageZoneRefVO = 'BackupStorageZoneRefVO';
    ApiHeader.IpRangeInventoryQueryable = ['uuid', 'l3NetworkUuid', 'name', 'description', 'startIp', 'endIp', 'netmask', 'gateway', 'networkCidr', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeIpRangeVO = 'IpRangeVO';
    ApiHeader.L3NetworkInventoryQueryable = ['uuid', 'name', 'description', 'type', 'zoneUuid', 'l2NetworkUuid', 'state', 'dnsDomain', 'system', 'createDate', 'lastOpDate', 'dns', 'ipRanges.uuid', 'ipRanges.l3NetworkUuid', 'ipRanges.name', 'ipRanges.description', 'ipRanges.startIp', 'ipRanges.endIp', 'ipRanges.netmask', 'ipRanges.gateway', 'ipRanges.networkCidr', 'ipRanges.createDate', 'ipRanges.lastOpDate', 'networkServices.l3NetworkUuid', 'networkServices.networkServiceProviderUuid', 'networkServices.networkServiceType'];
    ApiHeader.TagResourceTypeL3NetworkVO = 'L3NetworkVO';
    ApiHeader.IpUseInventoryQueryable = ['uuid', 'usedIpUuid', 'serviceId', 'use', 'details', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeIpUseVO = 'IpUseVO';
    ApiHeader.L3NetworkDnsInventoryQueryable = ['l3NetworkUuid', 'dns', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeL3NetworkDnsVO = 'L3NetworkDnsVO';
    ApiHeader.NetworkServiceL3NetworkRefInventoryQueryable = ['l3NetworkUuid', 'networkServiceProviderUuid', 'networkServiceType'];
    ApiHeader.TagResourceTypeNetworkServiceL3NetworkRefVO = 'NetworkServiceL3NetworkRefVO';
    ApiHeader.NetworkServiceTypeInventoryQueryable = ['networkServiceProviderUuid', 'type'];
    ApiHeader.TagResourceTypeNetworkServiceTypeVO = 'NetworkServiceTypeVO';
    ApiHeader.NetworkServiceProviderInventoryQueryable = ['uuid', 'name', 'description', 'type', 'createDate', 'lastOpDate', 'networkServiceTypes', 'attachedL2NetworkUuids'];
    ApiHeader.TagResourceTypeNetworkServiceProviderVO = 'NetworkServiceProviderVO';
    ApiHeader.NetworkServiceProviderL2NetworkRefInventoryQueryable = ['networkServiceProviderUuid', 'l2NetworkUuid'];
    ApiHeader.TagResourceTypeNetworkServiceProviderL2NetworkRefVO = 'NetworkServiceProviderL2NetworkRefVO';
    ApiHeader.L2VlanNetworkInventoryQueryable = ['vlan', 'uuid', 'name', 'description', 'zoneUuid', 'physicalInterface', 'type', 'createDate', 'lastOpDate', 'attachedClusterUuids'];
    ApiHeader.TagResourceTypeL2VlanNetworkVO = 'L2VlanNetworkVO';
    ApiHeader.L2NetworkClusterRefInventoryQueryable = ['clusterUuid', 'l2NetworkUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeL2NetworkClusterRefVO = 'L2NetworkClusterRefVO';
    ApiHeader.L2NetworkInventoryQueryable = ['uuid', 'name', 'description', 'zoneUuid', 'physicalInterface', 'type', 'createDate', 'lastOpDate', 'attachedClusterUuids'];
    ApiHeader.TagResourceTypeL2NetworkVO = 'L2NetworkVO';
    ApiHeader.UserTagInventoryQueryable = ['uuid', 'resourceUuid', 'resourceType', 'tag', 'type', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeUserTagVO = 'UserTagVO';
    ApiHeader.SystemTagInventoryQueryable = ['inherent', 'uuid', 'resourceUuid', 'resourceType', 'tag', 'type', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeSystemTagVO = 'SystemTagVO';
    ApiHeader.ManagementNodeInventoryQueryable = ['uuid', 'hostName', 'joinDate', 'heartBeat'];
    ApiHeader.TagResourceTypeManagementNodeVO = 'ManagementNodeVO';
    ApiHeader.ClusterInventoryQueryable = ['name', 'uuid', 'description', 'state', 'hypervisorType', 'createDate', 'lastOpDate', 'zoneUuid', 'type'];
    ApiHeader.TagResourceTypeClusterVO = 'ClusterVO';
    ApiHeader.UserInventoryQueryable = ['uuid', 'accountUuid', 'name', 'description', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeUserVO = 'UserVO';
    ApiHeader.UserGroupInventoryQueryable = ['uuid', 'accountUuid', 'name', 'description', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeUserGroupVO = 'UserGroupVO';
    ApiHeader.PolicyInventoryQueryable = ['statements.name', 'statements.effect', 'statements.principals', 'statements.actions', 'statements.resources', 'name', 'uuid', 'accountUuid'];
    ApiHeader.TagResourceTypePolicyVO = 'PolicyVO';
    ApiHeader.AccountResourceRefInventoryQueryable = ['accountUuid', 'ownerAccountUuid', 'resourceUuid', 'resourceType', 'permission', 'isShared', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeAccountResourceRefVO = 'AccountResourceRefVO';
    ApiHeader.UserGroupPolicyRefInventoryQueryable = ['groupUuid', 'policyUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeUserGroupPolicyRefVO = 'UserGroupPolicyRefVO';
    ApiHeader.AccountInventoryQueryable = ['uuid', 'name', 'description', 'type', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeAccountVO = 'AccountVO';
    ApiHeader.QuotaInventoryQueryable = ['name', 'identityUuid', 'identityType', 'value', 'lastOpDate', 'createDate'];
    ApiHeader.TagResourceTypeQuotaVO = 'QuotaVO';
    ApiHeader.UserPolicyRefInventoryQueryable = ['userUuid', 'policyUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeUserPolicyRefVO = 'UserPolicyRefVO';
    ApiHeader.UserGroupUserRefInventoryQueryable = ['userUuid', 'groupUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeUserGroupUserRefVO = 'UserGroupUserRefVO';
    ApiHeader.ZoneInventoryQueryable = ['uuid', 'name', 'description', 'state', 'type', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeZoneVO = 'ZoneVO';
    ApiHeader.HostInventoryQueryable = ['zoneUuid', 'name', 'uuid', 'clusterUuid', 'description', 'managementIp', 'hypervisorType', 'state', 'status', 'totalCpuCapacity', 'availableCpuCapacity', 'totalMemoryCapacity', 'availableMemoryCapacity', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeHostVO = 'HostVO';
    ApiHeader.SimulatorHostInventoryQueryable = ['memoryCapacity', 'cpuCapacity', 'zoneUuid', 'name', 'uuid', 'clusterUuid', 'description', 'managementIp', 'hypervisorType', 'state', 'status', 'totalCpuCapacity', 'availableCpuCapacity', 'totalMemoryCapacity', 'availableMemoryCapacity', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeSimulatorHostVO = 'SimulatorHostVO';
    ApiHeader.ApplianceVmFirewallRuleInventoryQueryable = ['applianceVmUuid', 'protocol', 'startPort', 'endPort', 'allowCidr', 'sourceIp', 'destIp', 'l3NetworkUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeApplianceVmFirewallRuleVO = 'ApplianceVmFirewallRuleVO';
    ApiHeader.ApplianceVmInventoryQueryable = ['applianceVmType', 'managementNetworkUuid', 'defaultRouteL3NetworkUuid', 'status', 'uuid', 'name', 'description', 'zoneUuid', 'clusterUuid', 'imageUuid', 'hostUuid', 'lastHostUuid', 'instanceOfferingUuid', 'rootVolumeUuid', 'platform', 'defaultL3NetworkUuid', 'type', 'hypervisorType', 'memorySize', 'cpuNum', 'cpuSpeed', 'allocatorStrategy', 'createDate', 'lastOpDate', 'state', 'vmNics.uuid', 'vmNics.vmInstanceUuid', 'vmNics.l3NetworkUuid', 'vmNics.ip', 'vmNics.mac', 'vmNics.netmask', 'vmNics.gateway', 'vmNics.metaData', 'vmNics.deviceId', 'vmNics.createDate', 'vmNics.lastOpDate', 'allVolumes.uuid', 'allVolumes.name', 'allVolumes.description', 'allVolumes.primaryStorageUuid', 'allVolumes.vmInstanceUuid', 'allVolumes.diskOfferingUuid', 'allVolumes.rootImageUuid', 'allVolumes.installPath', 'allVolumes.type', 'allVolumes.format', 'allVolumes.size', 'allVolumes.deviceId', 'allVolumes.state', 'allVolumes.status', 'allVolumes.createDate', 'allVolumes.lastOpDate'];
    ApiHeader.TagResourceTypeApplianceVmVO = 'ApplianceVmVO';
    ApiHeader.IscsiFileSystemBackendPrimaryStorageInventoryQueryable = ['chapUsername', 'hostname', 'sshUsername', 'filesystemType', 'uuid', 'zoneUuid', 'name', 'url', 'description', 'totalCapacity', 'availableCapacity', 'totalPhysicalCapacity', 'availablePhysicalCapacity', 'type', 'state', 'status', 'mountPath', 'createDate', 'lastOpDate', 'attachedClusterUuids'];
    ApiHeader.TagResourceTypeIscsiFileSystemBackendPrimaryStorageVO = 'IscsiFileSystemBackendPrimaryStorageVO';
    ApiHeader.CephPrimaryStorageInventoryQueryable = ['mons.hostname', 'mons.monPort', 'mons.createDate', 'mons.lastOpDate', 'mons.primaryStorageUuid', 'fsid', 'rootVolumePoolName', 'dataVolumePoolName', 'imageCachePoolName', 'uuid', 'zoneUuid', 'name', 'url', 'description', 'totalCapacity', 'availableCapacity', 'totalPhysicalCapacity', 'availablePhysicalCapacity', 'type', 'state', 'status', 'mountPath', 'createDate', 'lastOpDate', 'attachedClusterUuids'];
    ApiHeader.TagResourceTypeCephPrimaryStorageVO = 'CephPrimaryStorageVO';
    ApiHeader.CephPrimaryStorageMonInventoryQueryable = ['hostname', 'monPort', 'createDate', 'lastOpDate', 'primaryStorageUuid'];
    ApiHeader.TagResourceTypeCephPrimaryStorageMonVO = 'CephPrimaryStorageMonVO';
    ApiHeader.CephBackupStorageInventoryQueryable = ['mons.hostname', 'mons.monPort', 'mons.createDate', 'mons.lastOpDate', 'mons.backupStorageUuid', 'fsid', 'poolName', 'uuid', 'name', 'url', 'description', 'totalCapacity', 'availableCapacity', 'type', 'state', 'status', 'createDate', 'lastOpDate', 'attachedZoneUuids'];
    ApiHeader.TagResourceTypeCephBackupStorageVO = 'CephBackupStorageVO';
    ApiHeader.CephBackupStorageMonInventoryQueryable = ['hostname', 'monPort', 'createDate', 'lastOpDate', 'backupStorageUuid'];
    ApiHeader.TagResourceTypeCephBackupStorageMonVO = 'CephBackupStorageMonVO';
    ApiHeader.KVMHostInventoryQueryable = ['username', 'zoneUuid', 'name', 'uuid', 'clusterUuid', 'description', 'managementIp', 'hypervisorType', 'state', 'status', 'totalCpuCapacity', 'availableCpuCapacity', 'totalMemoryCapacity', 'availableMemoryCapacity', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeKVMHostVO = 'KVMHostVO';
    ApiHeader.SftpBackupStorageInventoryQueryable = ['hostname', 'uuid', 'name', 'url', 'description', 'totalCapacity', 'availableCapacity', 'type', 'state', 'status', 'createDate', 'lastOpDate', 'attachedZoneUuids'];
    ApiHeader.TagResourceTypeSftpBackupStorageVO = 'SftpBackupStorageVO';
    ApiHeader.VirtualRouterOfferingInventoryQueryable = ['managementNetworkUuid', 'publicNetworkUuid', 'zoneUuid', 'isDefault', 'imageUuid', 'uuid', 'name', 'description', 'cpuNum', 'cpuSpeed', 'memorySize', 'type', 'allocatorStrategy', 'sortKey', 'createDate', 'lastOpDate', 'state'];
    ApiHeader.TagResourceTypeVirtualRouterOfferingVO = 'VirtualRouterOfferingVO';
    ApiHeader.VirtualRouterEipRefInventoryQueryable = ['eipUuid', 'virtualRouterVmUuid'];
    ApiHeader.TagResourceTypeVirtualRouterEipRefVO = 'VirtualRouterEipRefVO';
    ApiHeader.VirtualRouterVmInventoryQueryable = ['publicNetworkUuid', 'applianceVmType', 'managementNetworkUuid', 'defaultRouteL3NetworkUuid', 'status', 'uuid', 'name', 'description', 'zoneUuid', 'clusterUuid', 'imageUuid', 'hostUuid', 'lastHostUuid', 'instanceOfferingUuid', 'rootVolumeUuid', 'platform', 'defaultL3NetworkUuid', 'type', 'hypervisorType', 'memorySize', 'cpuNum', 'cpuSpeed', 'allocatorStrategy', 'createDate', 'lastOpDate', 'state', 'vmNics.uuid', 'vmNics.vmInstanceUuid', 'vmNics.l3NetworkUuid', 'vmNics.ip', 'vmNics.mac', 'vmNics.netmask', 'vmNics.gateway', 'vmNics.metaData', 'vmNics.deviceId', 'vmNics.createDate', 'vmNics.lastOpDate', 'allVolumes.uuid', 'allVolumes.name', 'allVolumes.description', 'allVolumes.primaryStorageUuid', 'allVolumes.vmInstanceUuid', 'allVolumes.diskOfferingUuid', 'allVolumes.rootImageUuid', 'allVolumes.installPath', 'allVolumes.type', 'allVolumes.format', 'allVolumes.size', 'allVolumes.deviceId', 'allVolumes.state', 'allVolumes.status', 'allVolumes.createDate', 'allVolumes.lastOpDate'];
    ApiHeader.TagResourceTypeVirtualRouterVmVO = 'VirtualRouterVmVO';
    ApiHeader.VirtualRouterLoadBalancerRefInventoryQueryable = ['id', 'virtualRouterVmUuid', 'loadBalancerUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeVirtualRouterLoadBalancerRefVO = 'VirtualRouterLoadBalancerRefVO';
    ApiHeader.VirtualRouterVipInventoryQueryable = ['uuid', 'virtualRouterVmUuid'];
    ApiHeader.TagResourceTypeVirtualRouterVipVO = 'VirtualRouterVipVO';
    ApiHeader.VirtualRouterPortForwardingRuleRefInventoryQueryable = ['uuid', 'vipUuid', 'virtualRouterVmUuid'];
    ApiHeader.TagResourceTypeVirtualRouterPortForwardingRuleRefVO = 'VirtualRouterPortForwardingRuleRefVO';
    ApiHeader.PortForwardingRuleInventoryQueryable = ['uuid', 'name', 'description', 'vipIp', 'guestIp', 'vipUuid', 'vipPortStart', 'vipPortEnd', 'privatePortStart', 'privatePortEnd', 'vmNicUuid', 'protocolType', 'state', 'allowedCidr', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypePortForwardingRuleVO = 'PortForwardingRuleVO';
    ApiHeader.EipInventoryQueryable = ['uuid', 'name', 'description', 'vmNicUuid', 'vipUuid', 'createDate', 'lastOpDate', 'state', 'vipIp', 'guestIp'];
    ApiHeader.TagResourceTypeEipVO = 'EipVO';
    ApiHeader.LoadBalancerInventoryQueryable = ['name', 'uuid', 'description', 'state', 'vipUuid', 'listeners.uuid', 'listeners.name', 'listeners.description', 'listeners.loadBalancerUuid', 'listeners.instancePort', 'listeners.loadBalancerPort', 'listeners.protocol', 'listeners.createDate', 'listeners.lastOpDate', 'vmNicRefs.id', 'vmNicRefs.listenerUuid', 'vmNicRefs.vmNicUuid', 'vmNicRefs.status', 'vmNicRefs.createDate', 'vmNicRefs.lastOpDate'];
    ApiHeader.TagResourceTypeLoadBalancerVO = 'LoadBalancerVO';
    ApiHeader.LoadBalancerListenerVmNicRefInventoryQueryable = ['id', 'listenerUuid', 'vmNicUuid', 'status', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeLoadBalancerListenerVmNicRefVO = 'LoadBalancerListenerVmNicRefVO';
    ApiHeader.LoadBalancerListenerInventoryQueryable = ['uuid', 'name', 'description', 'loadBalancerUuid', 'instancePort', 'loadBalancerPort', 'protocol', 'createDate', 'lastOpDate', 'vmNicRefs.id', 'vmNicRefs.listenerUuid', 'vmNicRefs.vmNicUuid', 'vmNicRefs.status', 'vmNicRefs.createDate', 'vmNicRefs.lastOpDate'];
    ApiHeader.TagResourceTypeLoadBalancerListenerVO = 'LoadBalancerListenerVO';
    ApiHeader.VmNicSecurityGroupRefInventoryQueryable = ['vmNicUuid', 'securityGroupUuid', 'vmInstanceUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeVmNicSecurityGroupRefVO = 'VmNicSecurityGroupRefVO';
    ApiHeader.SecurityGroupRuleInventoryQueryable = ['uuid', 'securityGroupUuid', 'type', 'startPort', 'endPort', 'protocol', 'state', 'allowedCidr', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeSecurityGroupRuleVO = 'SecurityGroupRuleVO';
    ApiHeader.SecurityGroupInventoryQueryable = ['uuid', 'name', 'description', 'state', 'createDate', 'lastOpDate', 'rules.uuid', 'rules.securityGroupUuid', 'rules.type', 'rules.startPort', 'rules.endPort', 'rules.protocol', 'rules.state', 'rules.allowedCidr', 'rules.createDate', 'rules.lastOpDate', 'attachedL3NetworkUuids'];
    ApiHeader.TagResourceTypeSecurityGroupVO = 'SecurityGroupVO';
    ApiHeader.SecurityGroupL3NetworkRefInventoryQueryable = ['uuid', 'l3NetworkUuid', 'securityGroupUuid', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeSecurityGroupL3NetworkRefVO = 'SecurityGroupL3NetworkRefVO';
    ApiHeader.VipInventoryQueryable = ['uuid', 'name', 'description', 'l3NetworkUuid', 'ip', 'state', 'gateway', 'netmask', 'serviceProvider', 'peerL3NetworkUuid', 'useFor', 'createDate', 'lastOpDate'];
    ApiHeader.TagResourceTypeVipVO = 'VipVO';
})(ApiHeader || (ApiHeader = {}));
/// <reference path="d.ts/angularjs/angular.d.ts" />
var Utils;
(function (Utils) {
    var Receipt = (function () {
        function Receipt() {
        }
        return Receipt;
    })();
    var Tag = (function () {
        function Tag(api) {
            this.api = api;
        }
        Tag.prototype.createTag = function (tag, resourceUuid, resourceType, done) {
            var msg = new ApiHeader.APICreateUserTagMsg();
            msg.resourceType = resourceType;
            msg.resourceUuid = resourceUuid;
            msg.tag = tag;
            this.api.asyncApi(msg, function (ret) {
                if (Utils.notNullnotUndefined(done)) {
                    done(ret.inventory);
                }
            });
        };
        Tag.prototype.deleteTag = function (uuid, done) {
            if (done === void 0) { done = null; }
            var msg = new ApiHeader.APIDeleteTagMsg();
            msg.uuid = uuid;
            this.api.asyncApi(msg, function (ret) {
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
            });
        };
        Tag.prototype.queryTag = function (resourceUuid, done) {
            var msg = new ApiHeader.APIQueryUserTagMsg();
            msg.conditions = [{ name: 'resourceUuid', op: '=', value: resourceUuid }];
            this.api.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        return Tag;
    })();
    Utils.Tag = Tag;
    var Api = (function () {
        function Api($http, $rootScope, $location) {
            //this.debugLogIn();
            var _this = this;
            this.$http = $http;
            this.$rootScope = $rootScope;
            this.$location = $location;
            this.$inject = ['$http', '$rootScope', '$location'];
            this.beforeCallListeners = [];
            this.afterCallListeners = [];
            this.errorCallListeners = [];
            $rootScope.$watch(function () {
                return $rootScope.user;
            }, function () {
                if (Utils.notNullnotUndefined($rootScope.user)) {
                    _this.session = {
                        uuid: $rootScope.user.sessionUuid
                    };
                }
            });
        }
        Api.prototype.debugLogIn = function (done) {
            var _this = this;
            if (done === void 0) { done = null; }
            var msg = new ApiHeader.APILogInByAccountMsg();
            msg.accountName = 'admin';
            msg.password = 'b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cacbc86';
            this.syncCall(msg, function (ret) {
                _this.session = new ApiHeader.SessionInventory();
                _this.session.uuid = ret.inventory.uuid;
                console.log(JSON.stringify(_this.session));
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
            });
        };
        Api.prototype.getHypervisorTypes = function (done) {
            var msg = new ApiHeader.APIGetHypervisorTypesMsg();
            this.syncApi(msg, function (ret) {
                done(ret.hypervisorTypes);
            });
        };
        Api.prototype.getVolumeFormats = function (done) {
            var msg = new ApiHeader.APIGetVolumeFormatMsg();
            this.syncApi(msg, function (ret) {
                done(ret.formats);
            });
        };
        Api.prototype.getPrimaryStorageTypes = function (done) {
            var msg = new ApiHeader.APIGetPrimaryStorageTypesMsg();
            this.syncApi(msg, function (ret) {
                done(ret.primaryStorageTypes);
            });
        };
        Api.prototype.getL2NetworkTypes = function (done) {
            var msg = new ApiHeader.APIGetL2NetworkTypesMsg();
            this.syncApi(msg, function (ret) {
                done(ret.l2NetworkTypes);
            });
        };
        Api.prototype.getL3NetworkTypes = function (done) {
            var msg = new ApiHeader.APIGetL3NetworkTypesMsg();
            this.syncApi(msg, function (ret) {
                done(ret.l3NetworkTypes);
            });
        };
        Api.prototype.getBackupStorageTypes = function (done) {
            var msg = new ApiHeader.APIGetBackupStorageTypesMsg();
            this.syncApi(msg, function (ret) {
                done(ret.backupStorageTypes);
            });
        };
        Api.prototype.getInstanceOfferingAllocatorStrategies = function (done) {
            var msg = new ApiHeader.APIGetHostAllocatorStrategiesMsg();
            this.syncApi(msg, function (ret) {
                done(ret.hostAllocatorStrategies);
            });
        };
        Api.prototype.getDiskOfferingAllocatorStrategies = function (done) {
            var msg = new ApiHeader.APIGetPrimaryStorageAllocatorStrategiesMsg();
            this.syncApi(msg, function (ret) {
                done(ret.primaryStorageAllocatorStrategies);
            });
        };
        Api.prototype.getVmMigrationCandidateHosts = function (vmUuid, done) {
            var msg = new ApiHeader.APIGetVmMigrationCandidateHostsMsg();
            msg.vmInstanceUuid = vmUuid;
            this.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        Api.prototype.getDataVolumeAttachableVm = function (volUuid, done) {
            var msg = new ApiHeader.APIGetDataVolumeAttachableVmMsg();
            msg.volumeUuid = volUuid;
            this.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        Api.prototype.getVmAttachableL3Networks = function (vmUuid, done) {
            var msg = new ApiHeader.APIGetVmAttachableL3NetworkMsg();
            msg.vmInstanceUuid = vmUuid;
            this.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        Api.prototype.getVmAttachableVolume = function (vmUuid, done) {
            var msg = new ApiHeader.APIGetVmAttachableDataVolumeMsg();
            msg.vmInstanceUuid = vmUuid;
            this.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        Api.prototype.getMemoryCpuCapacity = function (zoneUuids, clusterUuids, hostUuids, done) {
            var msg = new ApiHeader.APIGetCpuMemoryCapacityMsg();
            msg.zoneUuids = zoneUuids;
            msg.clusterUuids = clusterUuids;
            msg.hostUuids = hostUuids;
            this.syncApi(msg, function (ret) {
                done(ret);
            });
        };
        Api.prototype.getMemoryCpuCapacityByAll = function (done) {
            var msg = new ApiHeader.APIGetCpuMemoryCapacityMsg();
            msg.all = true;
            this.syncApi(msg, function (ret) {
                done(ret);
            });
        };
        Api.prototype.getPirmaryStorageCapacityByAll = function (done) {
            var msg = new ApiHeader.APIGetPrimaryStorageCapacityMsg();
            msg.all = true;
            this.syncApi(msg, function (ret) {
                done(ret);
            });
        };
        Api.prototype.getBackupStorageCapacityByAll = function (done) {
            var msg = new ApiHeader.APIGetBackupStorageCapacityMsg();
            msg.all = true;
            this.syncApi(msg, function (ret) {
                done(ret);
            });
        };
        Api.prototype.getIpAddressCapacityByAll = function (done) {
            var msg = new ApiHeader.APIGetIpAddressCapacityMsg();
            msg.all = true;
            this.syncApi(msg, function (ret) {
                done(ret);
            });
        };
        Api.prototype.getSystemTags = function (resourceType, resourceUuid, done) {
            var msg = new ApiHeader.APIQuerySystemTagMsg();
            msg.conditions = [{
                    name: 'resourceType',
                    op: '=',
                    value: resourceType
                }, {
                    name: 'resourceUuid',
                    op: '=',
                    value: resourceUuid
                }];
            this.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        Api.prototype.fireAfterListener = function (recepit) {
            angular.forEach(this.afterCallListeners, function (item) {
                item(recepit.request, recepit.rsp);
            });
        };
        Api.prototype.poll = function (receipt, callback, error) {
            var _this = this;
            if (receipt.status == Api.STATUS_DONE) {
                console.log(JSON.stringify(receipt.rsp));
                this.fireAfterListener(receipt);
                var rsp = Utils.firstItem(receipt.rsp);
                if (rsp.success) {
                    callback(rsp);
                }
                else {
                    if (Utils.notNullnotUndefined(error)) {
                        error(rsp);
                    }
                }
                return;
            }
            this.$http.post(Api.QUERY_PATH, receipt.id)
                .success(function (re) {
                re.request = receipt.request;
                if (re.status == Api.STATUS_DONE) {
                    console.log(JSON.stringify(re.rsp));
                    _this.fireAfterListener(re);
                    var rsp = Utils.firstItem(re.rsp);
                    if (rsp.success) {
                        callback(rsp);
                    }
                    else {
                        if (Utils.notNullnotUndefined(error)) {
                            error(rsp);
                        }
                    }
                    return;
                }
                //TODO: configurable
                setTimeout(function () {
                    Utils.safeApply(_this.$rootScope, function () {
                        _this.poll(re, callback, error);
                    });
                }, 1000);
            }).error(function (reason, status) {
                if (error) {
                    error(reason, status);
                }
                _this.fireErrorListener({
                    request: receipt.request,
                    data: reason,
                    status: status
                });
            });
        };
        Api.prototype.fireErrorListener = function (reason) {
            angular.forEach(this.errorCallListeners, function (item) {
                item(reason);
            });
        };
        Api.prototype.asyncCall = function (msg, callback, error) {
            var _this = this;
            msg.session = this.session;
            angular.forEach(this.beforeCallListeners, function (item) {
                item(msg);
            });
            this.$http.post(Api.ASYNC_CALL_PATH, msg.toApiMap())
                .success(function (receipt) {
                receipt.request = msg;
                _this.poll(receipt, callback, error);
            }).error(function (reason, status) {
                if (error) {
                    error(reason, status);
                }
                _this.fireErrorListener({
                    request: msg,
                    data: reason,
                    status: status
                });
            });
        };
        Api.prototype.syncCall = function (msg, callback, error) {
            var _this = this;
            msg.session = this.session;
            console.log(JSON.stringify(msg));
            this.$http.post(Api.SYNC_CALL_PATH, msg.toApiMap()).success(function (rsp) {
                var ret = Utils.firstItem(rsp);
                if (!ret.success && notNullnotUndefined(ret.error) && ret.error.code == 'ID.1001') {
                    console.log('authentication error');
                    _this.$location.path('/login');
                    return;
                }
                callback(Utils.firstItem(rsp));
            }).error(function (reason, status) {
                if (error) {
                    error(reason, status);
                }
                _this.fireErrorListener({
                    request: msg,
                    data: reason,
                    status: status
                });
            });
        };
        Api.prototype.syncApi = function (data, callback, error) {
            if (error === void 0) { error = undefined; }
            /*
            if (Utils.notNullnotUndefined(this.session)) {
                this.syncCall(data, callback, error);
            } else {
                this.debugLogIn(()=> {
                    this.syncCall(data, callback, error);
                });
            }
            */
            if (Utils.notNullnotUndefined(this.$rootScope.sessionUuid)) {
                this.session = {
                    uuid: this.$rootScope.sessionUuid
                };
            }
            this.syncCall(data, callback, error);
        };
        Api.prototype.asyncApi = function (data, callback, error) {
            if (error === void 0) { error = undefined; }
            /*
            if (Utils.notNullnotUndefined(this.session)) {
                this.asyncCall(data, callback, error);
            } else {
                this.debugLogIn(()=> {
                    this.asyncCall(data, callback, error);
                });
            }
            */
            if (Utils.notNullnotUndefined(this.$rootScope.sessionUuid)) {
                this.session = {
                    uuid: this.$rootScope.sessionUuid
                };
            }
            this.asyncCall(data, callback, error);
        };
        Api.prototype.installListener = function (before, after, error) {
            if (before === void 0) { before = null; }
            if (after === void 0) { after = null; }
            if (error === void 0) { error = null; }
            if (notNullnotUndefined(before)) {
                this.beforeCallListeners.push(before);
            }
            if (notNullnotUndefined(after)) {
                this.afterCallListeners.push(after);
            }
            if (notNullnotUndefined(error)) {
                this.errorCallListeners.push(error);
            }
        };
        Api.ASYNC_CALL_PATH = "/api/async";
        Api.SYNC_CALL_PATH = "/api/sync";
        Api.QUERY_PATH = "/api/query";
        Api.STATUS_DONE = 2;
        Api.STATUS_PROCESSING = 1;
        return Api;
    })();
    Utils.Api = Api;
    var Chain = (function () {
        function Chain() {
            this.flows = [];
        }
        Chain.prototype.done = function (handler) {
            this.doneHandler = handler;
            return this;
        };
        Chain.prototype.error = function (handler) {
            this.errorHandler = handler;
            return this;
        };
        Chain.prototype.then = function (flow) {
            this.flows.push(flow);
            return this;
        };
        Chain.prototype.next = function () {
            var func = this.flows.shift();
            if (func) {
                func(this);
            }
            else {
                if (Utils.notNullnotUndefined(this.doneHandler)) {
                    this.doneHandler();
                }
            }
        };
        Chain.prototype.fail = function (reason) {
            if (this.errorHandler) {
                this.errorHandler(reason);
            }
        };
        Chain.prototype.start = function () {
            this.next();
        };
        return Chain;
    })();
    Utils.Chain = Chain;
    function periodicalRun(func, interval) {
        var cb = function () {
            if (func()) {
                return;
            }
            setTimeout(cb, interval);
        };
        cb();
    }
    Utils.periodicalRun = periodicalRun;
    function notNullnotUndefined(arg) {
        return angular.isDefined(arg) && arg != null;
    }
    Utils.notNullnotUndefined = notNullnotUndefined;
    function notNullnotUndefinedNotEmptyString(arg) {
        return notNullnotUndefined(arg) && arg != "";
    }
    Utils.notNullnotUndefinedNotEmptyString = notNullnotUndefinedNotEmptyString;
    function firstItem(obj) {
        return obj[Object.keys(obj)[0]];
    }
    Utils.firstItem = firstItem;
    function isEmptyObject(obj) {
        if (!notNullnotUndefined(obj)) {
            return true;
        }
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    }
    Utils.isEmptyObject = isEmptyObject;
    function arrayRemoveIndex(arr, index) {
        if (index != -1) {
            arr.splice(index, 1);
        }
    }
    Utils.arrayRemoveIndex = arrayRemoveIndex;
    function safeApply(scope, func) {
        if (!scope.$$phase) {
            scope.$apply(function () {
                func();
            });
        }
        else {
            func();
        }
    }
    Utils.safeApply = safeApply;
    function addCommas(str) {
        return (str + "").replace(/\b(\d+)((\.\d+)*)\b/g, function (a, b, c) {
            return (b.charAt(0) > 0 && !(c || ".").lastIndexOf(".") ? b.replace(/(\d)(?=(\d{3})+$)/g, "$1,") : b) + c;
        });
    }
    Utils.addCommas = addCommas;
    function isValidSizeStr(str) {
        if (angular.isNumber(str)) {
            return true;
        }
        var cpattern = /^[PpTtGgMmKk]$/;
        var npattern = /^[0-9]$/;
        var last = str.slice(-1);
        if (cpattern.test(last)) {
            var size = str.substring(0, str.length - 1);
            return !isNaN(size);
        }
        else if (npattern.test(last)) {
            return !isNaN(str);
        }
        else {
            return false;
        }
    }
    Utils.isValidSizeStr = isValidSizeStr;
    function stringContains(str, tofind) {
        return str.indexOf(tofind) > -1;
    }
    Utils.stringContains = stringContains;
    function isIpv4Address(ip) {
        var pattern = /\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/;
        return pattern.test(ip);
    }
    Utils.isIpv4Address = isIpv4Address;
    function isCharacter(c) {
        var pattern = /^[a-z]$/;
        return pattern.test(c);
    }
    Utils.isCharacter = isCharacter;
    function isValidPort(port) {
        if (isNaN(port)) {
            return false;
        }
        var sport = parseInt(port);
        return sport >= 0 && sport <= 65535;
    }
    Utils.isValidPort = isValidPort;
    function isValidCidr(cidr) {
        var pairs = cidr.split("/");
        if (pairs.length != 2) {
            return false;
        }
        var ip = pairs[0];
        if (!Utils.isIpv4Address(ip)) {
            return false;
        }
        var cidrStr = pairs[1];
        if (isNaN(cidrStr)) {
            return false;
        }
        cidr = parseInt(cidrStr);
        return cidr >= 0 && cidr <= 32;
    }
    Utils.isValidCidr = isValidCidr;
    function shortHashName(prefix) {
        return prefix + '-' + ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).substr(-4);
    }
    Utils.shortHashName = shortHashName;
    function uuid() {
        var dec2hex = [];
        for (var i = 0; i <= 15; i++) {
            dec2hex[i] = i.toString(16);
        }
        return function () {
            var uuid = '';
            for (var i = 1; i <= 36; i++) {
                if (i === 9 || i === 14 || i === 19 || i === 24) {
                    continue;
                }
                else if (i === 15) {
                    uuid += 4;
                }
                else if (i === 20) {
                    uuid += dec2hex[(Math.random() * 4 | 0 + 8)];
                }
                else {
                    uuid += dec2hex[(Math.random() * 15 | 0)];
                }
            }
            return uuid;
        }();
    }
    Utils.uuid = uuid;
    function sprintf(fmt) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return fmt.replace(/{(\d+)}/g, function (match, index) {
            return typeof args[index] != 'undefined'
                ? args[index]
                : "";
        });
    }
    Utils.sprintf = sprintf;
    var K = 1024;
    var M = K * K;
    var G = M * K;
    var T = G * K;
    var P = T * K;
    var sizeMap = {
        'K': K,
        'M': M,
        'G': G,
        'T': T,
        'P': P
    };
    function parseSize(sizeStr) {
        var quantity = sizeStr.substr(sizeStr.length - 1, 1);
        var size = parseInt(sizeStr);
        if (quantity == 'K' || quantity == 'k') {
            return size * K;
        }
        else if (quantity == 'M' || quantity == 'm') {
            return size * M;
        }
        else if (quantity == 'G' || quantity == 'g') {
            return size * G;
        }
        else if (quantity == 'T' || quantity == 't') {
            return size * T;
        }
        else if (quantity == 'P' || quantity == 'p') {
            return size * P;
        }
        else {
            return parseInt(sizeStr);
        }
    }
    Utils.parseSize = parseSize;
    function sizeRoundToString(size) {
        var suffixes = ['P', 'T', 'G', 'M', 'K'];
        function round() {
            var s = suffixes.shift();
            if (!notNullnotUndefined(size)) {
                return sprintf('{0} Bytes', size);
            }
            var q = sizeMap[s];
            var ret = size / q;
            if (ret >= 1) {
                return sprintf('{0} {1}', ret.toFixed(2), s);
            }
            else {
                return round();
            }
        }
        return round();
    }
    Utils.sizeRoundToString = sizeRoundToString;
    function toFixed(num, precision) {
        var multiplier = Math.pow(10, precision + 1), wholeNumber = Math.floor(num * multiplier);
        return Math.round(wholeNumber / 10) * 10 / multiplier;
    }
    Utils.toFixed = toFixed;
    function toSizeString(input) {
        try {
            return Utils.sizeRoundToString(parseInt(input));
        }
        catch (e) {
            return input;
        }
    }
    Utils.toSizeString = toSizeString;
    function toHZString(input) {
        return input + ' HZ';
    }
    Utils.toHZString = toHZString;
    function toPercentageString(input) {
        var per = parseFloat(input) * 100;
        var perStr = per.toString();
        if (perStr.length > 5) {
            perStr = perStr.slice(0, 5);
        }
        return Utils.sprintf('{0}%', perStr);
    }
    Utils.toPercentageString = toPercentageString;
    function commaString(input) {
        return Utils.addCommas(input.toString());
    }
    Utils.commaString = commaString;
    var Translator = (function () {
        function Translator($filter) {
            this.$filter = $filter;
        }
        Translator.prototype.addProperty = function (object, key, resourceId) {
            var _this = this;
            Object.defineProperty(object, key, {
                get: function () { return _this.$filter('translate')(resourceId); }
            });
        };
        return Translator;
    })();
    Utils.Translator = Translator;
    var Model = (function () {
        function Model() {
            this.multiSelection = false;
        }
        Model.prototype.resetCurrent = function () {
            this.current = null;
        };
        return Model;
    })();
    Utils.Model = Model;
    var OGrid = (function () {
        function OGrid() {
        }
        OGrid.prototype.setFilter = function (filter) {
            this.grid.dataSource.filter(filter);
        };
        OGrid.prototype.select = function (item) {
            var _this = this;
            var selected = null;
            if (Utils.notNullnotUndefined(item)) {
                selected = item;
            }
            else {
                selected = this.grid.dataSource.data()[0];
            }
            if (selected) {
                if (this.$scope.model.mutliSelection) {
                    selected.forEach(function (m) {
                        var row = _this.grid.table.find('tr[data-uid="' + m.uid + '"]');
                        _this.grid.select(row);
                    });
                }
                else {
                    var row = this.grid.table.find('tr[data-uid="' + selected.uid + '"]');
                    this.grid.select(row);
                }
            }
        };
        OGrid.prototype.refresh = function (data) {
            if (data === void 0) { data = null; }
            if (Utils.notNullnotUndefined(data)) {
                this.grid.dataSource.data(data);
            }
            else {
                this.grid.dataSource.read();
                this.$scope.model.resetCurrent();
            }
        };
        OGrid.prototype.add = function (ps) {
            this.grid.dataSource.insert(0, ps);
        };
        OGrid.prototype.deleteCurrent = function () {
            var _this = this;
            if (this.$scope.model.multiSelection) {
                this.$scope.model.current.forEach(function (m) {
                    var row = _this.grid.dataSource.getByUid(m.uid);
                    _this.grid.dataSource.remove(row);
                });
            }
            else {
                var row = this.grid.dataSource.getByUid(this.$scope.model.current.uid);
                this.grid.dataSource.remove(row);
            }
            this.$scope.model.resetCurrent();
        };
        OGrid.prototype.init = function ($scope, grid) {
            var _this = this;
            this.$scope = $scope;
            this.grid = grid;
            var model = this.$scope.model;
            this.options = {
                resizable: true,
                scrollable: true,
                selectable: true,
                pageable: true,
                dataBound: function (e) {
                    _this.grid = e.sender;
                    if (_this.grid.dataSource.totalPages() <= 1) {
                        _this.grid.pager.element.hide();
                    }
                    if (Utils.notNullnotUndefined(model.current)) {
                        _this.select(model.current);
                    }
                },
                change: function (e) {
                    var selected = _this.grid.select();
                    if (model.multiSelection) {
                        Utils.safeApply($scope, function () {
                            if (!model.current)
                                model.current = [];
                            var idx = model.current.indexOf(_this.grid.dataItem(selected));
                            if (idx < 0)
                                model.current.push(_this.grid.dataItem(selected));
                            else
                                model.current.splice(idx, 1);
                        });
                    }
                    else {
                        Utils.safeApply($scope, function () {
                            model.current = _this.grid.dataItem(selected);
                        });
                    }
                },
                dataSource: new kendo.data.DataSource({
                    serverPaging: true,
                    pageSize: 20,
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {}
                })
            };
        };
        return OGrid;
    })();
    Utils.OGrid = OGrid;
    var WizardButton = (function () {
        function WizardButton(pages, mediator) {
            this.pages = pages;
            this.mediator = mediator;
            this.currentIndex = 0;
        }
        WizardButton.prototype.reset = function () {
            this.currentIndex = 0;
            var fpage = this.pages[0];
            angular.forEach(this.pages, function (page) {
                page.reset();
                if (page != fpage) {
                    var el = page.getAnchorElement();
                    el.removeAttr('data-toggle');
                }
            });
            this.showPage(fpage);
        };
        WizardButton.prototype.canPreviousProceed = function () {
            if (this.currentIndex == 0) {
                return false;
            }
            else {
                var page = this.pages[this.currentIndex];
                return page.canMoveToPrevious();
            }
        };
        WizardButton.prototype.canNextProceed = function () {
            var page = this.pages[this.currentIndex];
            return page.canMoveToNext();
        };
        WizardButton.prototype.isLastPage = function () {
            return this.currentIndex == this.pages.length - 1;
        };
        WizardButton.prototype.showPage = function (page) {
            page.active();
            page.show();
            var el = page.getAnchorElement();
            if (!Utils.notNullnotUndefined(el.attr('data-toggle'))) {
                el.attr('data-toggle', 'tab');
            }
        };
        WizardButton.prototype.previousClick = function () {
            this.currentIndex--;
            var page = this.pages[this.currentIndex];
            this.mediator.movedToPage(page);
            this.showPage(page);
        };
        WizardButton.prototype.nextClick = function () {
            var _this = this;
            if (this.isLastPage()) {
                this.mediator.finish();
                return;
            }
            this.currentIndex++;
            var page = this.pages[this.currentIndex];
            if (Utils.notNullnotUndefined(page.beforeMoveToNext)) {
                page.beforeMoveToNext(function () {
                    _this.mediator.movedToPage(page);
                    _this.showPage(page);
                });
            }
            else {
                this.mediator.movedToPage(page);
                this.showPage(page);
            }
        };
        WizardButton.prototype.nextButtonName = function () {
            if (this.isLastPage()) {
                return this.mediator.finishButtonName();
            }
            else {
                return 'Next';
            }
        };
        WizardButton.prototype.pageClick = function (pageName) {
            for (var i = 0; i < this.pages.length; i++) {
                var page = this.pages[i];
                if (pageName == page.getPageName() && page.isActive()) {
                    page.show();
                    this.currentIndex = i;
                }
            }
        };
        return WizardButton;
    })();
    Utils.WizardButton = WizardButton;
})(Utils || (Utils = {}));
angular.module("app.service", []).factory('Api', ['$http', '$rootScope', '$location', function ($http, $rootScope, $location) {
        return new Utils.Api($http, $rootScope, $location);
    }]).factory('Tag', ['Api', function (api) {
        return new Utils.Tag(api);
    }]).factory('Translator', ['$filter', function ($filter) {
        return new Utils.Translator($filter);
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
/// <reference path="d.ts/zstack.d.ts" />
var MRoot;
(function (MRoot) {
    var Events = (function () {
        function Events() {
        }
        Events.NOTIFICATION = "root.notification";
        return Events;
    })();
    MRoot.Events = Events;
    var main = (function () {
        function main($scope, $rootScope, api, apiDetails, $location, $cookies, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$rootScope = $rootScope;
            this.api = api;
            this.apiDetails = apiDetails;
            this.$location = $location;
            this.$cookies = $cookies;
            this.$translate = $translate;
            if (Utils.notNullnotUndefined($cookies.sessionUuid)) {
                var msg = new ApiHeader.APIValidateSessionMsg();
                msg.sessionUuid = $cookies.sessionUuid;
                this.api.syncApi(msg, function (ret) {
                    if (ret.success && ret.validSession) {
                        $rootScope.sessionUuid = $cookies.sessionUuid;
                        $rootScope.loginFlag = true;
                        $location.path("/dashboard");
                    }
                    else {
                        $rootScope.loginFlag = false;
                    }
                });
            }
            $rootScope.instanceConsoles = {};
            $scope.optionsNotification = {
                position: {
                    pinned: true,
                    top: null,
                    left: 20,
                    bottom: 20,
                    right: null
                },
                width: 300,
                templates: [
                    {
                        type: 'success',
                        template: $('#successNotification').html()
                    },
                    {
                        type: 'error',
                        template: $('#errorNotification').html()
                    }
                ]
            };
            $scope.$on(Events.NOTIFICATION, function (e, msg) {
                var type = msg.type;
                if (!Utils.notNullnotUndefined(type)) {
                    type = "success";
                }
                $scope.apiNotification.show(msg, type);
            });
            $rootScope.loginFlag = false;
            $scope.isLogin = function () {
                return $rootScope.loginFlag;
            };
            $scope.$watch(function () {
                return $rootScope.loginFlag;
            }, function () {
                if (!$rootScope.loginFlag) {
                    $location.path("/login");
                }
            });
            $scope.canLogin = function () {
                return Utils.notNullnotUndefined($scope.username) && Utils.notNullnotUndefined($scope.password);
            };
            $scope.getAccountName = function () {
                return $cookies.accountName;
            };
            $scope.logout = function () {
                var msg = new ApiHeader.APILogOutMsg();
                msg.sessionUuid = $cookies.sessionUuid;
                _this.api.syncApi(msg, function (ret) {
                    $rootScope.loginFlag = false;
                    $rootScope.sessionUuid = null;
                    $cookies.sessionUuid = null;
                    $scope.username = null;
                    $scope.password = null;
                    $location.path("/login");
                    $scope.logInError = false;
                });
            };
            $scope.logInError = false;
            $scope.login = function () {
                var msg = new ApiHeader.APILogInByAccountMsg();
                msg.accountName = $scope.username;
                msg.password = CryptoJS.SHA512($scope.password).toString();
                _this.api.syncApi(msg, function (ret) {
                    if (ret.success) {
                        $rootScope.loginFlag = true;
                        $rootScope.sessionUuid = ret.inventory.uuid;
                        $cookies.sessionUuid = ret.inventory.uuid;
                        $cookies.accountName = $scope.username;
                        $scope.username = null;
                        $scope.password = null;
                        $location.path("/dashboard");
                        $scope.logInError = false;
                    }
                    else {
                        $scope.logInError = true;
                    }
                });
            };
            $scope.changeLanguage = function (language) {
                switch (language) {
                    case 'Chinese':
                        $translate.use('zh_CN');
                        break;
                    case 'English':
                        $translate.use('en_US');
                        break;
                }
            };
        }
        main.$inject = ['$scope', '$rootScope', 'Api', 'ApiDetails', '$location', '$cookies', '$translate'];
        return main;
    })();
    MRoot.main = main;
})(MRoot || (MRoot = {}));
var ApiHeader;
(function (ApiHeader) {
    var QueryObject = (function () {
        function QueryObject() {
            this.start = null;
            this.limit = null;
            this.count = false;
            this.conditions = null;
        }
        QueryObject.prototype.addCondition = function (cond) {
            if (!Utils.notNullnotUndefined(this.conditions)) {
                this.conditions = [];
            }
            this.conditions.push(cond);
        };
        return QueryObject;
    })();
    ApiHeader.QueryObject = QueryObject;
})(ApiHeader || (ApiHeader = {}));
angular.module("root", ['app.service', 'kendo.directives', 'ngRoute', 'ngTagsInput', 'ngCookies', 'pascalprecht.translate'])
    .config(['$routeProvider', function (route) {
        route.when('/login', {
            templateUrl: '/static/templates/login/login.html',
            controller: 'MRoot.main'
        }).otherwise({
            redirectTo: '/dashboard'
        });
    }])
    .constant('LOCALES', {
    'locales': {
        'zh_CN': '中文',
        'en_US': 'English'
    },
    'preferredLocale': 'en_US'
})
    .config(function ($translateProvider) {
    $translateProvider.useStaticFilesLoader({
        prefix: '/static/resources/locale-',
        suffix: '.json' // suffix, currently- extension of the translations  
    });
    $translateProvider.preferredLanguage('en_US'); // is applied on first load  
});
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var Controller;
(function (Controller) {
    var SideBar = (function () {
        function SideBar($scope) {
            $scope.dataSource = new kendo.data.HierarchicalDataSource({
                data: [
                    {
                        text: "Compute",
                        url: "#",
                        items: [
                            {
                                text: "Instance",
                                url: "#"
                            },
                            {
                                text: "Host",
                                url: "#"
                            },
                            {
                                text: "Cluster",
                                url: "/#/cluster"
                            },
                            {
                                text: "Zone",
                                url: "/#/zone"
                            },
                        ]
                    },
                    {
                        text: "Storage",
                        url: "#"
                    },
                    {
                        text: "Network",
                        url: "#",
                        items: [
                            {
                                text: "L2 Network",
                                url: "#"
                            },
                            {
                                text: "L3 Network",
                                url: "#"
                            },
                            {
                                text: "Network Service",
                                url: "#",
                                items: [
                                    {
                                        text: "Security Group",
                                        url: "#"
                                    },
                                    {
                                        text: "EIP",
                                        url: "#"
                                    },
                                    {
                                        text: "Port Forwarding",
                                        url: "#"
                                    },
                                    {
                                        text: "VIP",
                                        url: "#"
                                    },
                                ]
                            },
                        ]
                    },
                    {
                        text: "Configuration",
                        url: "#"
                    }
                ]
            });
            /*
            $scope.barOptions = {
                dataSource : new kendo.data.HierarchicalDataSource({
                    data:[
                        {
                            text: "Compute",
                            items: [
                                {text: "Instance"},
                                {text: "Host"},
                                {text: "Cluster"},
                                {text: "Zone"},
                            ]
                        },
                        {
                            text: "Storage"
                        },
                        {
                            text: "Network"
                        },
                        {
                            text: "Configuration"
                        }
                    ]
                })
            };
            */
        }
        return SideBar;
    })();
    Controller.SideBar = SideBar;
})(Controller || (Controller = {}));
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MNav;
(function (MNav) {
    var Controller = (function () {
        function Controller($scope, api) {
            var _this = this;
            this.$scope = $scope;
            this.api = api;
            this.pendingRequestNum = 0;
            api.installListener(function (msg) {
                _this.pendingRequestNum++;
            }, function (msg, ret) {
                _this.decrease();
            }, function (msg, reason) {
                _this.decrease();
            });
            $scope.funcIsProcessing = function () {
                return _this.pendingRequestNum > 0;
            };
            $scope.funcPendingRequestNum = function () {
                return _this.pendingRequestNum;
            };
        }
        Controller.prototype.decrease = function () {
            this.pendingRequestNum--;
            if (this.pendingRequestNum <= 0) {
                this.pendingRequestNum = 0;
            }
        };
        Controller.$inject = ['$scope', 'Api'];
        return Controller;
    })();
    MNav.Controller = Controller;
})(MNav || (MNav = {}));
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var MZone;
(function (MZone) {
    var Zone = (function (_super) {
        __extends(Zone, _super);
        function Zone() {
            _super.apply(this, arguments);
        }
        Zone.prototype.progressOn = function () {
            this.inProgress = true;
        };
        Zone.prototype.progressOff = function () {
            this.inProgress = false;
        };
        Zone.prototype.isInProgress = function () {
            return this.inProgress;
        };
        Zone.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        Zone.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        Zone.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        Zone.prototype.gridColumnLabel = function () {
            if (this.state == 'Enabled') {
                return 'z-color-box-green';
            }
            else if (this.state == 'Disabled') {
                return 'z-color-box-red';
            }
        };
        Zone.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return Zone;
    })(ApiHeader.ZoneInventory);
    MZone.Zone = Zone;
    var ZoneManager = (function () {
        function ZoneManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        ZoneManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        ZoneManager.prototype.query = function (qobj, callback) {
            var msg = new ApiHeader.APIQueryZoneMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var zones = [];
                ret.inventories.forEach(function (inv) {
                    var z = new Zone();
                    angular.extend(z, inv);
                    zones.push(new kendo.data.ObservableObject(z));
                });
                callback(zones, ret.total);
            });
        };
        ZoneManager.prototype.create = function (zone, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateZoneMsg();
            msg.name = zone.name;
            msg.description = zone.description;
            this.api.asyncApi(msg, function (ret) {
                var z = new Zone();
                angular.extend(z, ret.inventory);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new zone: {0}', z.name),
                    link: Utils.sprintf('/#/zone/{0}', z.uuid)
                });
                done(new kendo.data.ObservableObject(z));
            });
        };
        ZoneManager.prototype.disable = function (zone) {
            var _this = this;
            zone.progressOn();
            var msg = new ApiHeader.APIChangeZoneStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = zone.uuid;
            this.api.asyncApi(msg, function (ret) {
                zone.updateObservableObject(ret.inventory);
                zone.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled zone: {0}', zone.name),
                    link: Utils.sprintf('/#/zone/{0}', zone.uuid)
                });
            });
        };
        ZoneManager.prototype.enable = function (zone) {
            var _this = this;
            zone.progressOn();
            var msg = new ApiHeader.APIChangeZoneStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = zone.uuid;
            this.api.asyncApi(msg, function (ret) {
                zone.updateObservableObject(ret.inventory);
                zone.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled zone: {0}', zone.name),
                    link: Utils.sprintf('/#/zone/{0}', zone.uuid)
                });
            });
        };
        ZoneManager.prototype.delete = function (zone, done) {
            var _this = this;
            zone.progressOn();
            var msg = new ApiHeader.APIDeleteZoneMsg();
            msg.uuid = zone.uuid;
            this.api.asyncApi(msg, function (ret) {
                zone.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted zone: {0}', zone.name)
                });
                done(ret);
            });
        };
        ZoneManager.$inject = ['Api'];
        return ZoneManager;
    })();
    MZone.ZoneManager = ZoneManager;
    var ZoneModel = (function () {
        function ZoneModel() {
            this.current = new Zone();
        }
        ZoneModel.prototype.resetCurrent = function () {
            this.current = null;
        };
        ZoneModel.prototype.setCurrent = function ($scope, zone) {
            this.current = zone;
        };
        return ZoneModel;
    })();
    MZone.ZoneModel = ZoneModel;
    var CreateZoneModel = (function () {
        function CreateZoneModel() {
            this.name = Utils.shortHashName('zone');
        }
        CreateZoneModel.prototype.canCreate = function () {
            return angular.isDefined(this.name);
        };
        return CreateZoneModel;
    })();
    MZone.CreateZoneModel = CreateZoneModel;
    var Action = (function () {
        function Action($scope, zoneMgr) {
            this.$scope = $scope;
            this.zoneMgr = zoneMgr;
        }
        Action.prototype.enable = function () {
            this.zoneMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.zoneMgr.disable(this.$scope.model.current);
        };
        Action.prototype.createCluster = function (win) {
            this.$scope.optionsCreateCluster.zone = this.$scope.model.current;
            win.open();
        };
        Action.prototype.createL2Network = function () {
            this.$scope.optionsCreateL2Network.zone = this.$scope.model.current;
            this.$scope.winNewL2Network.open();
        };
        Action.prototype.addPrimaryStorage = function () {
            this.$scope.winNewPrimaryStorage.open();
        };
        Action.prototype.attachBackupStorage = function () {
        };
        return Action;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, zoneMgr, api, clusterMgr, $location, $routeParams, tagService, psMgr, current, l2Mgr, bsMgr) {
            var _this = this;
            this.$scope = $scope;
            this.zoneMgr = zoneMgr;
            this.api = api;
            this.clusterMgr = clusterMgr;
            this.$location = $location;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.psMgr = psMgr;
            this.l2Mgr = l2Mgr;
            this.bsMgr = bsMgr;
            $scope.model = new ZoneModel();
            $scope.model.current = current;
            $scope.optionsCreateCluster = new MCluster.CreateClusterOptions();
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, zoneMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.funcLoadClusters = function () {
                if (!Utils.notNullnotUndefined($scope.model.current)) {
                    return;
                }
                var qobj = new ApiHeader.QueryObject();
                qobj.addCondition({ name: 'zoneUuid', op: '=', value: $scope.model.current.uuid });
                _this.clusterMgr.query(qobj, function (clusters) {
                    $scope.optionsClusterGrid.dataSource.data(new kendo.data.ObservableArray(clusters));
                });
            };
            $scope.optionsDeleteZone = {
                confirm: function () {
                    zoneMgr.delete($scope.model.current, function (ret) {
                        $scope.model.current = null;
                    });
                },
                title: 'DELETE ZONE',
                description: 'Deleting zone will cause all sub resources(e.g Cluster, Host, VM) being deleted and no way to recover'
            };
            $scope.optionsCreateL2Network = {
                zone: null,
                done: function (l2) {
                    $scope.optionsL2NetworkGrid.dataSource.insert(0, l2);
                }
            };
            $scope.optionsClusterGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"zone.ts.NAME" | translate}}',
                        width: '20%',
                        template: '<a href="/\\#/cluster/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"zone.ts.DESCRIPTION" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'state',
                        title: '{{"zone.ts.STATE" | translate}}',
                        width: '20%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'hypervisorType',
                        title: '{{"zone.ts.HYPERVISOR" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"zone.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    data: new kendo.data.ObservableArray([])
                })
            };
            $scope.optionsCreatePrimaryStorage = {
                zone: current,
                done: function (ps) {
                    $scope.optionsPrimaryStorageGrid.dataSource.insert(0, ps);
                }
            };
            $scope.funcLoadPrimaryStorage = function () {
                $scope.optionsPrimaryStorageGrid.dataSource.read();
            };
            $scope.optionsPrimaryStorageGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"zone.ts.NAME" | translate}}',
                        width: '10%',
                        template: '<a href="/\\#/primaryStorage/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"zone.ts.DESCRIPTION" | translate}}',
                        width: '15%'
                    },
                    {
                        field: 'url',
                        title: '{{"zone.ts.URL" | translate}}',
                        width: '16%'
                    },
                    {
                        field: 'totalCapacity',
                        title: '{{"zone.ts.TOTAL CAPACITY" | translate}}',
                        width: '8%'
                    },
                    {
                        field: 'availableCapacity',
                        title: '{{"zone.ts.AVAILABLE CAPACITY" | translate}}',
                        width: '8%'
                    },
                    {
                        field: 'type',
                        title: '{{"zone.ts.TYPE" | translate}}',
                        width: '10%'
                    },
                    {
                        field: 'state',
                        title: '{{"zone.ts.STATE" | translate}}',
                        width: '15%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'uuid',
                        title: '{{"zone.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() <= 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined($scope.model.current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'zoneUuid',
                                op: '=',
                                value: $scope.model.current.uuid
                            });
                            psMgr.query(qobj, function (pss, total) {
                                options.success({
                                    data: pss,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
            $scope.optionsL2NetworkGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"zone.ts.NAME" | translate}}',
                        width: '10%',
                        template: '<a href="/\\#/l2Network/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"zone.ts.DESCRIPTION" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'physicalInterface',
                        title: '{{"zone.ts.PHYSICAL INTERFACE" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'type',
                        title: '{{"zone.ts.TYPE" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"zone.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() <= 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined($scope.model.current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'zoneUuid',
                                op: '=',
                                value: $scope.model.current.uuid
                            });
                            l2Mgr.query(qobj, function (l2s, total) {
                                options.success({
                                    data: l2s,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeZoneVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsBackupStorageGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"zone.ts.NAME" | translate}}',
                        width: '10%',
                        template: '<a href="/\\#/backupStorage/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'totalCapacity',
                        title: '{{"zone.ts.TOTAL CAPACITY" | translate}}',
                        width: '10%'
                    },
                    {
                        field: 'availableCapacity',
                        title: '{{"zone.ts.AVAILABLE CAPACITY" | translate}}',
                        width: '10%'
                    },
                    {
                        field: 'type',
                        title: '{{"zone.ts.TYPE" | translate}}',
                        width: '10%'
                    },
                    {
                        field: 'state',
                        title: '{{"zone.ts.STATE" | translate}}',
                        width: '20%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'status',
                        title: '{{"zone.ts.STATUS" | translate}}',
                        width: '20%',
                        template: '<span class="{{dataItem.statusLabel()}}">{{dataItem.status}}</span>'
                    },
                    {
                        field: 'uuid',
                        title: '{{"zone.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() <= 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'attachedZoneUuids',
                                op: 'in',
                                value: [current.uuid].join()
                            });
                            bsMgr.query(qobj, function (bss, total) {
                                options.success({
                                    data: bss,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.zoneMgr.query(qobj, function (zones, total) {
                _this.$scope.model.current = zones[0];
            });
        };
        DetailsController.$inject = ['$scope', 'ZoneManager', 'Api', 'ClusterManager', '$location', '$routeParams', 'Tag',
            'PrimaryStorageManager', 'current', 'L2NetworkManager', 'BackupStorageManager'];
        return DetailsController;
    })();
    MZone.DetailsController = DetailsController;
    var FilterBy = (function () {
        function FilterBy() {
            this.state = 'All';
        }
        FilterBy.prototype.useState = function () {
            if (this.state == 'All') {
                this.buttonName = 'state:all';
            }
            else if (this.state == 'Enabled') {
                this.buttonName = 'state:Enabled';
            }
            else if (this.state == 'Disabled') {
                this.buttonName = 'state:Disabled';
            }
            return this.state;
        };
        return FilterBy;
    })();
    MZone.FilterBy = FilterBy;
    var Controller = (function () {
        function Controller($scope, zoneMgr, api, $location) {
            var _this = this;
            this.$scope = $scope;
            this.zoneMgr = zoneMgr;
            this.api = api;
            this.$location = $location;
            $scope.action = new Action($scope, zoneMgr);
            $scope.funcCreateZone = function (win) {
                $scope.modelCreateZone = new CreateZoneModel();
                win.center();
                win.open();
            };
            $scope.funcCreateZoneDone = function (win) {
                zoneMgr.create($scope.modelCreateZone, function (ret) {
                    $scope.model.resetCurrent();
                    $scope.optionsZoneGrid.dataSource.insert(0, ret);
                });
                win.close();
            };
            $scope.funcCreateZoneCancel = function (win) {
                win.close();
            };
            $scope.funcRefresh = function () {
                var grid = $scope.zoneGrid;
                grid.dataSource.read();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                if ($scope.model.current == null) {
                    return true;
                }
                return $scope.model.current.isInProgress();
            };
            $scope.funcShowPopoverSortedBy = function (popover) {
                popover.toggle();
            };
            $scope.filterBy = new FilterBy();
            $scope.filterBy.useState();
            $scope.funcShowPopoverFilterBy = function (popover) {
                popover.toggle();
            };
            $scope.funcFilterByConfirm = function (popover) {
                var grid = $scope.zoneGrid;
                var state = $scope.filterBy.useState();
                if (state === 'All') {
                    grid.dataSource.filter(null);
                }
                else {
                    grid.dataSource.filter({
                        field: 'state',
                        operator: 'eq',
                        value: state
                    });
                }
                popover.toggle();
            };
            $scope.popoverFilterBy = function (popover) {
                popover.toggle();
            };
            $scope.funcSearch = function (search) {
                search.open();
            };
            $scope.optionsCreateL2Network = {
                zone: null,
                done: function (l2) {
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.ZoneInventoryQueryable,
                name: 'ZONE',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    console.log(JSON.stringify(ret));
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    zoneMgr.query(qobj, function (zones, total) {
                        $scope.model.resetCurrent();
                        $scope.optionsZoneGrid.dataSource.data(zones);
                    });
                }
            };
            $scope.optionsCreatePrimaryStorage = {
                zone: null,
                done: function (ps) {
                }
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                $scope.optionsCreatePrimaryStorage.zone = $scope.model.current;
            });
            $scope.optionsNewZone = {
                width: "480px",
                animation: false,
                modal: true,
                draggable: false,
                resizable: false
            };
            $scope.model = new ZoneModel();
            $scope.optionsDeleteZone = {
                confirm: function () {
                    zoneMgr.delete($scope.model.current, function (ret) {
                        var row = $scope.optionsZoneGrid.dataSource.getByUid(_this.$scope.model.current.uid);
                        $scope.model.resetCurrent();
                        $scope.optionsZoneGrid.dataSource.remove(row);
                    });
                },
                title: 'DELETE ZONE',
                description: 'Deleting zone will cause all sub resources(e.g Cluster, Host, VM) being deleted and no way to recover'
            };
            $scope.funcDeleteZone = function (win) {
                win.open();
            };
            $scope.optionsCreateCluster = new MCluster.CreateClusterOptions();
            $scope.optionsSortBy = {
                done: function (ret) {
                    zoneMgr.setSortBy(ret);
                    $scope.optionsZoneGrid.dataSource.read();
                    $scope.model.resetCurrent();
                },
                fields: [
                    {
                        name: '{{"zone.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"zone.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"zone.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"zone.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ]
            };
            $scope.funcZoneGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/zone/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.optionsZoneGrid = {
                change: function (e) {
                    var grid = e.sender;
                    var selected = grid.select();
                    Utils.safeApply($scope, function () {
                        $scope.model.setCurrent($scope, grid.dataItem(selected));
                    });
                },
                columns: [
                    {
                        field: 'name',
                        title: '{{"zone.ts.NAME" | translate}}',
                        width: '20%',
                        template: '<span><div class="{{dataItem.gridColumnLabel()}}"></div><i class="fa fa-spinner fa-spin" ng-show="dataItem.isInProgress()"></i><a href="/\\#/zone/{{dataItem.uuid}}"><span>#: name #</span></a></span>'
                    },
                    {
                        field: 'description',
                        title: '{{"zone.ts.DESCRIPTION" | translate}}',
                        width: '30%'
                    },
                    {
                        field: 'state',
                        title: '{{"zone.ts.STATE" | translate}}',
                        width: '20%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'uuid',
                        title: '{{"zone.ts.UUID" | translate}}',
                        width: '30%'
                    }
                ],
                resizable: true,
                scrollable: true,
                selectable: true,
                pageable: true,
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                    var selected = null;
                    if ($scope.model.current) {
                        selected = $scope.model.current;
                    }
                    else {
                        selected = grid.dataSource.data()[0];
                    }
                    if (selected) {
                        var row = grid.table.find('tr[data-uid="' + selected.uid + '"]');
                        grid.select(row);
                    }
                },
                dataSource: new kendo.data.DataSource({
                    transport: {
                        read: function (options) {
                            console.log(JSON.stringify(options));
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            zoneMgr.query(qobj, function (zones, total) {
                                options.success({
                                    data: zones,
                                    total: total
                                });
                            });
                        }
                    },
                    serverPaging: true,
                    pageSize: 20,
                    schema: {
                        data: 'data',
                        total: 'total'
                    }
                })
            };
        }
        Controller.$inject = ['$scope', 'ZoneManager', 'Api', '$location'];
        return Controller;
    })();
    MZone.Controller = Controller;
})(MZone || (MZone = {}));
angular.module('root').factory('ZoneManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MZone.ZoneManager(api, $rootScope);
    }]).config(['$routeProvider', function (route) {
        route.when('/zone', {
            templateUrl: '/static/templates/zone/zone.html',
            controller: 'MZone.Controller'
        }).when('/zone/:uuid', {
            templateUrl: '/static/templates/zone/details.html',
            controller: 'MZone.DetailsController',
            resolve: {
                current: function ($q, $route, ZoneManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    ZoneManager.query(qobj, function (zones) {
                        var z = zones[0];
                        defer.resolve(z);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MCluster;
(function (MCluster) {
    var Cluster = (function (_super) {
        __extends(Cluster, _super);
        function Cluster() {
            _super.apply(this, arguments);
        }
        Cluster.prototype.progressOn = function () {
            this.inProgress = true;
        };
        Cluster.prototype.progressOff = function () {
            this.inProgress = false;
        };
        Cluster.prototype.isInProgress = function () {
            return this.inProgress;
        };
        Cluster.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        Cluster.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        Cluster.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        Cluster.prototype.gridColumnLabel = function () {
            if (this.state == 'Enabled') {
                return 'z-color-box-green';
            }
            else if (this.state == 'Disabled') {
                return 'z-color-box-red';
            }
        };
        Cluster.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('hypervisorType', inv.hypervisorType);
            self.set('state', inv.state);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return Cluster;
    })(ApiHeader.ClusterInventory);
    MCluster.Cluster = Cluster;
    var ClusterManager = (function () {
        function ClusterManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        ClusterManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        ClusterManager.prototype.wrap = function (cluster) {
            return new kendo.data.ObservableObject(cluster);
        };
        ClusterManager.prototype.create = function (cluster, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateClusterMsg();
            msg.name = cluster.name;
            msg.description = cluster.description;
            msg.hypervisorType = cluster.hypervisorType;
            msg.zoneUuid = cluster.zoneUuid;
            this.api.asyncApi(msg, function (ret) {
                var c = new Cluster();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new cluster: {0}', c.name),
                    link: Utils.sprintf('/#/cluster/{0}', c.uuid)
                });
            });
        };
        ClusterManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryClusterMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var clusters = [];
                ret.inventories.forEach(function (inv) {
                    var c = new Cluster();
                    angular.extend(c, inv);
                    clusters.push(_this.wrap(c));
                });
                callback(clusters, ret.total);
            });
        };
        ClusterManager.prototype.detachPrimaryStorage = function (cluster, ps, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            cluster.progressOn();
            var msg = new ApiHeader.APIDetachPrimaryStorageFromClusterMsg();
            msg.primaryStorageUuid = ps.uuid;
            msg.clusterUuid = cluster.uuid;
            this.api.asyncApi(msg, function (ret) {
                cluster.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached cluster: {0} from primary storage: {1}', cluster.name, ps.name),
                    link: Utils.sprintf('/#/cluster/{0}', cluster.uuid)
                });
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
            });
        };
        ClusterManager.prototype.attachPrimaryStorage = function (cluster, ps, callback) {
            var _this = this;
            if (callback === void 0) { callback = null; }
            cluster.progressOn();
            var msg = new ApiHeader.APIAttachPrimaryStorageToClusterMsg();
            msg.clusterUuid = cluster.uuid;
            msg.primaryStorageUuid = ps.uuid;
            this.api.asyncApi(msg, function (ret) {
                cluster.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached cluster: {0} to primary storage: {1}', cluster.name, ps.name),
                    link: Utils.sprintf('/#/cluster/{0}', cluster.uuid)
                });
                if (Utils.notNullnotUndefined(callback)) {
                    callback();
                }
            });
        };
        ClusterManager.prototype.attachL2Network = function (cluster, l2, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            cluster.progressOn();
            var msg = new ApiHeader.APIAttachL2NetworkToClusterMsg();
            msg.clusterUuid = cluster.uuid;
            msg.l2NetworkUuid = l2.uuid;
            this.api.asyncApi(msg, function (ret) {
                cluster.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached cluster: {0} to l2 network: {1}', cluster.name, l2.name),
                    link: Utils.sprintf('/#/cluster/{0}', cluster.uuid)
                });
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
            });
        };
        ClusterManager.prototype.detachL2Network = function (cluster, l2, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            cluster.progressOn();
            var msg = new ApiHeader.APIDetachL2NetworkFromClusterMsg();
            msg.clusterUuid = cluster.uuid;
            msg.l2NetworkUuid = l2.uuid;
            this.api.asyncApi(msg, function (ret) {
                cluster.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached cluster: {0} from l2 network: {1}', cluster.name, l2.name),
                    link: Utils.sprintf('/#/cluster/{0}', cluster.uuid)
                });
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
            });
        };
        ClusterManager.prototype.disable = function (cluster) {
            var _this = this;
            cluster.progressOn();
            var msg = new ApiHeader.APIChangeClusterStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = cluster.uuid;
            this.api.asyncApi(msg, function (ret) {
                cluster.updateObservableObject(ret.inventory);
                cluster.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled cluster: {0}', cluster.name),
                    link: Utils.sprintf('/#/cluster/{0}', cluster.uuid)
                });
            });
        };
        ClusterManager.prototype.enable = function (cluster) {
            var _this = this;
            cluster.progressOn();
            var msg = new ApiHeader.APIChangeClusterStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = cluster.uuid;
            this.api.asyncApi(msg, function (ret) {
                cluster.updateObservableObject(ret.inventory);
                cluster.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled cluster: {0}', cluster.name),
                    link: Utils.sprintf('/#/cluster/{0}', cluster.uuid)
                });
            });
        };
        ClusterManager.prototype.delete = function (cluster, done) {
            var _this = this;
            cluster.progressOn();
            var msg = new ApiHeader.APIDeleteClusterMsg();
            msg.uuid = cluster.uuid;
            this.api.asyncApi(msg, function (ret) {
                cluster.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted cluster: {0}', cluster.name)
                });
            });
        };
        ClusterManager.$inject = ['Api', '$rootScope'];
        return ClusterManager;
    })();
    MCluster.ClusterManager = ClusterManager;
    var ClusterModel = (function (_super) {
        __extends(ClusterModel, _super);
        function ClusterModel() {
            _super.call(this);
            this.current = new Cluster();
        }
        return ClusterModel;
    })(Utils.Model);
    MCluster.ClusterModel = ClusterModel;
    var OClusterGrid = (function (_super) {
        __extends(OClusterGrid, _super);
        function OClusterGrid($scope, clusterMgr) {
            _super.call(this);
            this.clusterMgr = clusterMgr;
            _super.prototype.init.call(this, $scope, $scope.clusterGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"cluster.ts.NAME" | translate}}',
                    width: '15%',
                    template: '<a href="/\\#/cluster/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"cluster.ts.DESCRIPTION" | translate}}',
                    width: '25%'
                },
                {
                    field: 'hypervisorType',
                    title: '{{"cluster.ts.HYPERVISOR" | translate}}',
                    width: '15%'
                },
                {
                    field: 'state',
                    title: '{{"cluster.ts.STATE" | translate}}',
                    width: '15%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"cluster.ts.UUID" | translate}}',
                    width: '30%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                clusterMgr.query(qobj, function (clusters, total) {
                    options.success({
                        data: clusters,
                        total: total
                    });
                });
            };
        }
        return OClusterGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, clusterMgr) {
            this.$scope = $scope;
            this.clusterMgr = clusterMgr;
        }
        Action.prototype.enable = function () {
            this.clusterMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.clusterMgr.disable(this.$scope.model.current);
        };
        Action.prototype.addHost = function () {
            this.$scope.winNewHost.open();
        };
        Action.prototype.attachL2Network = function () {
            this.$scope.winAttachL2Network.open();
        };
        Action.prototype.detachL2Network = function () {
            this.$scope.winDetachL2Network.open();
        };
        Action.prototype.attachPrimaryStorage = function () {
            this.$scope.winAttachPrimaryStorage.open();
        };
        Action.prototype.detachPrimaryStorage = function () {
            this.$scope.winDetachPrimaryStorage.open();
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, hypervisorTypes) {
            var _this = this;
            this.$scope = $scope;
            this.hypervisorTypes = hypervisorTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"cluster.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"cluster.ts.State" | translate}}',
                            value: FilterBy.STATE
                        },
                        {
                            name: '{{"cluster.ts.Hypervisor" | translate}}',
                            value: FilterBy.HYPERVISOR
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
                else if (_this.field == FilterBy.HYPERVISOR) {
                    _this.valueList.dataSource.data(_this.hypervisorTypes);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            console.log(JSON.stringify(this.toKendoFilter()));
            this.$scope.oClusterGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        FilterBy.HYPERVISOR = 'hypervisorType';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, clusterMgr, $routeParams, tagService, psMgr, current, l2Mgr, hostMgr) {
            var _this = this;
            this.$scope = $scope;
            this.clusterMgr = clusterMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.psMgr = psMgr;
            this.current = current;
            this.l2Mgr = l2Mgr;
            this.hostMgr = hostMgr;
            $scope.model = new ClusterModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, clusterMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteCluster = {
                title: 'DELETE CLUSTER',
                description: 'Deleting cluster will cause all sub resources(e.g Host, VM) being deleted and no way to recover',
                confirm: function () {
                    clusterMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeClusterVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsAttachL2Network = {
                cluster: $scope.model.current,
                done: function (l2) {
                    $scope.optionsL2NetworkGrid.dataSource.insert(0, l2);
                }
            };
            $scope.optionsDetachL2Network = {
                cluster: $scope.model.current,
                done: function (l2) {
                    var ds = $scope.optionsL2NetworkGrid.dataSource;
                    var l2s = ds.data();
                    for (var i = 0; i < l2s.length; i++) {
                        var tl2 = l2s[i];
                        if (l2.uuid == tl2.uuid) {
                            var row = ds.getByUid(tl2.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
            $scope.optionsAttachPrimaryStorage = {
                cluster: $scope.model.current,
                done: function (ps) {
                    $scope.optionsPrimaryStorageGrid.dataSource.insert(0, ps);
                }
            };
            $scope.optionsDetachPrimaryStorage = {
                cluster: $scope.model.current,
                done: function (ps) {
                    var ds = $scope.optionsPrimaryStorageGrid.dataSource;
                    var pss = ds.data();
                    for (var i = 0; i < pss.length; i++) {
                        var tps = pss[i];
                        if (ps.uuid == tps.uuid) {
                            var row = ds.getByUid(tps.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
            $scope.optionsCreateHost = {
                done: function (info) {
                    hostMgr.create(info, function (ret) {
                        $scope.optionsHostGrid.dataSource.read();
                    });
                }
            };
            $scope.optionsHostGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"cluster.ts.NAME" | translate}}',
                        width: '25%',
                        template: '<a href="/\\#/host/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"cluster.ts.DESCRIPTION" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'managementIp',
                        title: '{{"cluster.ts.MANAGEMENT IP" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"cluster.ts.UUID" | translate}}',
                        width: '25%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() <= 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined($scope.model.current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'clusterUuid',
                                op: '=',
                                value: $scope.model.current.uuid
                            });
                            hostMgr.query(qobj, function (hosts, total) {
                                options.success({
                                    data: hosts,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
            $scope.optionsL2NetworkGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"cluster.ts.NAME" | translate}}',
                        width: '10%',
                        template: '<a href="/\\#/l2Network/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"cluster.ts.DESCRIPTION" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'physicalInterface',
                        title: '{{"cluster.ts.PHYSICAL INTERFACE" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'type',
                        title: '{{"cluster.ts.TYPE" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"cluster.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() <= 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined($scope.model.current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'attachedClusterUuids',
                                op: 'in',
                                value: $scope.model.current.uuid
                            });
                            l2Mgr.query(qobj, function (l2s, total) {
                                options.success({
                                    data: l2s,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
            $scope.funcLoadPrimaryStorage = function () {
                $scope.optionsPrimaryStorageGrid.dataSource.read();
            };
            $scope.optionsPrimaryStorageGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"cluster.ts.NAME" | translate}}',
                        width: '10%',
                        template: '<a href="/\\#/primaryStorage/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"cluster.ts.DESCRIPTION" | translate}}',
                        width: '15%'
                    },
                    {
                        field: 'url',
                        title: '{{"cluster.ts.URL" | translate}}',
                        width: '16%'
                    },
                    {
                        field: 'totalCapacity',
                        title: '{{"cluster.ts.TOTAL CAPACITY" | translate}}',
                        width: '8%'
                    },
                    {
                        field: 'availableCapacity',
                        title: '{{"cluster.ts.AVAILABLE CAPACITY" | translate}}',
                        width: '8%'
                    },
                    {
                        field: 'type',
                        title: '{{"cluster.ts.TYPE" | translate}}',
                        width: '10%'
                    },
                    {
                        field: 'state',
                        title: '{{"cluster.ts.STATE" | translate}}',
                        width: '15%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'uuid',
                        title: '{{"cluster.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() <= 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined($scope.model.current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'attachedClusterUuids',
                                op: 'in',
                                value: $scope.model.current.uuid
                            });
                            psMgr.query(qobj, function (pss, total) {
                                options.success({
                                    data: pss,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.clusterMgr.query(qobj, function (clusters, total) {
                _this.$scope.model.current = clusters[0];
            });
        };
        DetailsController.$inject = ['$scope', 'ClusterManager', '$routeParams', 'Tag', 'PrimaryStorageManager', 'current', 'L2NetworkManager', 'HostManager'];
        return DetailsController;
    })();
    MCluster.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, clusterMgr, hypervisorTypes, $location, hostMgr) {
            this.$scope = $scope;
            this.clusterMgr = clusterMgr;
            this.hypervisorTypes = hypervisorTypes;
            this.$location = $location;
            this.hostMgr = hostMgr;
            $scope.model = new ClusterModel();
            $scope.oClusterGrid = new OClusterGrid($scope, clusterMgr);
            $scope.action = new Action($scope, clusterMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"cluster.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"cluster.ts.Description" | translate}}',
                        value: 'Description'
                    },
                    {
                        name: '{{"cluster.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"cluster.ts.Hypervisor" | translate}}',
                        value: 'hypervisorType'
                    },
                    {
                        name: '{{"cluster.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"cluster.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    clusterMgr.setSortBy(ret);
                    $scope.oClusterGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.ClusterInventoryQueryable,
                name: 'CLUSTER',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    hypervisorType: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.hypervisorTypes
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    clusterMgr.query(qobj, function (clusters, total) {
                        $scope.oClusterGrid.refresh(clusters);
                    });
                }
            };
            $scope.optionsAttachPrimaryStorage = {
                cluster: $scope.model.current,
                done: function (ps) {
                }
            };
            $scope.optionsDetachPrimaryStorage = {
                cluster: $scope.model.current,
                done: function (ps) {
                }
            };
            $scope.optionsAttachL2Network = {
                cluster: $scope.model.current,
                done: function (l2) {
                }
            };
            $scope.optionsDetachL2Network = {
                cluster: $scope.model.current,
                done: function (l2) {
                }
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                $scope.optionsAttachPrimaryStorage.cluster = $scope.model.current;
                $scope.optionsDetachPrimaryStorage.cluster = $scope.model.current;
                $scope.optionsAttachL2Network.cluster = $scope.model.current;
                $scope.optionsDetachL2Network.cluster = $scope.model.current;
            });
            $scope.funcClusterGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/cluster/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.hypervisorTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateCluster = function (win) {
                win.open();
            };
            $scope.funcDeleteCluster = function (win) {
                $scope.deleteCluster.open();
            };
            $scope.optionsDeleteCluster = {
                title: 'DELETE CLUSTER',
                description: 'Deleting cluster will cause all sub resources(e.g Host, VM) being deleted and no way to recover',
                confirm: function () {
                    clusterMgr.delete($scope.model.current, function (ret) {
                        $scope.oClusterGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oClusterGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateCluster = {
                done: function (cluster) {
                    $scope.oClusterGrid.add(cluster);
                }
            };
            $scope.optionsCreateHost = {
                done: function (info) {
                    hostMgr.create(info, function (ret) {
                    });
                }
            };
        }
        Controller.$inject = ['$scope', 'ClusterManager', 'hypervisorTypes', '$location', 'HostManager'];
        return Controller;
    })();
    MCluster.Controller = Controller;
    var CreateClusterOptions = (function () {
        function CreateClusterOptions() {
        }
        return CreateClusterOptions;
    })();
    MCluster.CreateClusterOptions = CreateClusterOptions;
    var CreateCluster = (function () {
        function CreateCluster(api, zoneMgr, clusterMgr, psMgr, l2Mgr) {
            var _this = this;
            this.api = api;
            this.zoneMgr = zoneMgr;
            this.clusterMgr = clusterMgr;
            this.psMgr = psMgr;
            this.l2Mgr = l2Mgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateCluster;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateClusterOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    zoneUuid: null,
                    description: null,
                    hypervisorType: null,
                    canMoveToPrevious: function () {
                        return false;
                    },
                    hasZone: function () {
                        return $scope.zoneList.dataSource.data().length > 0;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.zoneUuid)
                            && Utils.notNullnotUndefined(this.hypervisorType);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createClusterInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createClusterInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName("cluster");
                        this.zoneUuid = null;
                        this.description = null;
                        this.hypervisorType = null;
                        this.activeState = false;
                    }
                };
                var psPage = $scope.psPage = {
                    activeState: false,
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createClusterPrimaryStorage"]');
                    },
                    hasPrimaryStorage: function () {
                        return $scope.primaryStorageListOptions__.dataSource.data().length > 0;
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createClusterPrimaryStorage';
                    },
                    reset: function () {
                        this.activeState = false;
                    }
                };
                var l2Page = $scope.l2Page = {
                    activeState: false,
                    hasL2Netwwork: function () {
                        return $scope.l2NetworkListOptions__.dataSource.data().length > 0;
                    },
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createClusterL2Network"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createClusterL2Network';
                    },
                    reset: function () {
                        this.activeState = false;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultCluster;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            clusterMgr.create(infoPage, function (ret) {
                                resultCluster = ret;
                                chain.next();
                            });
                        }).then(function () {
                            var pss = $scope.primaryStorageList__.dataItems();
                            angular.forEach(pss, function (ps) {
                                clusterMgr.attachPrimaryStorage(resultCluster, ps);
                            });
                            chain.next();
                        }).then(function () {
                            var l2s = $scope.l2NetworkList__.dataItems();
                            angular.forEach(l2s, function (l2) {
                                clusterMgr.attachL2Network(resultCluster, l2);
                            });
                            chain.next();
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultCluster);
                            }
                            $scope.winCreateCluster__.close();
                        }).start();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage, psPage, l2Page
                ], mediator);
                $scope.$watch(function () {
                    return $scope.infoPage.zoneUuid;
                }, function () {
                    if (Utils.notNullnotUndefined($scope.primaryStorageList__)) {
                        $scope.primaryStorageList__.value([]);
                    }
                    var zuuid = $scope.infoPage.zoneUuid;
                    if (Utils.notNullnotUndefined(zuuid)) {
                        _this.queryPrimaryStorages(zuuid, function (pss) {
                            $scope.primaryStorageListOptions__.dataSource.data(pss);
                        });
                        _this.queryL2Networks(zuuid, function (l2s) {
                            $scope.l2NetworkListOptions__.dataSource.data(l2s);
                        });
                    }
                });
                $scope.zoneList = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"cluster.ts.Name" | translate}}</span>: #: name #</div>' + '<div style="color: black"><span class="z-label">{{"cluster.ts.State" | translate}}</span>#: state #</div>' + '<div style="color: black"><span class="z-label">{{"cluster.ts.UUID" | translate}}</span> #: uuid #</div>'
                };
                $scope.hypervisorList = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "type",
                    dataValueField: "type"
                };
                $scope.winCreateClusterOptions__ = {
                    width: "700px",
                    //height: "518px",
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.primaryStorageListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">Type:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">URL:</span><span>#: url #</span></div>'
                };
                $scope.l2NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">Type:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">Physical Interface:</span><span>#: physicalInterface #</span></div>'
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/cluster/createCluster.html';
        }
        CreateCluster.prototype.queryPrimaryStorages = function (zoneUuid, done) {
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'zoneUuid',
                    op: '=',
                    value: zoneUuid
                }
            ];
            this.psMgr.query(qobj, function (pss) {
                done(pss);
            });
        };
        CreateCluster.prototype.queryL2Networks = function (zoneUuid, done) {
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'zoneUuid',
                    op: '=',
                    value: zoneUuid
                }
            ];
            this.l2Mgr.query(qobj, function (l2s) {
                done(l2s);
            });
        };
        CreateCluster.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateCluster__;
            this.$scope.primaryStorageList__.value([]);
            this.$scope.l2NetworkList__.value([]);
            this.$scope.button.reset();
            var chain = new Utils.Chain();
            chain.then(function () {
                if (Utils.notNullnotUndefined(_this.options.zone)) {
                    _this.$scope.zoneList.dataSource.data(new kendo.data.ObservableArray([_this.options.zone]));
                    _this.$scope.infoPage.zoneUuid = _this.options.zone.uuid;
                    chain.next();
                }
                else {
                    _this.zoneMgr.query(new ApiHeader.QueryObject(), function (zones, total) {
                        _this.$scope.zoneList.dataSource.data(zones);
                        if (zones.length > 0) {
                            _this.$scope.infoPage.zoneUuid = zones[0].uuid;
                        }
                        chain.next();
                    });
                }
            }).then(function () {
                _this.api.getHypervisorTypes(function (hvTypes) {
                    var types = [];
                    angular.forEach(hvTypes, function (item) {
                        types.push({ type: item });
                    });
                    _this.$scope.hypervisorList.dataSource.data(new kendo.data.ObservableArray(types));
                    _this.$scope.model.hypervisorType = hvTypes[0];
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreateCluster;
    })();
    MCluster.CreateCluster = CreateCluster;
    var AttachL2NetworkOptions = (function () {
        function AttachL2NetworkOptions() {
        }
        return AttachL2NetworkOptions;
    })();
    MCluster.AttachL2NetworkOptions = AttachL2NetworkOptions;
    var ClusterAttachL2Network = (function () {
        function ClusterAttachL2Network(l2Mgr, clusterMgr) {
            var _this = this;
            this.l2Mgr = l2Mgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/cluster/attachL2Network.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zClusterAttachL2Network] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                _this.l2NetworkListOptions = $scope.l2NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">Type:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">Physical Interface:</span><span>#: physicalInterface #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasL2Network = function () {
                    return $scope.l2NetworkListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.attachL2Network__.close();
                };
                $scope.done = function () {
                    var l2s = $scope.l2NetworkList__.dataItems();
                    angular.forEach(l2s, function (l2) {
                        clusterMgr.attachL2Network(_this.options.cluster, l2, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(l2);
                            }
                        });
                    });
                    $scope.attachL2Network__.close();
                };
            };
        }
        ClusterAttachL2Network.prototype.open = function () {
            var _this = this;
            this.$scope.l2NetworkList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'zoneUuid',
                        op: '=',
                        value: _this.options.cluster.zoneUuid
                    },
                    {
                        name: 'attachedClusterUuids',
                        op: 'not in',
                        value: _this.options.cluster.uuid
                    }
                ];
                _this.l2Mgr.query(qobj, function (l2s) {
                    _this.l2NetworkListOptions.dataSource.data(l2s);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachL2Network__.center();
                _this.$scope.attachL2Network__.open();
            }).start();
        };
        return ClusterAttachL2Network;
    })();
    MCluster.ClusterAttachL2Network = ClusterAttachL2Network;
    var DetachL2NetworkOptions = (function () {
        function DetachL2NetworkOptions() {
        }
        return DetachL2NetworkOptions;
    })();
    MCluster.DetachL2NetworkOptions = DetachL2NetworkOptions;
    var ClusterDetachL2Network = (function () {
        function ClusterDetachL2Network(l2Mgr, clusterMgr) {
            var _this = this;
            this.l2Mgr = l2Mgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/cluster/detachL2Network.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zClusterDetachL2Network] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.l2NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">Type:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">Physical Interface:</span><span>#: physicalInterface #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasL2Network = function () {
                    return $scope.l2NetworkListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.detachL2Network__.close();
                };
                $scope.done = function () {
                    var l2s = $scope.l2NetworkList__.dataItems();
                    angular.forEach(l2s, function (l2) {
                        clusterMgr.detachL2Network(_this.options.cluster, l2, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(l2);
                            }
                        });
                    });
                    $scope.detachL2Network__.close();
                };
                $scope.detachL2NetworkOptions__ = {
                    width: '600px'
                };
            };
        }
        ClusterDetachL2Network.prototype.open = function () {
            var _this = this;
            this.$scope.l2NetworkList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'attachedClusterUuids',
                        op: 'in',
                        value: _this.options.cluster.uuid
                    }
                ];
                _this.l2Mgr.query(qobj, function (l2s) {
                    _this.$scope.l2NetworkListOptions__.dataSource.data(l2s);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.detachL2Network__.center();
                _this.$scope.detachL2Network__.open();
            }).start();
        };
        return ClusterDetachL2Network;
    })();
    MCluster.ClusterDetachL2Network = ClusterDetachL2Network;
    var AttachPrimaryStorageOptions = (function () {
        function AttachPrimaryStorageOptions() {
        }
        return AttachPrimaryStorageOptions;
    })();
    MCluster.AttachPrimaryStorageOptions = AttachPrimaryStorageOptions;
    var ClusterAttachPrimaryStorage = (function () {
        function ClusterAttachPrimaryStorage(psMgr, clusterMgr) {
            var _this = this;
            this.psMgr = psMgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/cluster/attachPrimaryStorage.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zClusterAttachPrimaryStorage] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                _this.primaryStorageListOptions = $scope.primaryStorageListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">Type:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">URL:</span><span>#: url #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasPrimaryStorage = function () {
                    return $scope.primaryStorageListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.attachPrimaryStorage__.close();
                };
                $scope.done = function () {
                    var pss = $scope.primaryStorageList__.dataItems();
                    angular.forEach(pss, function (ps) {
                        clusterMgr.attachPrimaryStorage(_this.options.cluster, ps, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(ps);
                            }
                        });
                    });
                    $scope.attachPrimaryStorage__.close();
                };
            };
        }
        ClusterAttachPrimaryStorage.prototype.open = function () {
            var _this = this;
            this.$scope.primaryStorageList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'zoneUuid',
                        op: '=',
                        value: _this.options.cluster.zoneUuid
                    },
                    {
                        name: 'attachedClusterUuids',
                        op: 'not in',
                        value: _this.options.cluster.uuid
                    }
                ];
                _this.psMgr.query(qobj, function (pss) {
                    _this.primaryStorageListOptions.dataSource.data(pss);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachPrimaryStorage__.center();
                _this.$scope.attachPrimaryStorage__.open();
            }).start();
        };
        return ClusterAttachPrimaryStorage;
    })();
    MCluster.ClusterAttachPrimaryStorage = ClusterAttachPrimaryStorage;
    var DetachPrimaryStorageOptions = (function () {
        function DetachPrimaryStorageOptions() {
        }
        return DetachPrimaryStorageOptions;
    })();
    MCluster.DetachPrimaryStorageOptions = DetachPrimaryStorageOptions;
    var ClusterDetachPrimaryStorage = (function () {
        function ClusterDetachPrimaryStorage(psMgr, clusterMgr) {
            var _this = this;
            this.psMgr = psMgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/cluster/detachPrimaryStorage.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zClusterDetachPrimaryStorage] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.primaryStorageListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">Type:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">URL:</span><span>#: url #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasPrimaryStorage = function () {
                    return $scope.primaryStorageListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.detachPrimaryStorage__.close();
                };
                $scope.done = function () {
                    var pss = $scope.primaryStorageList__.dataItems();
                    angular.forEach(pss, function (ps) {
                        clusterMgr.detachPrimaryStorage(_this.options.cluster, ps, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(ps);
                            }
                        });
                    });
                    $scope.detachPrimaryStorage__.close();
                };
                $scope.detachPrimaryStorageOptions__ = {
                    width: '600px'
                };
            };
        }
        ClusterDetachPrimaryStorage.prototype.open = function () {
            var _this = this;
            this.$scope.primaryStorageList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'attachedClusterUuids',
                        op: 'in',
                        value: _this.options.cluster.uuid
                    }
                ];
                _this.psMgr.query(qobj, function (pss) {
                    _this.$scope.primaryStorageListOptions__.dataSource.data(pss);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.detachPrimaryStorage__.center();
                _this.$scope.detachPrimaryStorage__.open();
            }).start();
        };
        return ClusterDetachPrimaryStorage;
    })();
    MCluster.ClusterDetachPrimaryStorage = ClusterDetachPrimaryStorage;
})(MCluster || (MCluster = {}));
angular.module('root').factory('ClusterManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MCluster.ClusterManager(api, $rootScope);
    }]).directive('zCreateCluster', ['Api', 'ZoneManager', 'ClusterManager', 'PrimaryStorageManager', 'L2NetworkManager',
    function (api, zoneMgr, clusterMgr, psMgr, l2Mgr) {
        return new MCluster.CreateCluster(api, zoneMgr, clusterMgr, psMgr, l2Mgr);
    }]).directive('zClusterAttachPrimaryStorage', ['PrimaryStorageManager', 'ClusterManager', function (psMgr, clusterMgr) {
        return new MCluster.ClusterAttachPrimaryStorage(psMgr, clusterMgr);
    }]).directive('zClusterDetachPrimaryStorage', ['PrimaryStorageManager', 'ClusterManager', function (psMgr, clusterMgr) {
        return new MCluster.ClusterDetachPrimaryStorage(psMgr, clusterMgr);
    }]).directive('zClusterDetachL2Network', ['L2NetworkManager', 'ClusterManager', function (l2Mgr, clusterMgr) {
        return new MCluster.ClusterDetachL2Network(l2Mgr, clusterMgr);
    }]).directive('zClusterAttachL2Network', ['L2NetworkManager', 'ClusterManager', function (l2Mgr, clusterMgr) {
        return new MCluster.ClusterAttachL2Network(l2Mgr, clusterMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/cluster', {
            templateUrl: '/static/templates/cluster/cluster.html',
            controller: 'MCluster.Controller',
            resolve: {
                hypervisorTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getHypervisorTypes(function (hvTypes) {
                        defer.resolve(hvTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/cluster/:uuid', {
            templateUrl: '/static/templates/cluster/details.html',
            controller: 'MCluster.DetailsController',
            resolve: {
                current: function ($q, ClusterManager, $route) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    ClusterManager.query(qobj, function (clusters, total) {
                        defer.resolve(clusters[0]);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MPrimaryStorage;
(function (MPrimaryStorage) {
    var PrimaryStorage = (function (_super) {
        __extends(PrimaryStorage, _super);
        function PrimaryStorage() {
            _super.apply(this, arguments);
        }
        PrimaryStorage.prototype.progressOn = function () {
            this.inProgress = true;
        };
        PrimaryStorage.prototype.progressOff = function () {
            this.inProgress = false;
        };
        PrimaryStorage.prototype.isInProgress = function () {
            return this.inProgress;
        };
        PrimaryStorage.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        PrimaryStorage.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        PrimaryStorage.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        PrimaryStorage.prototype.statusLabel = function () {
            if (this.status == 'Connected') {
                return 'label label-success';
            }
            else if (this.status == 'Disconnected') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        PrimaryStorage.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('zoneUuid', inv.zoneUuid);
            self.set('url', inv.url);
            self.set('totalCapacity', inv.totalCapacity);
            self.set('availableCapacity', inv.availableCapacity);
            self.set('type', inv.type);
            self.set('state', inv.state);
            self.set('status', inv.status);
            self.set('mountPath', inv.mountPath);
            self.set('attachedClusterUuids', inv.attachedClusterUuids);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return PrimaryStorage;
    })(ApiHeader.PrimaryStorageInventory);
    MPrimaryStorage.PrimaryStorage = PrimaryStorage;
    var PrimaryStorageManager = (function () {
        function PrimaryStorageManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        PrimaryStorageManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        PrimaryStorageManager.prototype.wrap = function (PrimaryStorage) {
            return new kendo.data.ObservableObject(PrimaryStorage);
        };
        PrimaryStorageManager.prototype.create = function (ps, done) {
            var _this = this;
            var msg = null;
            if (ps.type == 'NFS') {
                msg = new ApiHeader.APIAddNfsPrimaryStorageMsg();
                msg.type = 'NFS';
            }
            else if (ps.type == 'SimulatorPrimaryStorage') {
                msg = new ApiHeader.APIAddSimulatorPrimaryStorageMsg();
                msg.type = 'SimulatorPrimaryStorage';
            }
            else if (ps.type == 'IscsiFileSystemBackendPrimaryStorage') {
                msg = new ApiHeader.APIAddIscsiFileSystemBackendPrimaryStorageMsg();
                msg.chapPassword = ps.chapPassword;
                msg.chapUsername = ps.chapUsername;
                msg.sshUsername = ps.sshUsername;
                msg.sshPassword = ps.sshPassword;
                msg.hostname = ps.hostname;
            }
            else if (ps.type == 'LocalStorage') {
                msg = new ApiHeader.APIAddLocalPrimaryStorageMsg();
            }
            else if (ps.type == 'Ceph') {
                msg = new ApiHeader.APIAddCephPrimaryStorageMsg();
                msg.monUrls = ps.cephMonUrls;
            }
            msg.name = ps.name;
            msg.description = ps.description;
            msg.zoneUuid = ps.zoneUuid;
            msg.url = ps.url;
            this.api.asyncApi(msg, function (ret) {
                var c = new PrimaryStorage();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new Primary Storage: {0}', c.name),
                    link: Utils.sprintf('/#/primaryStorage/{0}', c.uuid)
                });
            });
        };
        PrimaryStorageManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryPrimaryStorageMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new PrimaryStorage();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        PrimaryStorageManager.prototype.disable = function (ps) {
            var _this = this;
            ps.progressOn();
            var msg = new ApiHeader.APIChangePrimaryStorageStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = ps.uuid;
            this.api.asyncApi(msg, function (ret) {
                ps.updateObservableObject(ret.inventory);
                ps.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Primary Storage: {0}', ps.name),
                    link: Utils.sprintf('/#/primaryStorage/{0}', ps.uuid)
                });
            });
        };
        PrimaryStorageManager.prototype.reconnect = function (ps) {
            var _this = this;
            ps.progressOn();
            var msg = new ApiHeader.APIReconnectPrimaryStorageMsg();
            msg.uuid = ps.uuid;
            ps.status = 'Connecting';
            this.api.asyncApi(msg, function (ret) {
                ps.updateObservableObject(ret.inventory);
                ps.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Reconnected Primary Storage: {0}', ps.name),
                    link: Utils.sprintf('/#/primaryStorage/{0}', ps.uuid)
                });
            });
        };
        PrimaryStorageManager.prototype.enable = function (ps) {
            var _this = this;
            ps.progressOn();
            var msg = new ApiHeader.APIChangePrimaryStorageStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = ps.uuid;
            this.api.asyncApi(msg, function (ret) {
                ps.updateObservableObject(ret.inventory);
                ps.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled Primary Storage: {0}', ps.name),
                    link: Utils.sprintf('/#/primaryStorage/{0}', ps.uuid)
                });
            });
        };
        PrimaryStorageManager.prototype.attach = function (ps, cluster, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            ps.progressOn();
            var msg = new ApiHeader.APIAttachPrimaryStorageToClusterMsg();
            msg.clusterUuid = cluster.uuid;
            msg.primaryStorageUuid = ps.uuid;
            this.api.asyncApi(msg, function (ret) {
                ps.updateObservableObject(ret.inventory);
                ps.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached Primary Storage: {0} to Cluster: {1}', ps.name, cluster.name),
                    link: Utils.sprintf('/#/primaryStorage/{0}', ps.uuid)
                });
            });
        };
        PrimaryStorageManager.prototype.detach = function (ps, cluster, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            ps.progressOn();
            var msg = new ApiHeader.APIDetachPrimaryStorageFromClusterMsg();
            msg.clusterUuid = cluster.uuid;
            msg.primaryStorageUuid = ps.uuid;
            this.api.asyncApi(msg, function (ret) {
                ps.updateObservableObject(ret.inventory);
                ps.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached Primary Storage: {0} from Cluster: {1}', ps.name, cluster.name),
                    link: Utils.sprintf('/#/primaryStorage/{0}', ps.uuid)
                });
            });
        };
        PrimaryStorageManager.prototype.delete = function (ps, done) {
            var _this = this;
            ps.progressOn();
            var msg = new ApiHeader.APIDeletePrimaryStorageMsg();
            msg.uuid = ps.uuid;
            this.api.asyncApi(msg, function (ret) {
                ps.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted Primary Storage: {0}', ps.name)
                });
            });
        };
        PrimaryStorageManager.$inject = ['Api', '$rootScope'];
        return PrimaryStorageManager;
    })();
    MPrimaryStorage.PrimaryStorageManager = PrimaryStorageManager;
    var PrimaryStorageModel = (function (_super) {
        __extends(PrimaryStorageModel, _super);
        function PrimaryStorageModel() {
            _super.call(this);
            this.current = new PrimaryStorage();
        }
        return PrimaryStorageModel;
    })(Utils.Model);
    MPrimaryStorage.PrimaryStorageModel = PrimaryStorageModel;
    var OPrimaryStorageGrid = (function (_super) {
        __extends(OPrimaryStorageGrid, _super);
        function OPrimaryStorageGrid($scope, psMgr) {
            _super.call(this);
            this.psMgr = psMgr;
            _super.prototype.init.call(this, $scope, $scope.primaryStorageGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"primaryStorage.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/primaryStorage/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"primaryStorage.ts.DESCRIPTION" | translate}}',
                    width: '10%'
                },
                {
                    field: 'url',
                    title: 'URL',
                    width: '16%'
                },
                {
                    field: 'totalCapacity',
                    title: '{{"primaryStorage.ts.TOTAL CAPACITY" | translate}}',
                    width: '8%',
                    template: '<span>{{dataItem.totalCapacity | size}}</span>'
                },
                {
                    field: 'availableCapacity',
                    title: '{{"primaryStorage.ts.AVAILABLE CAPACITY" | translate}}',
                    width: '8%',
                    template: '<span>{{dataItem.availableCapacity | size}}</span>'
                },
                {
                    field: 'type',
                    title: '{{"primaryStorage.ts.TYPE" | translate}}',
                    width: '10%'
                },
                {
                    field: 'state',
                    title: '{{"primaryStorage.ts.STATE" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'status',
                    title: '{{"primaryStorage.ts.STATUS" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.statusLabel()}}">{{dataItem.status}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"primaryStorage.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                psMgr.query(qobj, function (pss, total) {
                    options.success({
                        data: pss,
                        total: total
                    });
                });
            };
        }
        return OPrimaryStorageGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, psMgr) {
            this.$scope = $scope;
            this.psMgr = psMgr;
        }
        Action.prototype.enable = function () {
            this.psMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.psMgr.disable(this.$scope.model.current);
        };
        Action.prototype.addHost = function () {
        };
        Action.prototype.reconnect = function () {
            this.psMgr.reconnect(this.$scope.model.current);
        };
        Action.prototype.attachL2Network = function () {
        };
        Action.prototype.detachL2Network = function () {
        };
        Action.prototype.attachCluster = function () {
            this.$scope.attachCluster.open();
        };
        Action.prototype.detachCluster = function () {
            this.$scope.detachCluster.open();
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, psTypes) {
            var _this = this;
            this.$scope = $scope;
            this.psTypes = psTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"primaryStorage.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"primaryStorage.ts.State" | translate}}',
                            value: FilterBy.STATE
                        },
                        {
                            name: '{{"primaryStorage.ts.Type" | translate}}',
                            value: FilterBy.TYPE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(_this.psTypes);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oPrimaryStorageGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        FilterBy.TYPE = 'type';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, psMgr, $routeParams, tagService, current, clusterMgr) {
            var _this = this;
            this.$scope = $scope;
            this.psMgr = psMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new PrimaryStorageModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, psMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeletePrimaryStorage = {
                title: 'DELETE PRIMARY STORAGE',
                html: '<strong><p>Deleting Primary Storage will cause:</p></strong>' +
                    '<ul><li><strong>Clusters to which this primary storage has attached will be detached</strong></li>' +
                    '<li><strong>VMs which has volumes on this primary storage will be deleted</strong></li></ul>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    psMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypePrimaryStorageVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsAttachCluster = {
                primaryStorage: $scope.model.current,
                done: function (cluster) {
                    $scope.optionsClusterGrid.dataSource.insert(0, cluster);
                }
            };
            $scope.optionsDetachCluster = {
                primaryStorage: $scope.model.current,
                done: function (cluster) {
                    var ds = $scope.optionsClusterGrid.dataSource;
                    var cs = ds.data();
                    for (var i = 0; i < cs.length; i++) {
                        var tcs = cs[i];
                        if (cluster.uuid == tcs.uuid) {
                            var row = ds.getByUid(tcs.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
            $scope.funcLoadClusters = function () {
                $scope.optionsClusterGrid.dataSource.read();
            };
            $scope.optionsClusterGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"primaryStorage.ts.NAME" | translate}}',
                        width: '20%',
                        template: '<a href="/\\#/cluster/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"primaryStorage.ts.DESCRIPTION" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'state',
                        title: '{{"primaryStorage.ts.STATE" | translate}}',
                        width: '20%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'hypervisorType',
                        title: '{{"primaryStorage.ts.HYPERVISOR" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"primaryStorage.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined($scope.model.current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'uuid',
                                op: 'in',
                                value: $scope.model.current.attachedClusterUuids.join()
                            });
                            clusterMgr.query(qobj, function (clusters, total) {
                                options.success({
                                    data: clusters,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.psMgr.query(qobj, function (pss, total) {
                _this.$scope.model.current = pss[0];
            });
        };
        DetailsController.$inject = ['$scope', 'PrimaryStorageManager', '$routeParams', 'Tag', 'current', 'ClusterManager'];
        return DetailsController;
    })();
    MPrimaryStorage.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, psMgr, primaryStorageTypes, $location) {
            this.$scope = $scope;
            this.psMgr = psMgr;
            this.primaryStorageTypes = primaryStorageTypes;
            this.$location = $location;
            $scope.model = new PrimaryStorageModel();
            $scope.oPrimaryStorageGrid = new OPrimaryStorageGrid($scope, psMgr);
            $scope.action = new Action($scope, psMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"primaryStorage.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"primaryStorage.ts.Description" | translate}}',
                        value: 'Description'
                    },
                    {
                        name: '{{"primaryStorage.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"primaryStorage.ts.Total Capacity" | translate}}',
                        value: 'totalCapacity'
                    },
                    {
                        name: '{{"primaryStorage.ts.Available Capacity" | translate}}',
                        value: 'availableCapacity'
                    },
                    {
                        name: '{{"primaryStorage.ts.Type" | translate}}',
                        value: 'type'
                    },
                    {
                        name: '{{"primaryStorage.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"primaryStorage.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    psMgr.setSortBy(ret);
                    $scope.oPrimaryStorageGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.PrimaryStorageInventoryQueryable,
                name: 'PrimaryStorage',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    type: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.primaryStorageTypes
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    psMgr.query(qobj, function (PrimaryStorages, total) {
                        $scope.oPrimaryStorageGrid.refresh(PrimaryStorages);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/primaryStorage/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.primaryStorageTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreatePrimaryStorage = function (win) {
                win.open();
            };
            $scope.funcDeletePrimaryStorage = function () {
                $scope.deletePrimaryStorage.open();
            };
            $scope.optionsDeletePrimaryStorage = {
                title: 'DELETE PRIMARY STORAGE',
                html: '<strong><p>Deleting Primary Storage will cause:</p></strong>' +
                    '<ul><li><strong>Clusters to which this primary storage has attached will be detached</strong></li>' +
                    '<li><strong>VMs which has volumes on this primary storage will be deleted</strong></li></ul>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    psMgr.delete($scope.model.current, function (ret) {
                        $scope.oPrimaryStorageGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oPrimaryStorageGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreatePrimaryStorage = {
                done: function (ps) {
                    $scope.oPrimaryStorageGrid.add(ps);
                }
            };
            $scope.optionsAttachCluster = {
                primaryStorage: $scope.model.current,
                done: function (cluster) {
                }
            };
            $scope.optionsDetachCluster = {
                primaryStorage: $scope.model.current,
                done: function (cluster) {
                }
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                $scope.optionsAttachCluster.primaryStorage = $scope.model.current;
                $scope.optionsDetachCluster.primaryStorage = $scope.model.current;
            });
        }
        Controller.$inject = ['$scope', 'PrimaryStorageManager', 'primaryStorageTypes', '$location'];
        return Controller;
    })();
    MPrimaryStorage.Controller = Controller;
    var CreatePrimaryStorageOptions = (function () {
        function CreatePrimaryStorageOptions() {
        }
        return CreatePrimaryStorageOptions;
    })();
    MPrimaryStorage.CreatePrimaryStorageOptions = CreatePrimaryStorageOptions;
    var CreatePrimaryStorage = (function () {
        function CreatePrimaryStorage(api, zoneMgr, psMgr, clusterMgr) {
            var _this = this;
            this.api = api;
            this.zoneMgr = zoneMgr;
            this.psMgr = psMgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreatePrimaryStorage;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreatePrimaryStorageOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                $scope.cephMonGrid__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            width: '20%',
                            title: '',
                            template: '<button type="button" class="btn btn-xs btn-default" ng-click="infoPage.delCephMon(dataItem.uid)"><i class="fa fa-times"></i></button>'
                        },
                        {
                            field: 'url',
                            title: '{{"primaryStorage.ts.MON URL" | translate}}',
                            width: '80%'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.total() == 0 || grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource([])
                };
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    zoneUuid: null,
                    description: null,
                    type: null,
                    url: null,
                    chapUsername: null,
                    chapPassword: null,
                    hostname: null,
                    sshUsername: 'root',
                    sshPassword: null,
                    cephMonUrls: [],
                    addCephMon: function () {
                        $scope.cephMonGrid__.dataSource.insert(0, { url: this.sshUsername + ":" + this.sshPassword + "@" + this.hostname });
                        this.hostname = null;
                        this.sshPassword = null;
                    },
                    canAddMon: function () {
                        return Utils.notNullnotUndefined(this.sshUsername) && Utils.notNullnotUndefined(this.hostname)
                            && Utils.notNullnotUndefined(this.sshPassword);
                    },
                    delCephMon: function (uid) {
                        var row = $scope.cephMonGrid__.dataSource.getByUid(uid);
                        $scope.cephMonGrid__.dataSource.remove(row);
                    },
                    hasZone: function () {
                        return $scope.zoneList.dataSource.data().length > 0;
                    },
                    isUrlValid: function () {
                        if (this.type == 'NFS' && Utils.notNullnotUndefined(this.url)) {
                            var paths = this.url.split(":");
                            if (paths.length != 2) {
                                return false;
                            }
                            var abspath = paths[1];
                            if (abspath.indexOf('/') != 0) {
                                return false;
                            }
                            return true;
                        }
                        else if (this.type == 'IscsiFileSystemBackendPrimaryStorage' || this.type == 'LocalStorage' && Utils.notNullnotUndefined(this.url)) {
                            if (this.url.indexOf('/') != 0) {
                                return false;
                            }
                            return true;
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        if (this.type == 'Ceph') {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.zoneUuid) &&
                                $scope.cephMonGrid__.dataSource.data().length > 0;
                        }
                        else {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.zoneUuid)
                                && Utils.notNullnotUndefined(this.type) && Utils.notNullnotUndefined(this.url) && this.isUrlValid();
                        }
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createPrimaryStorageInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createPrimaryStorageInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('ps');
                        this.zoneUuid = null;
                        this.description = null;
                        this.type = null;
                        this.activeState = false;
                        this.chapPassword = null;
                        this.chapUsername = null;
                        this.sshPassword = null;
                        this.sshUsername = 'root';
                        this.hostname = null;
                        this.cephMonUrls = [];
                    }
                };
                var clusterPage = $scope.clusterPage = {
                    activeState: false,
                    hasCluster: function () {
                        return $scope.clusterListOptions__.dataSource.data().length > 0;
                    },
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createPrimaryStorageCluster"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createPrimaryStorageCluster';
                    },
                    reset: function () {
                        this.activeState = false;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Add";
                    },
                    finish: function () {
                        var resultPs;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            angular.forEach($scope.cephMonGrid__.dataSource.data(), function (it) {
                                $scope.infoPage.cephMonUrls.push(it.url);
                            });
                            psMgr.create(infoPage, function (ret) {
                                resultPs = ret;
                                chain.next();
                            });
                        }).then(function () {
                            var clusters = $scope.clusterList__.dataItems();
                            angular.forEach(clusters, function (cluster) {
                                psMgr.attach(resultPs, cluster);
                            });
                            chain.next();
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultPs);
                            }
                        }).start();
                        $scope.winCreatePrimaryStorage__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage, clusterPage
                ], mediator);
                $scope.$watch(function () {
                    return $scope.infoPage.zoneUuid;
                }, function () {
                    if (Utils.notNullnotUndefined($scope.clusterList__)) {
                        $scope.clusterList__.value([]);
                    }
                    var zuuid = $scope.infoPage.zoneUuid;
                    if (Utils.notNullnotUndefined(zuuid)) {
                        _this.queryClusters(zuuid, function (clusters) {
                            $scope.clusterListOptions__.dataSource.data(clusters);
                        });
                    }
                });
                $scope.zoneList = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"primaryStorage.ts.Name" | translate}}</span>: #: name #</div>' + '<div style="color: black"><span class="z-label">State:</span>#: state #</div>' + '<div style="color: black"><span class="z-label">UUID:</span> #: uuid #</div>'
                };
                $scope.typeList = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "type",
                    dataValueField: "type",
                    change: function (e) {
                        var list = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.model.type = list.value();
                        });
                    }
                };
                $scope.winCreatePrimaryStorageOptions__ = {
                    width: '700px',
                    //height: '620px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.clusterListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"primaryStorage.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">HYPERVISOR:</span><span>#: hypervisorType #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>'
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/primaryStorage/createPrimaryStorage.html';
        }
        CreatePrimaryStorage.prototype.queryClusters = function (zoneUuid, done) {
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'zoneUuid',
                    op: '=',
                    value: zoneUuid
                }
            ];
            this.clusterMgr.query(qobj, function (clusters) {
                done(clusters);
            });
        };
        CreatePrimaryStorage.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreatePrimaryStorage__;
            var chain = new Utils.Chain();
            this.$scope.clusterList__.value([]);
            this.$scope.cephMonGrid__.dataSource.data([]);
            this.$scope.button.reset();
            chain.then(function () {
                if (Utils.notNullnotUndefined(_this.options.zone)) {
                    _this.$scope.zoneList.dataSource.data(new kendo.data.ObservableArray([_this.options.zone]));
                    _this.$scope.infoPage.zoneUuid = _this.options.zone.uuid;
                    chain.next();
                }
                else {
                    _this.zoneMgr.query(new ApiHeader.QueryObject(), function (zones, total) {
                        _this.$scope.zoneList.dataSource.data(zones);
                        if (zones.length > 0) {
                            _this.$scope.infoPage.zoneUuid = zones[0].uuid;
                        }
                        chain.next();
                    });
                }
            }).then(function () {
                _this.api.getPrimaryStorageTypes(function (psTypes) {
                    var types = [];
                    angular.forEach(psTypes, function (item) {
                        types.push({ type: item });
                    });
                    _this.$scope.typeList.dataSource.data(new kendo.data.ObservableArray(types));
                    _this.$scope.infoPage.type = psTypes[0];
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreatePrimaryStorage;
    })();
    MPrimaryStorage.CreatePrimaryStorage = CreatePrimaryStorage;
    var AttachCluster = (function () {
        function AttachCluster(clusterMgr, psMgr) {
            var _this = this;
            this.clusterMgr = clusterMgr;
            this.psMgr = psMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/primaryStorage/attachCluster.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zPrimaryStorageAttachCluster] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.clusterListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"primaryStorage.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasCluster = function () {
                    return $scope.clusterListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.attachCluster__.close();
                };
                $scope.done = function () {
                    var clusters = $scope.clusterList__.dataItems();
                    angular.forEach(clusters, function (cluster) {
                        psMgr.attach(_this.options.primaryStorage, cluster, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(cluster);
                            }
                        });
                    });
                    $scope.attachCluster__.close();
                };
                _this.$scope = $scope;
            };
        }
        AttachCluster.prototype.open = function () {
            var _this = this;
            this.$scope.clusterList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'not in',
                        value: _this.options.primaryStorage.attachedClusterUuids.join()
                    },
                    {
                        name: 'zoneUuid',
                        op: '=',
                        value: _this.options.primaryStorage.zoneUuid
                    }
                ];
                _this.clusterMgr.query(qobj, function (clusters) {
                    _this.$scope.clusterListOptions__.dataSource.data(clusters);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachCluster__.center();
                _this.$scope.attachCluster__.open();
            }).start();
        };
        return AttachCluster;
    })();
    MPrimaryStorage.AttachCluster = AttachCluster;
    var DetachClusterOptions = (function () {
        function DetachClusterOptions() {
        }
        return DetachClusterOptions;
    })();
    MPrimaryStorage.DetachClusterOptions = DetachClusterOptions;
    var DetachCluster = (function () {
        function DetachCluster(psMgr, clusterMgr) {
            var _this = this;
            this.psMgr = psMgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/primaryStorage/detachCluster.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zPrimaryStorageDetachCluster] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.clusterListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"primaryStorage.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">Hypervisor:</span><span>#: hypervisorType #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasCluster = function () {
                    return $scope.clusterListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.detachCluster__.close();
                };
                $scope.done = function () {
                    var clusters = $scope.clusterList__.dataItems();
                    angular.forEach(clusters, function (cluster) {
                        psMgr.detach(_this.options.primaryStorage, cluster, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(cluster);
                            }
                        });
                    });
                    $scope.detachCluster__.close();
                };
                $scope.detachClusterOptions__ = {
                    width: '600px'
                };
            };
        }
        DetachCluster.prototype.open = function () {
            var _this = this;
            this.$scope.clusterList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'in',
                        value: _this.options.primaryStorage.attachedClusterUuids.join()
                    }
                ];
                _this.clusterMgr.query(qobj, function (clusters) {
                    _this.$scope.clusterListOptions__.dataSource.data(clusters);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.detachCluster__.center();
                _this.$scope.detachCluster__.open();
            }).start();
        };
        return DetachCluster;
    })();
    MPrimaryStorage.DetachCluster = DetachCluster;
})(MPrimaryStorage || (MPrimaryStorage = {}));
angular.module('root').factory('PrimaryStorageManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MPrimaryStorage.PrimaryStorageManager(api, $rootScope);
    }]).directive('zCreatePrimaryStorage', ['Api', 'ZoneManager', 'PrimaryStorageManager', 'ClusterManager', function (api, zoneMgr, psMgr, clusterMgr) {
        return new MPrimaryStorage.CreatePrimaryStorage(api, zoneMgr, psMgr, clusterMgr);
    }]).directive('zPrimaryStorageAttachCluster', ['ClusterManager', 'PrimaryStorageManager', function (clusterMgr, psMgr) {
        return new MPrimaryStorage.AttachCluster(clusterMgr, psMgr);
    }]).directive('zPrimaryStorageDetachCluster', ['PrimaryStorageManager', 'ClusterManager', function (psMgr, clusterMgr) {
        return new MPrimaryStorage.DetachCluster(psMgr, clusterMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/primaryStorage', {
            templateUrl: '/static/templates/primaryStorage/primaryStorage.html',
            controller: 'MPrimaryStorage.Controller',
            resolve: {
                primaryStorageTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getPrimaryStorageTypes(function (psTypes) {
                        defer.resolve(psTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/primaryStorage/:uuid', {
            templateUrl: '/static/templates/primaryStorage/details.html',
            controller: 'MPrimaryStorage.DetailsController',
            resolve: {
                current: function ($q, $route, PrimaryStorageManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    PrimaryStorageManager.query(qobj, function (pss) {
                        var ps = pss[0];
                        defer.resolve(ps);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var ML2Network;
(function (ML2Network) {
    var L2Network = (function (_super) {
        __extends(L2Network, _super);
        function L2Network() {
            _super.apply(this, arguments);
        }
        L2Network.prototype.progressOn = function () {
            this.inProgress = true;
        };
        L2Network.prototype.progressOff = function () {
            this.inProgress = false;
        };
        L2Network.prototype.isInProgress = function () {
            return this.inProgress;
        };
        L2Network.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('zoneUuid', inv.zoneUuid);
            self.set('physicalInterface', inv.physicalInterface);
            self.set('type', inv.type);
            self.set('attachedClusterUuids', inv.attachedClusterUuids);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return L2Network;
    })(ApiHeader.L2NetworkInventory);
    ML2Network.L2Network = L2Network;
    var L2NetworkManager = (function () {
        function L2NetworkManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        L2NetworkManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        L2NetworkManager.prototype.wrap = function (l2) {
            return new kendo.data.ObservableObject(l2);
        };
        L2NetworkManager.prototype.create = function (l2, done) {
            var _this = this;
            var msg = null;
            if (l2.type == 'L2NoVlanNetwork') {
                msg = new ApiHeader.APICreateL2NoVlanNetworkMsg();
                msg.type = 'L2NoVlanNetwork';
            }
            else if (l2.type == 'L2VlanNetwork') {
                msg = new ApiHeader.APICreateL2VlanNetworkMsg();
                msg.type = 'L2VlanNetwork';
                msg.vlan = l2.vlan;
            }
            msg.name = l2.name;
            msg.description = l2.description;
            msg.zoneUuid = l2.zoneUuid;
            msg.physicalInterface = l2.physicalInterface;
            this.api.asyncApi(msg, function (ret) {
                var c = new L2Network();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new L2 Network: {0}', c.name),
                    link: Utils.sprintf('/#/l2Network/{0}', c.uuid)
                });
            });
        };
        L2NetworkManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryL2NetworkMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new L2Network();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        L2NetworkManager.prototype.attach = function (l2, cluster, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            l2.progressOn();
            var msg = new ApiHeader.APIAttachL2NetworkToClusterMsg();
            msg.clusterUuid = cluster.uuid;
            msg.l2NetworkUuid = l2.uuid;
            this.api.asyncApi(msg, function (ret) {
                l2.updateObservableObject(ret.inventory);
                l2.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached L2 Network: {0} to Cluster: {1}', l2.name, cluster.name),
                    link: Utils.sprintf('/#/l2Network/{0}', l2.uuid)
                });
            });
        };
        L2NetworkManager.prototype.detach = function (l2, cluster, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            l2.progressOn();
            var msg = new ApiHeader.APIDetachL2NetworkFromClusterMsg();
            msg.clusterUuid = cluster.uuid;
            msg.l2NetworkUuid = l2.uuid;
            this.api.asyncApi(msg, function (ret) {
                l2.updateObservableObject(ret.inventory);
                l2.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached L2 Network: {0} from Cluster: {1}', l2.name, cluster.name),
                    link: Utils.sprintf('/#/l2Network/{0}', l2.uuid)
                });
            });
        };
        L2NetworkManager.prototype.delete = function (l2, done) {
            var _this = this;
            l2.progressOn();
            var msg = new ApiHeader.APIDeleteL2NetworkMsg();
            msg.uuid = l2.uuid;
            this.api.asyncApi(msg, function (ret) {
                l2.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted L2 Network: {0}', l2.name)
                });
            });
        };
        L2NetworkManager.$inject = ['Api', '$rootScope'];
        return L2NetworkManager;
    })();
    ML2Network.L2NetworkManager = L2NetworkManager;
    var L2NetworkModel = (function (_super) {
        __extends(L2NetworkModel, _super);
        function L2NetworkModel() {
            _super.call(this);
            this.current = new L2Network();
        }
        return L2NetworkModel;
    })(Utils.Model);
    ML2Network.L2NetworkModel = L2NetworkModel;
    var OL2NetworkGrid = (function (_super) {
        __extends(OL2NetworkGrid, _super);
        function OL2NetworkGrid($scope, l2Mgr) {
            _super.call(this);
            this.l2Mgr = l2Mgr;
            _super.prototype.init.call(this, $scope, $scope.l2NetworkGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"l2Network.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/l2Network/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"l2Network.ts.DESCRIPTION" | translate}}',
                    width: '25%'
                },
                {
                    field: 'physicalInterface',
                    title: '{{"l2Network.ts.PHYSICAL INTERFACE" | translate}}',
                    width: '25%'
                },
                {
                    field: 'type',
                    title: '{{"l2Network.ts.TYPE" | translate}}',
                    width: '20%'
                },
                {
                    field: 'uuid',
                    title: '{{"l2Network.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                l2Mgr.query(qobj, function (l2s, total) {
                    options.success({
                        data: l2s,
                        total: total
                    });
                });
            };
        }
        return OL2NetworkGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, l2Mgr) {
            this.$scope = $scope;
            this.l2Mgr = l2Mgr;
        }
        Action.prototype.attachCluster = function () {
            this.$scope.attachCluster.open();
        };
        Action.prototype.detachCluster = function () {
            this.$scope.detachCluster.open();
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, l2Types) {
            var _this = this;
            this.$scope = $scope;
            this.l2Types = l2Types;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"l2Network.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"l2Network.ts.Type" | translate}}',
                            value: FilterBy.TYPE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(_this.l2Types);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oL2NetworkGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.TYPE = 'type';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, l2Mgr, $routeParams, tagService, current, clusterMgr) {
            var _this = this;
            this.$scope = $scope;
            this.l2Mgr = l2Mgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new L2NetworkModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, l2Mgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteL2Network = {
                title: 'DELETE L2 NETWORK',
                html: '<strong><p>Deleting L2 Network will cause:</p></strong>' +
                    '<ul><li><strong>Clusters to which this l2Network has attached will be detached</strong></li>' +
                    '<li><strong>l3Networks on this l2Network will be detached</strong></li>' +
                    '<li><strong>VMs whose nic on l3Network belonging to this l2Network will be stopped</strong></li></ul>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    l2Mgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeL2NetworkVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsAttachCluster = {
                l2Network: $scope.model.current,
                done: function (cluster) {
                    $scope.optionsClusterGrid.dataSource.insert(0, cluster);
                }
            };
            $scope.optionsDetachCluster = {
                l2Network: $scope.model.current,
                done: function (cluster) {
                    var ds = $scope.optionsClusterGrid.dataSource;
                    var cs = ds.data();
                    for (var i = 0; i < cs.length; i++) {
                        var tcs = cs[i];
                        if (cluster.uuid == tcs.uuid) {
                            var row = ds.getByUid(tcs.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
            $scope.funcLoadClusters = function () {
                $scope.optionsClusterGrid.dataSource.read();
            };
            $scope.optionsClusterGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"l2Network.ts.NAME" | translate}}',
                        width: '20%',
                        template: '<a href="/\\#/cluster/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"l2Network.ts.DESCRIPTION" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'state',
                        title: '{{"l2Network.ts.STATE" | translate}}',
                        width: '20%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'hypervisorType',
                        title: '{{"l2Network.ts.HYPERVISOR" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"l2Network.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined($scope.model.current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'uuid',
                                op: 'in',
                                value: $scope.model.current.attachedClusterUuids.join()
                            });
                            clusterMgr.query(qobj, function (clusters, total) {
                                options.success({
                                    data: clusters,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.l2Mgr.query(qobj, function (l2s, total) {
                _this.$scope.model.current = l2s[0];
            });
        };
        DetailsController.$inject = ['$scope', 'L2NetworkManager', '$routeParams', 'Tag', 'current', 'ClusterManager'];
        return DetailsController;
    })();
    ML2Network.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, l2Mgr, l2NetworkTypes, $location) {
            this.$scope = $scope;
            this.l2Mgr = l2Mgr;
            this.l2NetworkTypes = l2NetworkTypes;
            this.$location = $location;
            $scope.model = new L2NetworkModel();
            $scope.oL2NetworkGrid = new OL2NetworkGrid($scope, l2Mgr);
            $scope.action = new Action($scope, l2Mgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"l2Network.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"l2Network.ts.Description" | translate}}',
                        value: 'Description'
                    },
                    {
                        name: '{{"l2Network.ts.Physical Interface" | translate}}',
                        value: 'physicalInterface'
                    },
                    {
                        name: '{{"l2Network.ts.Type" | translate}}',
                        value: 'type'
                    },
                    {
                        name: '{{"l2Network.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"l2Network.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    l2Mgr.setSortBy(ret);
                    $scope.oL2NetworkGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.L2NetworkInventoryQueryable,
                name: 'L2Network',
                schema: {
                    type: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.l2NetworkTypes,
                        getQueryableFields: function (value) {
                            if (value == 'L2VlanNetwork') {
                                return ApiHeader.L2VlanNetworkInventoryQueryable;
                            }
                            else if (value == 'L2NoVlanNetwork') {
                                return ApiHeader.L2VlanNetworkInventoryQueryable;
                            }
                        },
                        removeCascade: {
                            type: ['vlan']
                        }
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    l2Mgr.query(qobj, function (l2s, total) {
                        $scope.oL2NetworkGrid.refresh(l2s);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/l2Network/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.l2NetworkTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateL2Network = function (win) {
                win.open();
            };
            $scope.funcDeleteL2Network = function () {
                $scope.deleteL2Network.open();
            };
            $scope.optionsDeleteL2Network = {
                title: 'DELETE L2 NETWORK',
                html: '<strong><p>Deleting L2 Network will cause:</p></strong>' +
                    '<ul><li><strong>Clusters to which this l2Network has attached will be detached</strong></li>' +
                    '<li><strong>l3Networks on this l2Network will be detached</strong></li>' +
                    '<li><strong>VMs whose nic on l3Network belonging to this l2Network will be stopped</strong></li></ul>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    l2Mgr.delete($scope.model.current, function (ret) {
                        $scope.oL2NetworkGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oL2NetworkGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateL2Network = {
                done: function (l2) {
                    $scope.oL2NetworkGrid.add(l2);
                }
            };
            $scope.optionsAttachCluster = {
                l2Network: $scope.model.current,
                done: function (cluster) {
                }
            };
            $scope.optionsDetachCluster = {
                l2Network: $scope.model.current,
                done: function (cluster) {
                }
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                $scope.optionsAttachCluster.l2Network = $scope.model.current;
                $scope.optionsDetachCluster.l2Network = $scope.model.current;
            });
        }
        Controller.$inject = ['$scope', 'L2NetworkManager', 'l2NetworkTypes', '$location'];
        return Controller;
    })();
    ML2Network.Controller = Controller;
    var CreateL2NetworkOptions = (function () {
        function CreateL2NetworkOptions() {
        }
        return CreateL2NetworkOptions;
    })();
    ML2Network.CreateL2NetworkOptions = CreateL2NetworkOptions;
    var CreateL2NetworkModel = (function () {
        function CreateL2NetworkModel() {
        }
        CreateL2NetworkModel.prototype.canCreate = function () {
            return angular.isDefined(this.name) && angular.isDefined(this.type) &&
                angular.isDefined(this.zoneUuid) && Utils.notNullnotUndefined(this.physicalInterface);
        };
        return CreateL2NetworkModel;
    })();
    ML2Network.CreateL2NetworkModel = CreateL2NetworkModel;
    var CreateL2Network = (function () {
        function CreateL2Network(api, zoneMgr, l2Mgr, clusterMgr) {
            var _this = this;
            this.api = api;
            this.zoneMgr = zoneMgr;
            this.l2Mgr = l2Mgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateL2Network;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateL2NetworkOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    zoneUuid: null,
                    description: null,
                    type: null,
                    physicalInterface: null,
                    vlan: null,
                    hasZone: function () {
                        return $scope.zoneList.dataSource.data().length > 0;
                    },
                    isVlanValid: function () {
                        if (this.type == 'L2VlanNetwork' && Utils.notNullnotUndefined(this.vlan)) {
                            if (isNaN(this.vlan)) {
                                return false;
                            }
                            var vlan = parseInt(this.vlan);
                            return vlan >= 0 && vlan <= 4095;
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        if (this.type == 'L2NoVlanNetwork') {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.zoneUuid)
                                && Utils.notNullnotUndefined(this.type) && Utils.notNullnotUndefined(this.physicalInterface);
                        }
                        else if (this.type == 'L2VlanNetwork') {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.zoneUuid)
                                && Utils.notNullnotUndefined(this.type) && Utils.notNullnotUndefined(this.physicalInterface)
                                && Utils.notNullnotUndefined(this.vlan) && this.isVlanValid();
                        }
                        else {
                            return false;
                        }
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createL2NetworkInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createL2NetworkInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('l2');
                        this.zoneUuid = null;
                        this.description = null;
                        this.type = null;
                        this.physicalInterface = null;
                        this.vlan = null;
                        this.activeState = false;
                    },
                    normalize: function () {
                        if (this.type == 'L2NoVlanNetwork') {
                            this.vlan = null;
                        }
                        else {
                            this.vlan = parseInt(this.vlan);
                        }
                    }
                };
                var clusterPage = $scope.clusterPage = {
                    activeState: false,
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createL2NetworkCluster"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createL2NetworkCluster';
                    },
                    reset: function () {
                        this.activeState = false;
                    },
                    hasCluster: function () {
                        return $scope.clusterListOptions__.dataSource.data().length > 0;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultPs;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            $scope.infoPage.normalize();
                            l2Mgr.create(infoPage, function (ret) {
                                resultPs = ret;
                                chain.next();
                            });
                        }).then(function () {
                            var clusters = $scope.clusterList__.dataItems();
                            angular.forEach(clusters, function (cluster) {
                                l2Mgr.attach(resultPs, cluster);
                            });
                            chain.next();
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultPs);
                            }
                        }).start();
                        $scope.winCreateL2Network__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage, clusterPage
                ], mediator);
                $scope.$watch(function () {
                    return $scope.infoPage.zoneUuid;
                }, function () {
                    if (Utils.notNullnotUndefined($scope.clusterList__)) {
                        $scope.clusterList__.value([]);
                    }
                    var zuuid = $scope.infoPage.zoneUuid;
                    if (Utils.notNullnotUndefined(zuuid)) {
                        _this.queryClusters(zuuid, function (clusters) {
                            $scope.clusterListOptions__.dataSource.data(clusters);
                        });
                    }
                });
                $scope.zoneList = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"l2Network.ts.Name" | translate}}</span>: #: name #</div>' + '<div style="color: black"><span class="z-label">{{"l2Network.ts.State" | translate}}:</span>#: state #</div>' + '<div style="color: black"><span class="z-label">{{"l2Network.ts.UUID" | translate}}:</span> #: uuid #</div>'
                };
                $scope.typeList = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "type",
                    dataValueField: "type",
                    change: function (e) {
                        var list = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.model.type = list.value();
                        });
                    }
                };
                $scope.winCreateL2NetworkOptions__ = {
                    width: '700px',
                    //height: '680px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.clusterListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">HYPERVISOR:</span><span>#: hypervisorType #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>'
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/l2Network/createL2Network.html';
        }
        CreateL2Network.prototype.queryClusters = function (zoneUuid, done) {
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'zoneUuid',
                    op: '=',
                    value: zoneUuid
                }
            ];
            this.clusterMgr.query(qobj, function (clusters) {
                done(clusters);
            });
        };
        CreateL2Network.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateL2Network__;
            var chain = new Utils.Chain();
            this.$scope.clusterList__.value([]);
            this.$scope.button.reset();
            chain.then(function () {
                if (Utils.notNullnotUndefined(_this.options.zone)) {
                    _this.$scope.zoneList.dataSource.data(new kendo.data.ObservableArray([_this.options.zone]));
                    _this.$scope.infoPage.zoneUuid = _this.options.zone.uuid;
                    chain.next();
                }
                else {
                    _this.zoneMgr.query(new ApiHeader.QueryObject(), function (zones, total) {
                        _this.$scope.zoneList.dataSource.data(zones);
                        if (zones && zones.length > 0) {
                            _this.$scope.infoPage.zoneUuid = zones[0].uuid;
                        }
                        chain.next();
                    });
                }
            }).then(function () {
                _this.api.getL2NetworkTypes(function (l2Types) {
                    var types = [];
                    angular.forEach(l2Types, function (item) {
                        types.push({ type: item });
                    });
                    _this.$scope.typeList.dataSource.data(new kendo.data.ObservableArray(types));
                    _this.$scope.infoPage.type = l2Types[0];
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreateL2Network;
    })();
    ML2Network.CreateL2Network = CreateL2Network;
    var AttachCluster = (function () {
        function AttachCluster(clusterMgr, l2Mgr) {
            var _this = this;
            this.clusterMgr = clusterMgr;
            this.l2Mgr = l2Mgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/l2Network/attachCluster.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zL2NetworkAttachCluster] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.clusterListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">HYPERVISOR:</span><span>#: hypervisorType #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.selectItemNum = 0;
                $scope.hasCluster = function () {
                    return $scope.clusterListOptions__.dataSource.data().length > 0;
                };
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.attachCluster__.close();
                };
                $scope.done = function () {
                    var clusters = $scope.clusterList__.dataItems();
                    angular.forEach(clusters, function (cluster) {
                        l2Mgr.attach(_this.options.l2Network, cluster, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(cluster);
                            }
                        });
                    });
                    $scope.attachCluster__.close();
                };
                _this.$scope = $scope;
            };
        }
        AttachCluster.prototype.open = function () {
            var _this = this;
            this.$scope.clusterList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'not in',
                        value: _this.options.l2Network.attachedClusterUuids.join()
                    },
                    {
                        name: 'zoneUuid',
                        op: '=',
                        value: _this.options.l2Network.zoneUuid
                    }
                ];
                _this.clusterMgr.query(qobj, function (clusters) {
                    _this.$scope.clusterListOptions__.dataSource.data(clusters);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachCluster__.center();
                _this.$scope.attachCluster__.open();
            }).start();
        };
        return AttachCluster;
    })();
    ML2Network.AttachCluster = AttachCluster;
    var DetachClusterOptions = (function () {
        function DetachClusterOptions() {
        }
        return DetachClusterOptions;
    })();
    ML2Network.DetachClusterOptions = DetachClusterOptions;
    var DetachCluster = (function () {
        function DetachCluster(l2Mgr, clusterMgr) {
            var _this = this;
            this.l2Mgr = l2Mgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/l2Network/detachCluster.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zL2NetworkDetachCluster] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.clusterListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">Hypervisor:</span><span>#: hypervisorType #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.selectItemNum = 0;
                $scope.hasCluster = function () {
                    return $scope.clusterListOptions__.dataSource.data().length > 0;
                };
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.detachCluster__.close();
                };
                $scope.done = function () {
                    var clusters = $scope.clusterList__.dataItems();
                    angular.forEach(clusters, function (cluster) {
                        l2Mgr.detach(_this.options.l2Network, cluster, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(cluster);
                            }
                        });
                    });
                    $scope.detachCluster__.close();
                };
                $scope.detachClusterOptions__ = {
                    width: '600px'
                };
            };
        }
        DetachCluster.prototype.open = function () {
            var _this = this;
            this.$scope.clusterList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'in',
                        value: _this.options.l2Network.attachedClusterUuids.join()
                    }
                ];
                _this.clusterMgr.query(qobj, function (clusters) {
                    _this.$scope.clusterListOptions__.dataSource.data(clusters);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.detachCluster__.center();
                _this.$scope.detachCluster__.open();
            }).start();
        };
        return DetachCluster;
    })();
    ML2Network.DetachCluster = DetachCluster;
})(ML2Network || (ML2Network = {}));
angular.module('root').factory('L2NetworkManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new ML2Network.L2NetworkManager(api, $rootScope);
    }]).directive('zCreateL2Network', ['Api', 'ZoneManager', 'L2NetworkManager', 'ClusterManager', function (api, zoneMgr, l2Mgr, clusterMgr) {
        return new ML2Network.CreateL2Network(api, zoneMgr, l2Mgr, clusterMgr);
    }]).directive('zL2NetworkAttachCluster', ['ClusterManager', 'L2NetworkManager', function (clusterMgr, l2Mgr) {
        return new ML2Network.AttachCluster(clusterMgr, l2Mgr);
    }]).directive('zL2NetworkDetachCluster', ['L2NetworkManager', 'ClusterManager', function (l2Mgr, clusterMgr) {
        return new ML2Network.DetachCluster(l2Mgr, clusterMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/l2Network', {
            templateUrl: '/static/templates/l2Network/l2Network.html',
            controller: 'ML2Network.Controller',
            resolve: {
                l2NetworkTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getL2NetworkTypes(function (l2Types) {
                        defer.resolve(l2Types);
                    });
                    return defer.promise;
                }
            }
        }).when('/l2Network/:uuid', {
            templateUrl: '/static/templates/l2Network/details.html',
            controller: 'ML2Network.DetailsController',
            resolve: {
                current: function ($q, $route, L2NetworkManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    L2NetworkManager.query(qobj, function (l2s) {
                        var l2 = l2s[0];
                        defer.resolve(l2);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var ML3Network;
(function (ML3Network) {
    var L3Network = (function (_super) {
        __extends(L3Network, _super);
        function L3Network() {
            _super.apply(this, arguments);
        }
        L3Network.prototype.progressOn = function () {
            this.inProgress = true;
        };
        L3Network.prototype.progressOff = function () {
            this.inProgress = false;
        };
        L3Network.prototype.isInProgress = function () {
            return this.inProgress;
        };
        L3Network.prototype.isEnableShow = function () {
            return this.state == 'Disabled' || this.state == 'Maintenance' || this.state == 'PreMaintenance';
        };
        L3Network.prototype.isDisableShow = function () {
            return this.state == 'Enabled' || this.state == 'Maintenance' || this.state == 'PreMaintenance';
        };
        L3Network.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        L3Network.prototype.systemLabel = function () {
            if (this.system) {
                return 'label label-primary';
            }
            return null;
        };
        L3Network.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('zoneUuid', inv.zoneUuid);
            self.set('l2NetworkUuid', inv.l2NetworkUuid);
            self.set('dnsDomain', inv.dnsDomain);
            self.set('type', inv.type);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
            self.set('dns', inv.dns);
            self.set('ipRanges', inv.ipRanges);
            self.set('system', inv.system);
            self.set('networkServices', inv.networkServices);
        };
        return L3Network;
    })(ApiHeader.L3NetworkInventory);
    ML3Network.L3Network = L3Network;
    var L3NetworkManager = (function () {
        function L3NetworkManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        L3NetworkManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        L3NetworkManager.prototype.wrap = function (l3) {
            return new kendo.data.ObservableObject(l3);
        };
        L3NetworkManager.prototype.disable = function (l3) {
            var _this = this;
            l3.progressOn();
            var msg = new ApiHeader.APIChangeL3NetworkStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = l3.uuid;
            this.api.asyncApi(msg, function (ret) {
                l3.updateObservableObject(ret.inventory);
                l3.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled L3Network: {0}', l3.name),
                    link: Utils.sprintf('/#/l3/{0}', l3.uuid)
                });
            });
        };
        L3NetworkManager.prototype.enable = function (l3) {
            var _this = this;
            l3.progressOn();
            var msg = new ApiHeader.APIChangeL3NetworkStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = l3.uuid;
            this.api.asyncApi(msg, function (ret) {
                l3.updateObservableObject(ret.inventory);
                l3.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled L3Network: {0}', l3.name),
                    link: Utils.sprintf('/#/l3/{0}', l3.uuid)
                });
            });
        };
        L3NetworkManager.prototype.queryNetworkServiceProvider = function (providerUuids, done) {
            var msg = new ApiHeader.APIQueryNetworkServiceProviderMsg();
            if (providerUuids.length != 0) {
                msg.conditions = [
                    {
                        name: 'uuid',
                        op: 'in',
                        value: providerUuids.join()
                    }
                ];
            }
            else {
                msg.conditions = [];
            }
            this.api.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        L3NetworkManager.prototype.addDns = function (l3, dns, done) {
            var _this = this;
            var msg = new ApiHeader.APIAddDnsToL3NetworkMsg();
            msg.dns = dns;
            msg.l3NetworkUuid = l3.uuid;
            this.api.asyncApi(msg, function (ret) {
                done();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Added DNS{0} to L3 Network: {1}', dns, l3.name),
                    link: Utils.sprintf('/#/l3Network/{0}', l3.uuid)
                });
            });
        };
        L3NetworkManager.prototype.deleteDns = function (l3, dns, done) {
            var _this = this;
            var msg = new ApiHeader.APIRemoveDnsFromL3NetworkMsg();
            msg.l3NetworkUuid = l3.uuid;
            msg.dns = dns;
            this.api.asyncApi(msg, function (ret) {
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Removed ip DNS{0} from L3 Network: {1}', dns, l3.name),
                    link: Utils.sprintf('/#/l3Network/{0}', l3.uuid)
                });
            });
        };
        L3NetworkManager.prototype.addIpRangeByCidr = function (l3, ipr, done) {
            var _this = this;
            var msg = new ApiHeader.APIAddIpRangeByNetworkCidrMsg();
            msg.l3NetworkUuid = l3.uuid;
            msg.name = ipr.name;
            msg.description = ipr.description;
            msg.networkCidr = ipr.networkCidr;
            this.api.asyncApi(msg, function (ret) {
                done(ret.inventory);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Add ip range to L3 Network: {0}', l3.name),
                    link: Utils.sprintf('/#/l3Network/{0}', l3.uuid)
                });
            });
        };
        L3NetworkManager.prototype.addIpRange = function (l3, ipr, done) {
            var _this = this;
            var msg = new ApiHeader.APIAddIpRangeMsg();
            msg.l3NetworkUuid = l3.uuid;
            msg.startIp = ipr.startIp;
            msg.endIp = ipr.endIp;
            msg.gateway = ipr.gateway;
            msg.netmask = ipr.netmask;
            msg.name = ipr.name;
            msg.description = ipr.description;
            this.api.asyncApi(msg, function (ret) {
                done(ret.inventory);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Add ip range to L3 Network: {0}', l3.name),
                    link: Utils.sprintf('/#/l3Network/{0}', l3.uuid)
                });
            });
        };
        L3NetworkManager.prototype.deleteIpRange = function (ipr, done) {
            var _this = this;
            var msg = new ApiHeader.APIDeleteIpRangeMsg();
            msg.uuid = ipr.uuid;
            this.api.asyncApi(msg, function (ret) {
                if (Utils.notNullnotUndefined(done)) {
                    done();
                    _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                        msg: Utils.sprintf('Deleted ip range: {0}', ipr.name),
                        link: Utils.sprintf('/#/l3Network/{0}', ipr.l3NetworkUuid)
                    });
                }
            });
        };
        L3NetworkManager.prototype.attachNetworkService = function (l3, ns, done) {
            var _this = this;
            var msg = new ApiHeader.APIAttachNetworkServiceToL3NetworkMsg();
            msg.l3NetworkUuid = l3.uuid;
            msg.networkServices = ns;
            this.api.asyncApi(msg, function (ret) {
                done();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached network services to L3 Network: {0}', l3.name),
                    link: Utils.sprintf('/#/l3Network/{0}', l3.uuid)
                });
            });
        };
        L3NetworkManager.prototype.create = function (l3, done) {
            var _this = this;
            var msg = null;
            msg = new ApiHeader.APICreateL3NetworkMsg();
            msg.type = 'L3BasicNetwork';
            msg.name = l3.name;
            msg.description = l3.description;
            msg.l2NetworkUuid = l3.l2NetworkUuid;
            msg.system = l3.system;
            msg.dnsDomain = l3.dnsDomain;
            this.api.asyncApi(msg, function (ret) {
                var c = new L3Network();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new L3 Network: {0}', c.name),
                    link: Utils.sprintf('/#/l3Network/{0}', c.uuid)
                });
            });
        };
        L3NetworkManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryL3NetworkMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new L3Network();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        L3NetworkManager.prototype.delete = function (l3, done) {
            var _this = this;
            l3.progressOn();
            var msg = new ApiHeader.APIDeleteL3NetworkMsg();
            msg.uuid = l3.uuid;
            this.api.asyncApi(msg, function (ret) {
                l3.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted L2 Network: {0}', l3.name)
                });
            });
        };
        L3NetworkManager.$inject = ['Api', '$rootScope'];
        return L3NetworkManager;
    })();
    ML3Network.L3NetworkManager = L3NetworkManager;
    var L3NetworkModel = (function (_super) {
        __extends(L3NetworkModel, _super);
        function L3NetworkModel() {
            _super.call(this);
            this.current = new L3Network();
        }
        return L3NetworkModel;
    })(Utils.Model);
    ML3Network.L3NetworkModel = L3NetworkModel;
    var OL3NetworkGrid = (function (_super) {
        __extends(OL3NetworkGrid, _super);
        function OL3NetworkGrid($scope, l3Mgr) {
            _super.call(this);
            this.l3Mgr = l3Mgr;
            _super.prototype.init.call(this, $scope, $scope.l3NetworkGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"l3Network.ts.NAME" | translate}}',
                    width: '15%',
                    template: '<a href="/\\#/l3Network/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"l3Network.ts.DESCRIPTION" | translate}}',
                    width: '20%'
                },
                {
                    field: 'state',
                    title: '{{"l3Network.ts.STATE" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'type',
                    title: '{{"l3Network.ts.TYPE" | translate}}',
                    width: '15%'
                },
                {
                    field: 'system',
                    title: '{{"l3Network.ts.SYSTEM NETWORK" | translate}}',
                    width: '15%',
                    template: '<span class="{{dataItem.systemLabel()}}">{{dataItem.system ? "TRUE" : "" }}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"l3Network.ts.UUID" | translate}}',
                    width: '25%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                l3Mgr.query(qobj, function (l3s, total) {
                    options.success({
                        data: l3s,
                        total: total
                    });
                });
            };
        }
        return OL3NetworkGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, l3Mgr) {
            this.$scope = $scope;
            this.l3Mgr = l3Mgr;
        }
        Action.prototype.enable = function () {
            this.l3Mgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.l3Mgr.disable(this.$scope.model.current);
        };
        Action.prototype.addIpRange = function () {
            this.$scope.winAddIpRange.open();
        };
        Action.prototype.deleteIpRange = function () {
            this.$scope.winDeleteIpRange.open();
        };
        Action.prototype.addDns = function () {
            this.$scope.winAddDns.open();
        };
        Action.prototype.deleteDns = function () {
            this.$scope.winDeleteDns.open();
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, l3Types) {
            var _this = this;
            this.$scope = $scope;
            this.l3Types = l3Types;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"l3Network.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"l3Network.ts.Type" | translate}}',
                            value: FilterBy.TYPE
                        },
                        {
                            name: '{{"l3Network.ts.State" | translate}}',
                            value: FilterBy.STATE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(_this.l3Types);
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oL3NetworkGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.TYPE = 'type';
        FilterBy.STATE = 'state';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, l3Mgr, $routeParams, tagService, current) {
            var _this = this;
            this.$scope = $scope;
            this.l3Mgr = l3Mgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new L3NetworkModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, l3Mgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteL3Network = {
                title: 'DELETE L3 NETWORK',
                html: '<strong><p>Deleting L2 Network will cause:</p></strong>' +
                    '<ul><li><strong>Ip ranges on this l3Network will be deleted</strong></li>' +
                    '<li><strong>DNS on this l3Network will be deleted</strong></li>' +
                    '<li><strong>Virtual Router on this l3Network will be deleted</strong></li>' +
                    '<li><strong>VMs whose nic belongs to this l3Network will be stopped</strong></li></ul>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    l3Mgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeL3NetworkVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsIpRangeGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"l3Network.ts.NAME" | translate}}',
                        width: '10%'
                    },
                    {
                        field: 'startIp',
                        title: '{{"l3Network.ts.START IP" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'endIp',
                        title: '{{"l3Network.ts.END IP" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'netmask',
                        title: '{{"l3Network.ts.NETMASK" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'gateway',
                        title: '{{"l3Network.ts.GATEWAY" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'networkCidr',
                        title: '{{"l3Network.ts.NETWORK CIDR" | translate}}',
                        width: '18%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource([])
            };
            $scope.optionsIpRangeGrid.dataSource.data(current.ipRanges);
            $scope.optionsDnsGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'dns',
                        title: '{{"l3Network.ts.UUID" | translate}}DNS',
                        width: '100%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource([])
            };
            var dns = [];
            angular.forEach(current.dns, function (it) {
                dns.push({
                    dns: it
                });
            });
            $scope.optionsDnsGrid.dataSource.data(dns);
            $scope.optionsNetworkServiceGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'service',
                        title: '{{"l3Network.ts.SERVICE" | translate}}',
                        width: '50%'
                    },
                    {
                        field: 'provider',
                        title: '{{"l3Network.ts.PROVIDER" | translate}}',
                        width: '50%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined(current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var providerUuids = [];
                            angular.forEach(current.networkServices, function (nws) {
                                providerUuids.push(nws.networkServiceProviderUuid);
                            });
                            l3Mgr.queryNetworkServiceProvider(providerUuids, function (providers) {
                                var names = {};
                                angular.forEach(providers, function (it) {
                                    names[it.uuid] = it;
                                });
                                var data = [];
                                angular.forEach(current.networkServices, function (it) {
                                    data.push({
                                        service: it.networkServiceType,
                                        provider: names[it.networkServiceProviderUuid].name
                                    });
                                });
                                options.success({
                                    data: data,
                                    total: data.length
                                });
                            });
                        }
                    }
                })
            };
            $scope.optionsAddDns = {
                l3Network: current,
                done: function (dns) {
                    $scope.optionsDnsGrid.dataSource.insert(0, { dns: dns });
                }
            };
            $scope.optionsAddIpRange = {
                l3Network: current,
                done: function (ipr) {
                    $scope.optionsIpRangeGrid.dataSource.insert(0, ipr);
                }
            };
            $scope.optionsDeleteIpRange = {
                l3Network: current,
                done: function (ipr) {
                    var ds = $scope.optionsIpRangeGrid.dataSource;
                    var cs = ds.data();
                    for (var i = 0; i < cs.length; i++) {
                        var tcs = cs[i];
                        if (ipr.uuid == tcs.uuid) {
                            var row = ds.getByUid(tcs.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
            $scope.optionsDeleteDns = {
                l3Network: current,
                done: function (dns) {
                    var ds = $scope.optionsDnsGrid.dataSource;
                    var cs = ds.data();
                    for (var i = 0; i < cs.length; i++) {
                        var tcs = cs[i];
                        if (dns == tcs.dns) {
                            var row = ds.getByUid(tcs.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.l3Mgr.query(qobj, function (l3s, total) {
                _this.$scope.model.current = l3s[0];
            });
        };
        DetailsController.$inject = ['$scope', 'L3NetworkManager', '$routeParams', 'Tag', 'current'];
        return DetailsController;
    })();
    ML3Network.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, l3Mgr, l3NetworkTypes, $location) {
            this.$scope = $scope;
            this.l3Mgr = l3Mgr;
            this.l3NetworkTypes = l3NetworkTypes;
            this.$location = $location;
            $scope.model = new L3NetworkModel();
            $scope.oL3NetworkGrid = new OL3NetworkGrid($scope, l3Mgr);
            $scope.action = new Action($scope, l3Mgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"l3Network.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"l3Network.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"l3Network.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"l3Network.ts.Type" | translate}}',
                        value: 'type'
                    },
                    {
                        name: '{{"l3Network.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"l3Network.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    l3Mgr.setSortBy(ret);
                    $scope.oL3NetworkGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.L3NetworkInventoryQueryable,
                name: 'L3Network',
                schema: {
                    type: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.l3NetworkTypes
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    l3Mgr.query(qobj, function (l3s, total) {
                        $scope.oL3NetworkGrid.refresh(l3s);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/l3Network/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.l3NetworkTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateL3Network = function (win) {
                win.open();
            };
            $scope.funcDeleteL3Network = function () {
                $scope.deleteL3Network.open();
            };
            $scope.optionsDeleteL3Network = {
                title: 'DELETE L3 NETWORK',
                html: '<strong><p>Deleting L2 Network will cause:</p></strong>' +
                    '<ul><li><strong>Ip ranges on this l3Network will be deleted</strong></li>' +
                    '<li><strong>DNS on this l3Network will be deleted</strong></li>' +
                    '<li><strong>Virtual Router on this l3Network will be deleted</strong></li>' +
                    '<li><strong>VMs whose nic belongs to this l3Network will be stopped</strong></li></ul>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    l3Mgr.delete($scope.model.current, function (ret) {
                        $scope.oL3NetworkGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oL3NetworkGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateL3Network = {
                done: function (l3) {
                    $scope.oL3NetworkGrid.add(l3);
                }
            };
            $scope.optionsAddIpRange = {
                l3Network: null
            };
            $scope.optionsDeleteIpRange = {
                l3Network: null
            };
            $scope.optionsAddDns = {
                l3Network: null,
                done: function (dns) {
                    $scope.model.current.dns.push(dns);
                }
            };
            $scope.optionsDeleteDns = {
                l3Network: null
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    $scope.optionsAddIpRange.l3Network = $scope.model.current;
                    $scope.optionsDeleteIpRange.l3Network = $scope.model.current;
                    $scope.optionsAddDns.l3Network = $scope.model.current;
                    $scope.optionsDeleteDns.l3Network = $scope.model.current;
                }
            });
        }
        Controller.$inject = ['$scope', 'L3NetworkManager', 'l3NetworkTypes', '$location'];
        return Controller;
    })();
    ML3Network.Controller = Controller;
    var AddDnsOptions = (function () {
        function AddDnsOptions() {
        }
        return AddDnsOptions;
    })();
    ML3Network.AddDnsOptions = AddDnsOptions;
    var AddDns = (function () {
        function AddDns(l3Mgr) {
            var _this = this;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zAddDns;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new AddDnsOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                $scope.optionsAddDns__ = {
                    width: 500
                };
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.dns);
                };
                $scope.cancel = function () {
                    $scope.addDns__.close();
                };
                $scope.done = function () {
                    l3Mgr.addDns(_this.options.l3Network, $scope.dns, function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done($scope.dns);
                        }
                    });
                    $scope.addDns__.close();
                };
                $scope.isDnsValid = function () {
                    if (Utils.notNullnotUndefined($scope.dns)) {
                        return Utils.isIpv4Address($scope.dns);
                    }
                    return true;
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/l3Network/addDns.html';
        }
        AddDns.prototype.open = function () {
            this.$scope.dns = null;
            this.$scope.addDns__.center();
            this.$scope.addDns__.open();
        };
        return AddDns;
    })();
    ML3Network.AddDns = AddDns;
    var AddIpRangeOptions = (function () {
        function AddIpRangeOptions() {
        }
        return AddIpRangeOptions;
    })();
    ML3Network.AddIpRangeOptions = AddIpRangeOptions;
    var AddIpRange = (function () {
        function AddIpRange(l3Mgr) {
            var _this = this;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zAddIpRange;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new AddIpRangeOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                $scope.info = {
                    name: null,
                    description: null,
                    startIp: null,
                    endIp: null,
                    gateway: null,
                    netmask: null,
                    method: 'cidr',
                    cidr: null
                };
                $scope.optionsAddIpRange__ = {
                    width: "500px"
                };
                $scope.methodOptions__ = {
                    dataSource: new kendo.data.DataSource({
                        data: [{
                                name: "Add By CIDR",
                                field: "cidr"
                            }, {
                                name: "Add By IP Range",
                                field: "range"
                            }]
                    }),
                    dataTextField: "name",
                    dataValueField: "field"
                };
                $scope.isNetworkCidrValid = function () {
                    if (Utils.notNullnotUndefined($scope.info.cidr)) {
                        return Utils.isValidCidr($scope.info.cidr);
                    }
                    return true;
                };
                $scope.canProceed = function () {
                    if ($scope.info.method == 'range') {
                        return Utils.notNullnotUndefined($scope.info.name) && Utils.notNullnotUndefined($scope.info.startIp)
                            && Utils.notNullnotUndefined($scope.info.endIp) && Utils.notNullnotUndefined($scope.info.netmask)
                            && Utils.notNullnotUndefined($scope.info.gateway) && $scope.isStartIpValid()
                            && $scope.isEndIpValid() && $scope.isNetmaskValid() && $scope.isGatewayValid();
                    }
                    else {
                        return Utils.notNullnotUndefined($scope.info.cidr) && $scope.isNetworkCidrValid();
                    }
                };
                $scope.cancel = function () {
                    $scope.addIpRange__.close();
                };
                $scope.done = function () {
                    if ($scope.info.method == 'range') {
                        l3Mgr.addIpRange(_this.options.l3Network, {
                            name: $scope.info.name,
                            description: $scope.info.description,
                            startIp: $scope.info.startIp,
                            endIp: $scope.info.endIp,
                            netmask: $scope.info.netmask,
                            gateway: $scope.info.gateway
                        }, function (ipr) {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(ipr);
                            }
                        });
                    }
                    else {
                        l3Mgr.addIpRangeByCidr(_this.options.l3Network, {
                            name: $scope.info.name,
                            description: $scope.info.description,
                            networkCidr: $scope.info.cidr
                        }, function (ipr) {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(ipr);
                            }
                        });
                    }
                    $scope.addIpRange__.close();
                };
                $scope.isStartIpValid = function () {
                    if (Utils.notNullnotUndefined($scope.info.startIp)) {
                        return Utils.isIpv4Address($scope.info.startIp);
                    }
                    return true;
                },
                    $scope.isEndIpValid = function () {
                        if (Utils.notNullnotUndefined($scope.info.endIp)) {
                            return Utils.isIpv4Address($scope.info.endIp);
                        }
                        return true;
                    },
                    $scope.isNetmaskValid = function () {
                        if (Utils.notNullnotUndefined($scope.info.netmask)) {
                            return Utils.isIpv4Address($scope.info.netmask);
                        }
                        return true;
                    },
                    $scope.isGatewayValid = function () {
                        if (Utils.notNullnotUndefined($scope.info.gateway)) {
                            return Utils.isIpv4Address($scope.info.gateway);
                        }
                        return true;
                    },
                    _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/l3Network/addIpRange.html';
        }
        AddIpRange.prototype.open = function () {
            this.$scope.info = {};
            this.$scope.info.startIp = null;
            this.$scope.info.description = null;
            this.$scope.info.name = Utils.shortHashName('ipr');
            this.$scope.info.endIp = null;
            this.$scope.info.netmask = null;
            this.$scope.info.gateway = null;
            this.$scope.info.method = 'cidr';
            this.$scope.info.cidr = null;
            this.$scope.addIpRange__.center();
            this.$scope.addIpRange__.open();
        };
        return AddIpRange;
    })();
    ML3Network.AddIpRange = AddIpRange;
    var CreateL3NetworkOptions = (function () {
        function CreateL3NetworkOptions() {
        }
        return CreateL3NetworkOptions;
    })();
    ML3Network.CreateL3NetworkOptions = CreateL3NetworkOptions;
    var CreateL3NetworkModel = (function () {
        function CreateL3NetworkModel() {
        }
        CreateL3NetworkModel.prototype.canCreate = function () {
            return angular.isDefined(this.name) && angular.isDefined(this.type) &&
                angular.isDefined(this.l2NetworkUuid);
        };
        return CreateL3NetworkModel;
    })();
    ML3Network.CreateL3NetworkModel = CreateL3NetworkModel;
    var CreateL3Network = (function () {
        function CreateL3Network(api, zoneMgr, l3Mgr, l2Mgr) {
            var _this = this;
            this.api = api;
            this.zoneMgr = zoneMgr;
            this.l3Mgr = l3Mgr;
            this.l2Mgr = l2Mgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateL3Network;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateL3NetworkOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    type: null,
                    l2NetworkUuid: null,
                    system: false,
                    dnsDomain: null,
                    hasL2Network: function () {
                        return $scope.optionsL2NetworkList__.dataSource.data().length > 0;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.l2NetworkUuid)
                            && Utils.notNullnotUndefined(this.type);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createL3NetworkInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createL3NetworkInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('l3');
                        this.l2NetworkUuid = null;
                        this.description = null;
                        this.type = null;
                        this.system = false;
                        this.activeState = false;
                        this.dnsDomain = null;
                    }
                };
                var ipRangePage = $scope.ipRangePage = {
                    activeState: false,
                    startIp: null,
                    endIp: null,
                    netmask: null,
                    gateway: null,
                    name: null,
                    description: null,
                    cidr: null,
                    method: 'cidr',
                    isStartIpValid: function () {
                        if (Utils.notNullnotUndefined(this.startIp)) {
                            return Utils.isIpv4Address(this.startIp);
                        }
                        return true;
                    },
                    isEndIpValid: function () {
                        if (Utils.notNullnotUndefined(this.endIp)) {
                            return Utils.isIpv4Address(this.endIp);
                        }
                        return true;
                    },
                    isNetmaskValid: function () {
                        if (Utils.notNullnotUndefined(this.netmask)) {
                            return Utils.isIpv4Address(this.netmask);
                        }
                        return true;
                    },
                    isGatewayValid: function () {
                        if (Utils.notNullnotUndefined(this.gateway)) {
                            return Utils.isIpv4Address(this.gateway);
                        }
                        return true;
                    },
                    isCidrValid: function () {
                        if (Utils.notNullnotUndefined(this.cidr)) {
                            return Utils.isValidCidr(this.cidr);
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createL3NetworkIpRange"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createL3NetworkIpRange';
                    },
                    reset: function () {
                        this.activeState = false;
                        this.startIp = null;
                        this.endIp = null;
                        this.netmask = null;
                        this.gateway = null;
                        this.name = Utils.shortHashName('ipr');
                        this.description = null;
                        this.method = 'cidr';
                        this.cidr = null;
                    },
                    add: function () {
                        $scope.optionsIpRangeGrid__.dataSource.insert(0, {
                            startIp: this.startIp,
                            endIp: this.endIp,
                            netmask: this.netmask,
                            gateway: this.gateway,
                            name: this.name,
                            description: this.description,
                            networkCidr: this.cidr
                        });
                        this.startIp = null;
                        this.endIp = null;
                        this.netmask = null;
                        this.gateway = null;
                        this.name = Utils.shortHashName('ipr');
                        this.description = null;
                        this.cidr = null;
                    },
                    canAdd: function () {
                        if (this.method == 'range') {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.startIp)
                                && Utils.notNullnotUndefined(this.endIp) && Utils.notNullnotUndefined(this.netmask)
                                && Utils.notNullnotUndefined(this.gateway) && this.isStartIpValid()
                                && this.isEndIpValid() && this.isNetmaskValid() && this.isGatewayValid();
                        }
                        else {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefinedNotEmptyString(this.cidr) && this.isCidrValid();
                        }
                    },
                    isGridShow: function () {
                        return $scope.optionsIpRangeGrid__.dataSource.data().length > 0;
                    },
                    del: function (uid) {
                        var row = $scope.optionsIpRangeGrid__.dataSource.getByUid(uid);
                        $scope.optionsIpRangeGrid__.dataSource.remove(row);
                    }
                };
                var dnsPage = $scope.dnsPage = {
                    activeState: false,
                    dns: null,
                    isDnsValid: function () {
                        if (Utils.notNullnotUndefined(this.dns)) {
                            return Utils.isIpv4Address(this.dns);
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createL3NetworkDns"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createL3NetworkDns';
                    },
                    reset: function () {
                        this.activeState = false;
                        this.dns = null;
                    },
                    add: function () {
                        $scope.optionsDnsGrid__.dataSource.insert(0, {
                            dns: this.dns
                        });
                        this.dns = null;
                    },
                    canAdd: function () {
                        return Utils.notNullnotUndefined(this.dns) && this.isDnsValid();
                    },
                    isGridShow: function () {
                        return $scope.optionsDnsGrid__.dataSource.data().length > 0;
                    },
                    del: function (uid) {
                        var row = $scope.optionsDnsGrid__.dataSource.getByUid(uid);
                        $scope.optionsDnsGrid__.dataSource.remove(row);
                    }
                };
                var self = _this;
                var servicePage = $scope.servicePage = {
                    activeState: false,
                    providerUuid: null,
                    serviceType: null,
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createL3NetworkService"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createL3NetworkService';
                    },
                    reset: function () {
                        this.activeState = false;
                    },
                    add: function () {
                        var pro = self.networkServiceProviders[this.providerUuid];
                        var data = $scope.optionsNetworkServiceGrid__.dataSource.data();
                        for (var i = 0; i < data.length; i++) {
                            var item = data[i];
                            if (item.providerUuid == this.providerUuid && item.serviceType == this.serviceType) {
                                return;
                            }
                        }
                        $scope.optionsNetworkServiceGrid__.dataSource.insert(0, {
                            providerName: pro.name,
                            providerUuid: pro.uuid,
                            serviceType: this.serviceType
                        });
                    },
                    canAdd: function () {
                        return Utils.notNullnotUndefined(this.providerUuid) && Utils.notNullnotUndefined(this.serviceType);
                    },
                    isGridShow: function () {
                        return $scope.optionsNetworkServiceGrid__.dataSource.data().length > 0;
                    },
                    del: function (uid) {
                        var row = $scope.optionsNetworkServiceGrid__.dataSource.getByUid(uid);
                        $scope.optionsNetworkServiceGrid__.dataSource.remove(row);
                    }
                };
                $scope.$watch(function () {
                    return $scope.servicePage.providerUuid;
                }, function () {
                    if (Utils.notNullnotUndefined($scope.servicePage.providerUuid)) {
                        var pro = _this.networkServiceProviders[$scope.servicePage.providerUuid];
                        if (Utils.notNullnotUndefined(pro)) {
                            $scope.optionsServiceList__.dataSource.data(pro.networkServiceTypes);
                        }
                    }
                });
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultL3;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            l3Mgr.create(infoPage, function (ret) {
                                resultL3 = ret;
                                chain.next();
                            });
                        }).then(function () {
                            var iprs = $scope.optionsIpRangeGrid__.dataSource.data();
                            if (iprs.length == 0) {
                                chain.next();
                                return;
                            }
                            var add = function () {
                                var ipr = iprs.shift();
                                if (!Utils.notNullnotUndefined(ipr)) {
                                    chain.next();
                                    return;
                                }
                                if (Utils.notNullnotUndefined(ipr.networkCidr)) {
                                    _this.l3Mgr.addIpRangeByCidr(resultL3, ipr, function () {
                                        add();
                                    });
                                }
                                else {
                                    _this.l3Mgr.addIpRange(resultL3, ipr, function () {
                                        add();
                                    });
                                }
                            };
                            add();
                        }).then(function () {
                            var dns = $scope.optionsDnsGrid__.dataSource.data();
                            if (dns.length == 0) {
                                chain.next();
                                return;
                            }
                            var add = function () {
                                var d = dns.shift();
                                if (!Utils.notNullnotUndefined(d)) {
                                    chain.next();
                                    return;
                                }
                                _this.l3Mgr.addDns(resultL3, d.dns, function () {
                                    add();
                                });
                            };
                            add();
                        }).then(function () {
                            var nws = $scope.optionsNetworkServiceGrid__.dataSource.data();
                            if (nws.length == 0) {
                                chain.next();
                                return;
                            }
                            var networkServices = {};
                            angular.forEach(nws, function (n) {
                                var providerUuid = n.providerUuid;
                                var services = networkServices[providerUuid];
                                if (!Utils.notNullnotUndefined(services)) {
                                    services = [];
                                    networkServices[providerUuid] = services;
                                }
                                services.push(n.serviceType);
                            });
                            _this.l3Mgr.attachNetworkService(resultL3, networkServices, function () {
                                chain.next();
                            });
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultL3);
                            }
                        }).start();
                        $scope.winCreateL3Network__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage, ipRangePage, dnsPage, servicePage
                ], mediator);
                $scope.$watch(function () {
                    return $scope.infoPage.zoneUuid;
                }, function () {
                    var zuuid = $scope.infoPage.zoneUuid;
                    if (Utils.notNullnotUndefined(zuuid)) {
                        _this.queryL2Networks(zuuid, function (l2s) {
                            $scope.optionsL2NetworkList__.dataSource.data(l2s);
                            var l2 = l2s[0];
                            if (Utils.notNullnotUndefined(l2)) {
                                $scope.infoPage.l2NetworkUuid = l2.uuid;
                            }
                        });
                    }
                });
                $scope.methodOptions__ = {
                    dataSource: new kendo.data.DataSource({
                        data: [{
                                name: "Add By CIDR",
                                field: "cidr"
                            }, {
                                name: "Add By IP Range",
                                field: "range"
                            }]
                    }),
                    dataTextField: "name",
                    dataValueField: "field"
                };
                $scope.optionsL2NetworkList__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"l3Network.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"l3Network.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"l3Network.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.optionsZoneList__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"l3Network.ts.Name" | translate}}</span>: #: name #</div>' + '<div style="color: black"><span class="z-label">{{"l3Network.ts.State" | translate}}:</span>#: state #</div>' + '<div style="color: black"><span class="z-label">{{"l3Network.ts.UUID" | translate}}:</span> #: uuid #</div>'
                };
                $scope.optionsL3NetworkTypeList__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "type",
                    dataValueField: "type"
                };
                $scope.optionsIpRangeGrid__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            width: '12%',
                            title: '',
                            template: '<button type="button" class="btn btn-xs btn-default" ng-click="ipRangePage.del(dataItem.uid)"><i class="fa fa-times"></i></button>'
                        },
                        {
                            field: 'networkCidr',
                            title: '{{"l3Network.ts.CIDR" | translate}}',
                            width: '22%'
                        },
                        {
                            field: 'startIp',
                            title: '{{"l3Network.ts.START IP" | translate}}',
                            width: '22%'
                        },
                        {
                            field: 'endIp',
                            title: '{{"l3Network.ts.END IP" | translate}}',
                            width: '22%'
                        },
                        {
                            field: 'gateway',
                            title: '{{"l3Network.ts.GATEWAY" | translate}}',
                            width: '22%'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource([])
                };
                $scope.optionsDnsGrid__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            field: 'dns',
                            title: '{{"l3Network.ts.DNS" | translate}}',
                            width: '80%'
                        },
                        {
                            width: '20%',
                            title: '',
                            template: '<button type="button" class="btn btn-xs btn-default" ng-click="dnsPage.del(dataItem.uid)"><i class="fa fa-times"></i></button>'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource([])
                };
                $scope.optionsProviderList__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid"
                };
                $scope.optionsServiceList__ = {
                    dataSource: new kendo.data.DataSource({ data: [] })
                };
                $scope.optionsNetworkServiceGrid__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            field: 'providerName',
                            title: '{{"l3Network.ts.PROVIDER" | translate}}',
                            width: '40%'
                        },
                        {
                            field: 'serviceType',
                            title: '{{"l3Network.ts.SERVICE" | translate}}',
                            width: '40%'
                        },
                        {
                            width: '10%',
                            title: '',
                            template: '<button type="button" class="btn btn-xs btn-default" ng-click="servicePage.del(dataItem.uid)"><i class="fa fa-times"></i></button>'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource([])
                };
                $scope.winCreateL3NetworkOptions__ = {
                    width: '800px',
                    //height: '680px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/l3Network/createL3Network.html';
        }
        CreateL3Network.prototype.queryL2Networks = function (zoneUuid, done) {
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'zoneUuid',
                    op: '=',
                    value: zoneUuid
                }
            ];
            this.l2Mgr.query(qobj, function (l2s) {
                done(l2s);
            });
        };
        CreateL3Network.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateL3Network__;
            var chain = new Utils.Chain();
            this.$scope.infoPage.zoneUuid = null;
            this.$scope.optionsL2NetworkList__.dataSource.data([]);
            this.$scope.optionsIpRangeGrid__.dataSource.data([]);
            this.$scope.button.reset();
            chain.then(function () {
                if (Utils.notNullnotUndefined(_this.options.zone)) {
                    _this.$scope.optionsZoneList__.dataSource.data(new kendo.data.ObservableArray([_this.options.zone]));
                    _this.$scope.infoPage.zoneUuid = _this.options.zone.uuid;
                    chain.next();
                }
                else {
                    _this.zoneMgr.query(new ApiHeader.QueryObject(), function (zones, total) {
                        _this.$scope.optionsZoneList__.dataSource.data(zones);
                        if (zones.length > 0) {
                            _this.$scope.infoPage.zoneUuid = zones[0].uuid;
                        }
                        chain.next();
                    });
                }
            }).then(function () {
                _this.api.getL3NetworkTypes(function (l3Types) {
                    var types = [];
                    angular.forEach(l3Types, function (item) {
                        types.push({ type: item });
                    });
                    _this.$scope.optionsL3NetworkTypeList__.dataSource.data(types);
                    _this.$scope.infoPage.type = l3Types[0];
                    chain.next();
                });
            }).then(function () {
                _this.l3Mgr.queryNetworkServiceProvider([], function (providers) {
                    _this.networkServiceProviders = {};
                    angular.forEach(providers, function (pro) {
                        _this.networkServiceProviders[pro.uuid] = pro;
                    });
                    _this.$scope.optionsProviderList__.dataSource.data(providers);
                    var cpro = providers[0];
                    _this.$scope.optionsServiceList__.dataSource.data(cpro.networkServiceTypes);
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreateL3Network;
    })();
    ML3Network.CreateL3Network = CreateL3Network;
    var DeleteIpRangeOptions = (function () {
        function DeleteIpRangeOptions() {
        }
        return DeleteIpRangeOptions;
    })();
    ML3Network.DeleteIpRangeOptions = DeleteIpRangeOptions;
    var DeleteIpRange = (function () {
        function DeleteIpRange(l3Mgr) {
            var _this = this;
            this.l3Mgr = l3Mgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/l3Network/deleteIpRange.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zDeleteIpRange] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.ipRangeListOptions__ = {
                    dataSource: new kendo.data.DataSource([]),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">Start IP:</span><span>#: startIp #</span></div>' +
                        '<div style="color: black"><span class="z-label">End IP:</span><span>#: endIp #</span></div>' +
                        '<div style="color: black"><span class="z-label">Netmask:</span><span>#: netmask #</span></div>' +
                        '<div style="color: black"><span class="z-label">Gateway:</span><span>#: gateway #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.deleteIpRange__.close();
                };
                $scope.done = function () {
                    var iprs = $scope.ipRangeList__.dataItems();
                    angular.forEach(iprs, function (ipr) {
                        l3Mgr.deleteIpRange(ipr, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(ipr);
                            }
                        });
                    });
                    $scope.deleteIpRange__.close();
                };
                $scope.deleteIpRangeOptions__ = {
                    width: '550px'
                };
            };
        }
        DeleteIpRange.prototype.open = function () {
            this.$scope.ipRangeListOptions__.dataSource.data(this.options.l3Network.ipRanges);
            this.$scope.deleteIpRange__.center();
            this.$scope.deleteIpRange__.open();
        };
        return DeleteIpRange;
    })();
    ML3Network.DeleteIpRange = DeleteIpRange;
    var DeleteDnsOptions = (function () {
        function DeleteDnsOptions() {
        }
        return DeleteDnsOptions;
    })();
    ML3Network.DeleteDnsOptions = DeleteDnsOptions;
    var DeleteDns = (function () {
        function DeleteDns(l3Mgr) {
            var _this = this;
            this.l3Mgr = l3Mgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/l3Network/deleteDns.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zDeleteDns] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.dnsOptions__ = {
                    dataSource: new kendo.data.DataSource([]),
                    dataTextField: "dns",
                    dataValueField: "dns",
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.deleteDns__.close();
                };
                $scope.done = function () {
                    var dnss = $scope.dnsList__.dataItems();
                    angular.forEach(dnss, function (it) {
                        l3Mgr.deleteDns(_this.options.l3Network, it.dns, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(it.dns);
                            }
                        });
                    });
                    $scope.deleteDns__.close();
                };
                $scope.deleteDnsOptions__ = {
                    width: '550px'
                };
            };
        }
        DeleteDns.prototype.open = function () {
            var _this = this;
            this.$scope.dnsOptions__.dataSource.data((function () {
                var dns = [];
                angular.forEach(_this.options.l3Network.dns, function (it) {
                    dns.push({ dns: it });
                });
                return dns;
            })());
            this.$scope.deleteDns__.center();
            this.$scope.deleteDns__.open();
        };
        return DeleteDns;
    })();
    ML3Network.DeleteDns = DeleteDns;
})(ML3Network || (ML3Network = {}));
angular.module('root').factory('L3NetworkManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new ML3Network.L3NetworkManager(api, $rootScope);
    }]).directive('zCreateL3Network', ['Api', 'ZoneManager', 'L3NetworkManager', 'L2NetworkManager', function (api, zoneMgr, l3Mgr, l2Mgr) {
        return new ML3Network.CreateL3Network(api, zoneMgr, l3Mgr, l2Mgr);
    }]).directive('zAddIpRange', ['L3NetworkManager', function (l3Mgr) {
        return new ML3Network.AddIpRange(l3Mgr);
    }]).directive('zDeleteIpRange', ['L3NetworkManager', function (l3Mgr) {
        return new ML3Network.DeleteIpRange(l3Mgr);
    }]).directive('zAddDns', ['L3NetworkManager', function (l3Mgr) {
        return new ML3Network.AddDns(l3Mgr);
    }]).directive('zDeleteDns', ['L3NetworkManager', function (l3Mgr) {
        return new ML3Network.DeleteDns(l3Mgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/l3Network', {
            templateUrl: '/static/templates/l3Network/l3Network.html',
            controller: 'ML3Network.Controller',
            resolve: {
                l3NetworkTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getL3NetworkTypes(function (l3Types) {
                        defer.resolve(l3Types);
                    });
                    return defer.promise;
                }
            }
        }).when('/l3Network/:uuid', {
            templateUrl: '/static/templates/l3Network/details.html',
            controller: 'ML3Network.DetailsController',
            resolve: {
                current: function ($q, $route, L3NetworkManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    L3NetworkManager.query(qobj, function (l3s) {
                        var l3 = l3s[0];
                        defer.resolve(l3);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MBackupStorage;
(function (MBackupStorage) {
    var BackupStorage = (function (_super) {
        __extends(BackupStorage, _super);
        function BackupStorage() {
            _super.apply(this, arguments);
        }
        BackupStorage.prototype.progressOn = function () {
            this.inProgress = true;
        };
        BackupStorage.prototype.progressOff = function () {
            this.inProgress = false;
        };
        BackupStorage.prototype.isInProgress = function () {
            return this.inProgress;
        };
        BackupStorage.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        BackupStorage.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        BackupStorage.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        BackupStorage.prototype.statusLabel = function () {
            if (this.status == 'Connected') {
                return 'label label-success';
            }
            else if (this.status == 'Disconnected') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        BackupStorage.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('url', inv.url);
            self.set('totalCapacity', inv.totalCapacity);
            self.set('availableCapacity', inv.availableCapacity);
            self.set('type', inv.type);
            self.set('state', inv.state);
            self.set('status', inv.status);
            self.set('attachedZoneUuids', inv.attachedZoneUuids);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return BackupStorage;
    })(ApiHeader.BackupStorageInventory);
    MBackupStorage.BackupStorage = BackupStorage;
    var BackupStorageManager = (function () {
        function BackupStorageManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        BackupStorageManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        BackupStorageManager.prototype.wrap = function (bs) {
            return new kendo.data.ObservableObject(bs);
        };
        BackupStorageManager.prototype.create = function (bs, done) {
            var _this = this;
            var msg = null;
            if (bs.type == 'SftpBackupStorage') {
                msg = new ApiHeader.APIAddSftpBackupStorageMsg();
                msg.hostname = bs.hostname;
                msg.username = bs.username;
                msg.password = bs.password;
                msg.type = 'SftpBackupStorage';
            }
            else if (bs.type == 'SimulatorBackupStorage') {
                msg = new ApiHeader.APIAddSimulatorBackupStorageMsg();
                msg.type = 'SimulatorBackupStorage';
            }
            else if (bs.type == 'Ceph') {
                msg = new ApiHeader.APIAddCephBackupStorageMsg();
                msg.monUrls = bs.cephMonUrls;
            }
            if (Utils.notNullnotUndefined(bs.resourceUuid)) {
                msg.resourceUuid = bs.resourceUuid;
            }
            msg.name = bs.name;
            msg.description = bs.description;
            msg.url = bs.url;
            this.api.asyncApi(msg, function (ret) {
                var c = new BackupStorage();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new Backup Storage: {0}', c.name),
                    link: Utils.sprintf('/#/backupStorage/{0}', c.uuid)
                });
            });
        };
        BackupStorageManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryBackupStorageMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new BackupStorage();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        BackupStorageManager.prototype.disable = function (bs) {
            var _this = this;
            bs.progressOn();
            var msg = new ApiHeader.APIChangeBackupStorageStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = bs.uuid;
            this.api.asyncApi(msg, function (ret) {
                bs.updateObservableObject(ret.inventory);
                bs.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Backup Storage: {0}', bs.name),
                    link: Utils.sprintf('/#/backupStorage/{0}', bs.uuid)
                });
            });
        };
        BackupStorageManager.prototype.enable = function (bs) {
            var _this = this;
            bs.progressOn();
            var msg = new ApiHeader.APIChangeBackupStorageStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = bs.uuid;
            this.api.asyncApi(msg, function (ret) {
                bs.updateObservableObject(ret.inventory);
                bs.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled Backup Storage: {0}', bs.name),
                    link: Utils.sprintf('/#/backupStorage/{0}', bs.uuid)
                });
            });
        };
        BackupStorageManager.prototype.attach = function (bs, zone, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            bs.progressOn();
            var msg = new ApiHeader.APIAttachBackupStorageToZoneMsg();
            msg.zoneUuid = zone.uuid;
            msg.backupStorageUuid = bs.uuid;
            this.api.asyncApi(msg, function (ret) {
                bs.updateObservableObject(ret.inventory);
                bs.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached Backup Storage: {0} to Zone: {1}', bs.name, zone.name),
                    link: Utils.sprintf('/#/backupStorage/{0}', bs.uuid)
                });
            });
        };
        BackupStorageManager.prototype.detach = function (bs, zone, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            bs.progressOn();
            var msg = new ApiHeader.APIDetachBackupStorageFromZoneMsg();
            msg.zoneUuid = zone.uuid;
            msg.backupStorageUuid = bs.uuid;
            this.api.asyncApi(msg, function (ret) {
                bs.updateObservableObject(ret.inventory);
                bs.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached Backup Storage: {0} from zone: {1}', bs.name, zone.name),
                    link: Utils.sprintf('/#/backupStorage/{0}', bs.uuid)
                });
            });
        };
        BackupStorageManager.prototype.reconnect = function (bs, done) {
            var _this = this;
            if (done === void 0) { done = null; }
            if (bs.type != 'SftpBackupStorage') {
                return;
            }
            bs.progressOn();
            var msg = new ApiHeader.APIReconnectSftpBackupStorageMsg();
            msg.uuid = bs.uuid;
            bs.status = 'Connecting';
            this.api.asyncApi(msg, function (ret) {
                bs.updateObservableObject(ret.inventory);
                bs.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Reconnected SFtp Backup Storage: {0}', bs.name),
                    link: Utils.sprintf('/#/backupStorage/{0}', bs.uuid)
                });
            });
        };
        BackupStorageManager.prototype.delete = function (bs, done) {
            var _this = this;
            bs.progressOn();
            var msg = new ApiHeader.APIDeleteBackupStorageMsg();
            msg.uuid = bs.uuid;
            this.api.asyncApi(msg, function (ret) {
                bs.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted Backup Storage: {0}', bs.name)
                });
            });
        };
        BackupStorageManager.$inject = ['Api', '$rootScope'];
        return BackupStorageManager;
    })();
    MBackupStorage.BackupStorageManager = BackupStorageManager;
    var BackupStorageModel = (function (_super) {
        __extends(BackupStorageModel, _super);
        function BackupStorageModel() {
            _super.call(this);
            this.current = new BackupStorage();
        }
        return BackupStorageModel;
    })(Utils.Model);
    MBackupStorage.BackupStorageModel = BackupStorageModel;
    var OBackupStorageGrid = (function (_super) {
        __extends(OBackupStorageGrid, _super);
        function OBackupStorageGrid($scope, bsMgr) {
            _super.call(this);
            this.bsMgr = bsMgr;
            _super.prototype.init.call(this, $scope, $scope.backupStorageGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"backupStorage.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/backupStorage/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"backupStorage.ts.DESCRIPTION" | translate}}',
                    width: '10%'
                },
                {
                    field: 'url',
                    title: '{{"backupStorage.ts.URL" | translate}}',
                    width: '16%'
                },
                {
                    field: 'totalCapacity',
                    title: '{{"backupStorage.ts.TOTAL CAPACITY" | translate}}',
                    width: '8%',
                    template: '<span>{{dataItem.totalCapacity | size}}</span>'
                },
                {
                    field: 'availableCapacity',
                    title: '{{"backupStorage.ts.AVAILABLE CAPACITY" | translate}}',
                    width: '8%',
                    template: '<span>{{dataItem.availableCapacity | size}}</span>'
                },
                {
                    field: 'type',
                    title: '{{"backupStorage.ts.TYPE" | translate}}',
                    width: '10%'
                },
                {
                    field: 'state',
                    title: '{{"backupStorage.ts.STATE" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'status',
                    title: '{{"backupStorage.ts.STATUS" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.statusLabel()}}">{{dataItem.status}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"backupStorage.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                bsMgr.query(qobj, function (bss, total) {
                    options.success({
                        data: bss,
                        total: total
                    });
                });
            };
        }
        return OBackupStorageGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, bsMgr) {
            this.$scope = $scope;
            this.bsMgr = bsMgr;
        }
        Action.prototype.enable = function () {
            this.bsMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.bsMgr.disable(this.$scope.model.current);
        };
        Action.prototype.reconnect = function () {
            this.bsMgr.reconnect(this.$scope.model.current);
        };
        Action.prototype.addHost = function () {
        };
        Action.prototype.attachL2Network = function () {
        };
        Action.prototype.detachL2Network = function () {
        };
        Action.prototype.attachZone = function () {
            this.$scope.attachZone.open();
        };
        Action.prototype.detachZone = function () {
            this.$scope.detachZone.open();
        };
        Action.prototype.isReconnectShow = function () {
            if (!Utils.notNullnotUndefined(this.$scope.model.current)) {
                return false;
            }
            return this.$scope.model.current.type == 'SftpBackupStorage';
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, bsTypes) {
            var _this = this;
            this.$scope = $scope;
            this.bsTypes = bsTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"backupStorage.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"backupStorage.ts.State" | translate}}',
                            value: FilterBy.STATE
                        },
                        {
                            name: '{{"backupStorage.ts.Status" | translate}}',
                            value: FilterBy.STATUS
                        },
                        {
                            name: '{{"backupStorage.ts.Type" | translate}}',
                            value: FilterBy.TYPE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
                else if (_this.field == FilterBy.STATUS) {
                    _this.valueList.dataSource.data(['Connecting', 'Connected', 'Disconnected']);
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(_this.bsTypes);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oBackupStorageGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        FilterBy.STATUS = 'status';
        FilterBy.TYPE = 'type';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, bsMgr, $routeParams, tagService, current, zoneMgr) {
            var _this = this;
            this.$scope = $scope;
            this.bsMgr = bsMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new BackupStorageModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, bsMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteBackupStorage = {
                title: 'DELETE BACKUP STORAGE',
                html: '<strong><p>Deleting Backup Storage will cause:</p></strong>' +
                    '<ul><li><strong>Zones to which this backup storage has attached will be detached</strong></li>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    bsMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeBackupStorageVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsAttachZone = {
                backupStorage: $scope.model.current,
                done: function (zone) {
                    $scope.optionsZoneGrid.dataSource.insert(0, zone);
                }
            };
            $scope.optionsDetachZone = {
                backupStorage: $scope.model.current,
                done: function (zone) {
                    var ds = $scope.optionsZoneGrid.dataSource;
                    var cs = ds.data();
                    for (var i = 0; i < cs.length; i++) {
                        var tcs = cs[i];
                        if (zone.uuid == tcs.uuid) {
                            var row = ds.getByUid(tcs.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
            $scope.funcLoadZones = function () {
                $scope.optionsZoneGrid.dataSource.read();
            };
            $scope.optionsZoneGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"backupStorage.ts.NAME" | translate}}',
                        width: '25%',
                        template: '<a href="/\\#/zone/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"backupStorage.ts.DESCRIPTION" | translate}}',
                        width: '30%'
                    },
                    {
                        field: 'state',
                        title: '{{"backupStorage.ts.STATE" | translate}}',
                        width: '20%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'uuid',
                        title: '{{"backupStorage.ts.UUID" | translate}}',
                        width: '25%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            if (!Utils.notNullnotUndefined($scope.model.current.uuid)) {
                                options.success({
                                    data: [],
                                    total: 0
                                });
                                return;
                            }
                            var qobj = new ApiHeader.QueryObject();
                            qobj.limit = options.data.take;
                            qobj.start = options.data.pageSize * (options.data.page - 1);
                            qobj.addCondition({
                                name: 'uuid',
                                op: 'in',
                                value: $scope.model.current.attachedZoneUuids.join()
                            });
                            zoneMgr.query(qobj, function (zones, total) {
                                options.success({
                                    data: zones,
                                    total: total
                                });
                            });
                        }
                    }
                })
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.bsMgr.query(qobj, function (bss, total) {
                _this.$scope.model.current = bss[0];
            });
        };
        DetailsController.$inject = ['$scope', 'BackupStorageManager', '$routeParams', 'Tag', 'current', 'ZoneManager'];
        return DetailsController;
    })();
    MBackupStorage.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, bsMgr, backupStorageTypes, $location) {
            this.$scope = $scope;
            this.bsMgr = bsMgr;
            this.backupStorageTypes = backupStorageTypes;
            this.$location = $location;
            $scope.model = new BackupStorageModel();
            $scope.oBackupStorageGrid = new OBackupStorageGrid($scope, bsMgr);
            $scope.action = new Action($scope, bsMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"backupStorage.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"backupStorage.ts.Description" | translate}}',
                        value: 'Description'
                    },
                    {
                        name: '{{"backupStorage.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"backupStorage.ts.Status" | translate}}',
                        value: 'status'
                    },
                    {
                        name: '{{"backupStorage.ts.Total Capacity" | translate}}',
                        value: 'totalCapacity'
                    },
                    {
                        name: '{{"backupStorage.ts.Available Capacity" | translate}}',
                        value: 'availableCapacity'
                    },
                    {
                        name: '{{"backupStorage.ts.Type" | translate}}',
                        value: 'type'
                    },
                    {
                        name: '{{"backupStorage.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"backupStorage.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    bsMgr.setSortBy(ret);
                    $scope.oBackupStorageGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.BackupStorageInventoryQueryable,
                name: 'BackupStorage',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    status: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Connecting', 'Connected', 'Disconnected']
                    },
                    type: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.backupStorageTypes
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    bsMgr.query(qobj, function (BackupStorages, total) {
                        $scope.oBackupStorageGrid.refresh(BackupStorages);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/backupStorage/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.backupStorageTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateBackupStorage = function (win) {
                win.open();
            };
            $scope.funcDeleteBackupStorage = function () {
                $scope.deleteBackupStorage.open();
            };
            $scope.optionsDeleteBackupStorage = {
                title: 'DELETE BACKUP STORAGE',
                html: '<strong><p>Deleting Backup Storage will cause:</p></strong>' +
                    '<ul><li><strong>Zones to which this backup storage has attached will be detached</strong></li>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    bsMgr.delete($scope.model.current, function (ret) {
                        $scope.oBackupStorageGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oBackupStorageGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateBackupStorage = {
                done: function (data) {
                    var resultBs;
                    var chain = new Utils.Chain();
                    chain.then(function () {
                        var placeHolder = new BackupStorage();
                        placeHolder.name = data.info.name;
                        placeHolder.uuid = data.info.resourceUuid = Utils.uuid();
                        placeHolder.state = 'Enabled';
                        placeHolder.status = 'Connecting';
                        $scope.oBackupStorageGrid.add(placeHolder);
                        bsMgr.create(data.info, function (ret) {
                            resultBs = ret;
                            chain.next();
                        });
                    }).then(function () {
                        angular.forEach(data.zones, function (zone) {
                            bsMgr.attach(resultBs, zone);
                        });
                        chain.next();
                    }).done(function () {
                        $scope.oBackupStorageGrid.refresh();
                    }).start();
                }
            };
            $scope.optionsAttachZone = {
                backupStorage: $scope.model.current,
                done: function (zone) {
                }
            };
            $scope.optionsDetachZone = {
                backupStorage: $scope.model.current,
                done: function (zone) {
                }
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                $scope.optionsAttachZone.backupStorage = $scope.model.current;
                $scope.optionsDetachZone.backupStorage = $scope.model.current;
            });
        }
        Controller.$inject = ['$scope', 'BackupStorageManager', 'backupStorageTypes', '$location'];
        return Controller;
    })();
    MBackupStorage.Controller = Controller;
    var CreateBackupStorageOptions = (function () {
        function CreateBackupStorageOptions() {
        }
        return CreateBackupStorageOptions;
    })();
    MBackupStorage.CreateBackupStorageOptions = CreateBackupStorageOptions;
    var CreateBackupStorageModel = (function () {
        function CreateBackupStorageModel() {
        }
        CreateBackupStorageModel.prototype.canCreate = function () {
            return angular.isDefined(this.name) && angular.isDefined(this.type) &&
                Utils.notNullnotUndefined(this.url);
        };
        return CreateBackupStorageModel;
    })();
    MBackupStorage.CreateBackupStorageModel = CreateBackupStorageModel;
    var CreateBackupStorage = (function () {
        function CreateBackupStorage(api, bsMgr, zoneMgr) {
            var _this = this;
            this.api = api;
            this.bsMgr = bsMgr;
            this.zoneMgr = zoneMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateBackupStorage;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateBackupStorageOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                $scope.cephMonGrid__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            width: '20%',
                            title: '',
                            template: '<button type="button" class="btn btn-xs btn-default" ng-click="infoPage.delCephMon(dataItem.uid)"><i class="fa fa-times"></i></button>'
                        },
                        {
                            field: 'url',
                            title: '{{"backupStorage.ts.MON URL" | translate}}',
                            width: '80%'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.total() == 0 || grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource([])
                };
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    type: null,
                    url: null,
                    hostname: null,
                    username: 'root',
                    password: null,
                    cephMonUrls: [],
                    isUrlValid: function () {
                        if (this.type == 'SftpBackupStorage' && Utils.notNullnotUndefined(this.url)) {
                            return this.url.indexOf('/') == 0;
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        if (this.type == 'SftpBackupStorage') {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.type)
                                && Utils.notNullnotUndefined(this.url) && Utils.notNullnotUndefined(this.hostname)
                                && Utils.notNullnotUndefined(this.username) && Utils.notNullnotUndefined(this.password)
                                && this.isUrlValid();
                        }
                        else if (this.type == 'Ceph') {
                            return $scope.cephMonGrid__.dataSource.data().length > 0;
                        }
                        else {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.type)
                                && Utils.notNullnotUndefined(this.url);
                        }
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createBackupStorageInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createBackupStorageInfo';
                    },
                    addCephMon: function () {
                        $scope.cephMonGrid__.dataSource.insert(0, { url: this.username + ":" + this.password + "@" + this.hostname });
                        this.hostname = null;
                        this.password = null;
                    },
                    canAddMon: function () {
                        return Utils.notNullnotUndefined(this.username) && Utils.notNullnotUndefined(this.hostname)
                            && Utils.notNullnotUndefined(this.password);
                    },
                    delCephMon: function (uid) {
                        var row = $scope.cephMonGrid__.dataSource.getByUid(uid);
                        $scope.cephMonGrid__.dataSource.remove(row);
                    },
                    reset: function () {
                        this.name = Utils.shortHashName("bs");
                        this.description = null;
                        this.type = null;
                        this.hostname = null;
                        this.username = 'root';
                        this.password = null;
                        this.url = null;
                        this.activeState = false;
                        this.cephMonUrls = [];
                    }
                };
                var zonePage = $scope.zonePage = {
                    activeState: false,
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createBackupStorageZone"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createBackupStorageZone';
                    },
                    reset: function () {
                        this.activeState = false;
                    },
                    hasZone: function () {
                        return $scope.zoneListOptions__.dataSource.data().length > 0;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Add";
                    },
                    finish: function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            angular.forEach($scope.cephMonGrid__.dataSource.data(), function (it) {
                                $scope.infoPage.cephMonUrls.push(it.url);
                            });
                            _this.options.done({
                                info: infoPage,
                                zones: $scope.zoneList__.dataItems()
                            });
                        }
                        $scope.winCreateBackupStorage__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage, zonePage
                ], mediator);
                $scope.typeList = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "type",
                    dataValueField: "type",
                    change: function (e) {
                        var list = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.model.type = list.value();
                        });
                    }
                };
                $scope.winCreateBackupStorageOptions__ = {
                    width: '750px',
                    //height: '780px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.zoneListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"backupStorage.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">Type:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">URL:</span><span>#: url #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>'
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/backupStorage/createBackupStorage.html';
        }
        CreateBackupStorage.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateBackupStorage__;
            var chain = new Utils.Chain();
            this.$scope.zoneList__.value([]);
            this.$scope.button.reset();
            this.$scope.cephMonGrid__.dataSource.data([]);
            chain.then(function () {
                _this.api.getBackupStorageTypes(function (bsTypes) {
                    var types = [];
                    angular.forEach(bsTypes, function (item) {
                        types.push({ type: item });
                    });
                    _this.$scope.typeList.dataSource.data(new kendo.data.ObservableArray(types));
                    _this.$scope.infoPage.type = bsTypes[0];
                    chain.next();
                });
            }).then(function () {
                if (Utils.notNullnotUndefined(_this.options.zone)) {
                    _this.$scope.zoneListOptions__.dataSource.data(new kendo.data.ObservableArray([_this.options.zone]));
                    chain.next();
                }
                else {
                    _this.zoneMgr.query(new ApiHeader.QueryObject(), function (zones, total) {
                        _this.$scope.zoneListOptions__.dataSource.data(zones);
                        chain.next();
                    });
                }
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreateBackupStorage;
    })();
    MBackupStorage.CreateBackupStorage = CreateBackupStorage;
    var AttachZone = (function () {
        function AttachZone(zoneMgr, bsMgr) {
            var _this = this;
            this.zoneMgr = zoneMgr;
            this.bsMgr = bsMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/backupStorage/attachZone.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zBackupStorageAttachZone] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.zoneListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"backupStorage.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.attachZone__.close();
                };
                $scope.done = function () {
                    var zones = $scope.zoneList__.dataItems();
                    angular.forEach(zones, function (zone) {
                        bsMgr.attach(_this.options.backupStorage, zone, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(zone);
                            }
                        });
                    });
                    $scope.attachZone__.close();
                };
                _this.$scope = $scope;
            };
        }
        AttachZone.prototype.open = function () {
            var _this = this;
            this.$scope.zoneList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'not in',
                        value: _this.options.backupStorage.attachedZoneUuids.join()
                    }
                ];
                _this.zoneMgr.query(qobj, function (zones) {
                    _this.$scope.zoneListOptions__.dataSource.data(zones);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachZone__.center();
                _this.$scope.attachZone__.open();
            }).start();
        };
        return AttachZone;
    })();
    MBackupStorage.AttachZone = AttachZone;
    var DetachZoneOptions = (function () {
        function DetachZoneOptions() {
        }
        return DetachZoneOptions;
    })();
    MBackupStorage.DetachZoneOptions = DetachZoneOptions;
    var DetachZone = (function () {
        function DetachZone(bsMgr, zoneMgr) {
            var _this = this;
            this.bsMgr = bsMgr;
            this.zoneMgr = zoneMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/backupStorage/detachZone.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zBackupStorageDetachZone] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.zoneListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"backupStorage.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.detachZone__.close();
                };
                $scope.done = function () {
                    var zones = $scope.zoneList__.dataItems();
                    angular.forEach(zones, function (zone) {
                        bsMgr.detach(_this.options.backupStorage, zone, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(zone);
                            }
                        });
                    });
                    $scope.detachZone__.close();
                };
                $scope.detachZoneOptions__ = {
                    width: '600px'
                };
            };
        }
        DetachZone.prototype.open = function () {
            var _this = this;
            this.$scope.zoneList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'in',
                        value: _this.options.backupStorage.attachedZoneUuids.join()
                    }
                ];
                _this.zoneMgr.query(qobj, function (zones) {
                    _this.$scope.zoneListOptions__.dataSource.data(zones);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.detachZone__.center();
                _this.$scope.detachZone__.open();
            }).start();
        };
        return DetachZone;
    })();
    MBackupStorage.DetachZone = DetachZone;
})(MBackupStorage || (MBackupStorage = {}));
angular.module('root').factory('BackupStorageManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MBackupStorage.BackupStorageManager(api, $rootScope);
    }]).directive('zCreateBackupStorage', ['Api', 'BackupStorageManager', 'ZoneManager', function (api, bsMgr, zoneMgr) {
        return new MBackupStorage.CreateBackupStorage(api, bsMgr, zoneMgr);
    }]).directive('zBackupStorageAttachZone', ['ZoneManager', 'BackupStorageManager', function (zoneMgr, bsMgr) {
        return new MBackupStorage.AttachZone(zoneMgr, bsMgr);
    }]).directive('zBackupStorageDetachZone', ['BackupStorageManager', 'ZoneManager', function (bsMgr, zoneMgr) {
        return new MBackupStorage.DetachZone(bsMgr, zoneMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/backupStorage', {
            templateUrl: '/static/templates/backupStorage/backupStorage.html',
            controller: 'MBackupStorage.Controller',
            resolve: {
                backupStorageTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getBackupStorageTypes(function (bsTypes) {
                        defer.resolve(bsTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/backupStorage/:uuid', {
            templateUrl: '/static/templates/backupStorage/details.html',
            controller: 'MBackupStorage.DetailsController',
            resolve: {
                current: function ($q, $route, BackupStorageManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    BackupStorageManager.query(qobj, function (bss) {
                        var bs = bss[0];
                        defer.resolve(bs);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MHost;
(function (MHost) {
    var Host = (function (_super) {
        __extends(Host, _super);
        function Host() {
            _super.apply(this, arguments);
        }
        Host.prototype.progressOn = function () {
            this.inProgress = true;
        };
        Host.prototype.progressOff = function () {
            this.inProgress = false;
        };
        Host.prototype.isInProgress = function () {
            return this.inProgress;
        };
        Host.prototype.isEnableShow = function () {
            return this.state == 'Disabled' || this.state == 'Maintenance' || this.state == 'PreMaintenance';
        };
        Host.prototype.isDisableShow = function () {
            return this.state == 'Enabled' || this.state == 'Maintenance' || this.state == 'PreMaintenance';
        };
        Host.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        Host.prototype.statusLabel = function () {
            if (this.status == 'Connected') {
                return 'label label-success';
            }
            else if (this.status == 'Disconnected') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        Host.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('zoneUuid', inv.zoneUuid);
            self.set('hypervisorType', inv.hypervisorType);
            self.set('managementIp', inv.managementIp);
            self.set('state', inv.state);
            self.set('clusterUuid', inv.clusterUuid);
            self.set('zoneUuid', inv.zoneUuid);
            self.set('status', inv.status);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return Host;
    })(ApiHeader.HostInventory);
    MHost.Host = Host;
    var HostManager = (function () {
        function HostManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        HostManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        HostManager.prototype.wrap = function (Host) {
            return new kendo.data.ObservableObject(Host);
        };
        HostManager.prototype.create = function (host, done) {
            var _this = this;
            var msg = null;
            if (host.hypervisorType == 'KVM') {
                msg = new ApiHeader.APIAddKVMHostMsg();
                msg.username = host.username;
                msg.password = host.password;
            }
            else if (host.hypervisorType == 'Simulator') {
                msg = new ApiHeader.APIAddSimulatorHostMsg();
            }
            msg.name = host.name;
            msg.description = host.description;
            msg.clusterUuid = host.clusterUuid;
            msg.managementIp = host.managementIp;
            this.api.asyncApi(msg, function (ret) {
                var c = new Host();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Added new Host: {0}', c.name),
                    link: Utils.sprintf('/#/host/{0}', c.uuid)
                });
            });
        };
        HostManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryHostMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new Host();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        HostManager.prototype.disable = function (host) {
            var _this = this;
            host.progressOn();
            var msg = new ApiHeader.APIChangeHostStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = host.uuid;
            this.api.asyncApi(msg, function (ret) {
                host.updateObservableObject(ret.inventory);
                host.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Host: {0}', host.name),
                    link: Utils.sprintf('/#/host/{0}', host.uuid)
                });
            });
        };
        HostManager.prototype.enable = function (host) {
            var _this = this;
            host.progressOn();
            var msg = new ApiHeader.APIChangeHostStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = host.uuid;
            this.api.asyncApi(msg, function (ret) {
                host.updateObservableObject(ret.inventory);
                host.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled Host: {0}', host.name),
                    link: Utils.sprintf('/#/host/{0}', host.uuid)
                });
            });
        };
        HostManager.prototype.maintain = function (host) {
            var _this = this;
            host.progressOn();
            var msg = new ApiHeader.APIChangeHostStateMsg();
            msg.stateEvent = 'maintain';
            msg.uuid = host.uuid;
            this.api.asyncApi(msg, function (ret) {
                host.updateObservableObject(ret.inventory);
                host.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Put Host into maintenance mode: {0}', host.name),
                    link: Utils.sprintf('/#/host/{0}', host.uuid)
                });
            }, function () {
                host.progressOff();
            });
        };
        HostManager.prototype.reconnect = function (host) {
            var _this = this;
            host.progressOn();
            var msg = new ApiHeader.APIReconnectHostMsg();
            msg.uuid = host.uuid;
            host.status = 'Connecting';
            this.api.asyncApi(msg, function (ret) {
                host.updateObservableObject(ret.inventory);
                host.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Reconnected Host: {0}', host.name),
                    link: Utils.sprintf('/#/host/{0}', host.uuid)
                });
            });
        };
        HostManager.prototype.delete = function (host, done) {
            var _this = this;
            host.progressOn();
            var msg = new ApiHeader.APIDeleteHostMsg();
            msg.uuid = host.uuid;
            this.api.asyncApi(msg, function (ret) {
                host.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted Host: {0}', host.name)
                });
            });
        };
        HostManager.$inject = ['Api', '$rootScope'];
        return HostManager;
    })();
    MHost.HostManager = HostManager;
    var HostModel = (function (_super) {
        __extends(HostModel, _super);
        function HostModel() {
            _super.call(this);
            this.current = new Host();
        }
        return HostModel;
    })(Utils.Model);
    MHost.HostModel = HostModel;
    var OHostGrid = (function (_super) {
        __extends(OHostGrid, _super);
        function OHostGrid($scope, hostMgr) {
            _super.call(this);
            this.hostMgr = hostMgr;
            _super.prototype.init.call(this, $scope, $scope.hostGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"host.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/host/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"host.ts.DESCRIPTION" | translate}}',
                    width: '20%'
                },
                {
                    field: 'managementIp',
                    title: '{{"host.ts.MANAGEMENT IP" | translate}}',
                    width: '15%'
                },
                {
                    field: 'hypervisorType',
                    title: '{{"host.ts.HYPERVISOR" | translate}}',
                    width: '15%'
                },
                {
                    field: 'state',
                    title: '{{"host.ts.STATE" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'status',
                    title: '{{"host.ts.STATUS" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.statusLabel()}}">{{dataItem.status}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"host.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                hostMgr.query(qobj, function (hosts, total) {
                    options.success({
                        data: hosts,
                        total: total
                    });
                });
            };
        }
        return OHostGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, hostMgr) {
            this.$scope = $scope;
            this.hostMgr = hostMgr;
        }
        Action.prototype.enable = function () {
            this.hostMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.hostMgr.disable(this.$scope.model.current);
        };
        Action.prototype.reconnect = function () {
            this.hostMgr.reconnect(this.$scope.model.current);
        };
        Action.prototype.maintain = function () {
            this.hostMgr.maintain(this.$scope.model.current);
        };
        Action.prototype.isMaintainShow = function () {
            if (Utils.notNullnotUndefined(this.$scope.model.current)) {
                return this.$scope.model.current.state != 'PreMaintenance' && this.$scope.model.current.state != 'Maintenance';
            }
            else {
                return false;
            }
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, hypervisorTypes) {
            var _this = this;
            this.$scope = $scope;
            this.hypervisorTypes = hypervisorTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"host.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"host.ts.State" | translate}}',
                            value: FilterBy.STATE
                        },
                        {
                            name: '{{"host.ts.Status" | translate}}',
                            value: FilterBy.STATUS
                        },
                        {
                            name: '{{"host.ts.HypervisorType" | translate}}',
                            value: FilterBy.TYPE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATUS) {
                    _this.valueList.dataSource.data(['Connecting', 'Connected', 'Disconnected']);
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled', 'PreMaintenance', 'Maintenance']);
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(_this.hypervisorTypes);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oHostGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        FilterBy.STATUS = 'status';
        FilterBy.TYPE = 'hypervisorType';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, hostMgr, $routeParams, tagService, current, clusterMgr, api) {
            var _this = this;
            this.$scope = $scope;
            this.hostMgr = hostMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.api = api;
            $scope.model = new HostModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, hostMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteHost = {
                title: 'DELETE HOST',
                description: "Deleting Host will cause all VMs on this host being stopped",
                confirm: function () {
                    hostMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeHostVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.systemTags = [];
            this.api.getSystemTags('HostVO', current.uuid, function (tags) {
                $scope.systemTags = tags;
            });
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.hostMgr.query(qobj, function (hosts, total) {
                _this.$scope.model.current = hosts[0];
            });
        };
        DetailsController.$inject = ['$scope', 'HostManager', '$routeParams', 'Tag', 'current', 'ClusterManager', 'Api'];
        return DetailsController;
    })();
    MHost.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, hostMgr, hypervisorTypes, $location) {
            this.$scope = $scope;
            this.hostMgr = hostMgr;
            this.hypervisorTypes = hypervisorTypes;
            this.$location = $location;
            $scope.model = new HostModel();
            $scope.oHostGrid = new OHostGrid($scope, hostMgr);
            $scope.action = new Action($scope, hostMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"host.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"host.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"host.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"host.ts.Status" | translate}}',
                        value: 'status'
                    },
                    {
                        name: '{{"host.ts.Hypervisor" | translate}}',
                        value: 'hypervisorType'
                    },
                    {
                        name: '{{"host.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"host.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    hostMgr.setSortBy(ret);
                    $scope.oHostGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.HostInventoryQueryable,
                name: 'Host',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled', 'PreMaintenance', 'Maintenance']
                    },
                    status: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Connecting', 'Connected', 'Disconnected']
                    },
                    hypervisorType: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.hypervisorTypes
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    hostMgr.query(qobj, function (Hosts, total) {
                        $scope.oHostGrid.refresh(Hosts);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/host/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.hypervisorTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateHost = function (win) {
                win.open();
            };
            $scope.funcDeleteHost = function () {
                $scope.deleteHost.open();
            };
            $scope.optionsDeleteHost = {
                title: 'DELETE HOST',
                description: "Deleting Host will cause all VMs on this host being stopped",
                confirm: function () {
                    hostMgr.delete($scope.model.current, function (ret) {
                        $scope.oHostGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oHostGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateHost = {
                done: function (infoPage) {
                    infoPage.uuid = infoPage.resourceUuid = Utils.uuid();
                    infoPage.state = 'Enabled';
                    infoPage.status = 'Connecting';
                    var host = new Host();
                    angular.extend(host, infoPage);
                    $scope.oHostGrid.add(host);
                    hostMgr.create(infoPage, function (ret) {
                        $scope.oHostGrid.refresh();
                    });
                }
            };
        }
        Controller.$inject = ['$scope', 'HostManager', 'hypervisorTypes', '$location'];
        return Controller;
    })();
    MHost.Controller = Controller;
    var CreateHostOptions = (function () {
        function CreateHostOptions() {
        }
        return CreateHostOptions;
    })();
    MHost.CreateHostOptions = CreateHostOptions;
    var CreateHostModel = (function () {
        function CreateHostModel() {
        }
        CreateHostModel.prototype.canCreate = function () {
            if (this.hypervisorType == 'KVM') {
                return angular.isDefined(this.name) && angular.isDefined(this.description) &&
                    angular.isDefined(this.clusterUuid) && Utils.notNullnotUndefined(this.managementIp) &&
                    Utils.notNullnotUndefined(this.username) && Utils.notNullnotUndefined(this.password);
            }
            else {
                return angular.isDefined(this.name) && angular.isDefined(this.description) &&
                    angular.isDefined(this.clusterUuid) && Utils.notNullnotUndefined(this.managementIp);
            }
        };
        return CreateHostModel;
    })();
    MHost.CreateHostModel = CreateHostModel;
    var CreateHost = (function () {
        function CreateHost(api, zoneMgr, hostMgr, clusterMgr) {
            var _this = this;
            this.api = api;
            this.zoneMgr = zoneMgr;
            this.hostMgr = hostMgr;
            this.clusterMgr = clusterMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateHost;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateHostOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    clusterUuid: null,
                    description: null,
                    hypervisorType: null,
                    managementIp: null,
                    username: 'root',
                    password: null,
                    canMoveToPrevious: function () {
                        return false;
                    },
                    hasCluster: function () {
                        return $scope.clusterListOptions__.dataSource.data().length > 0;
                    },
                    canMoveToNext: function () {
                        if (this.hypervisorType == 'KVM') {
                            return Utils.notNullnotUndefined(this.name)
                                && Utils.notNullnotUndefined(this.clusterUuid) && Utils.notNullnotUndefined(this.managementIp) &&
                                Utils.notNullnotUndefined(this.username) && Utils.notNullnotUndefined(this.password);
                        }
                        else {
                            return Utils.notNullnotUndefined(this.name)
                                && Utils.notNullnotUndefined(this.clusterUuid) && Utils.notNullnotUndefined(this.managementIp);
                        }
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createHostInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createHostInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('host');
                        this.clusterUuid = null;
                        this.description = null;
                        this.hypervisorType = null;
                        this.username = 'root';
                        this.password = null;
                        this.managementIp = null;
                        this.activeState = false;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Add";
                    },
                    finish: function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done($scope.infoPage);
                        }
                        $scope.winCreateHost__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage
                ], mediator);
                $scope.$watch(function () {
                    return $scope.infoPage.zoneUuid;
                }, function () {
                    var zuuid = $scope.infoPage.zoneUuid;
                    if (Utils.notNullnotUndefined(zuuid)) {
                        _this.queryClusters(zuuid, function (clusters) {
                            $scope.clusterListOptions__.dataSource.data(clusters);
                            var c = clusters[0];
                            if (Utils.notNullnotUndefined(c)) {
                                $scope.infoPage.hypervisorType = c.hypervisorType;
                            }
                        });
                    }
                });
                $scope.zoneList = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"host.ts.Name" | translate}}</span>: #: name #</div>' + '<div style="color: black"><span class="z-label">{{"host.ts.State" | translate}}</span>#: state #</div>' + '<div style="color: black"><span class="z-label">{{"host.ts.UUID" | translate}}</span> #: uuid #</div>'
                };
                $scope.winCreateHostOptions__ = {
                    width: '700px',
                    //height: '620px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.clusterListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"host.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"host.ts.HYPERVISOR" | translate}}</span><span>#: hypervisorType #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"host.ts.UUID" | translate}}</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var list = e.sender;
                        var cluster = list.dataItem();
                        Utils.safeApply($scope, function () {
                            $scope.infoPage.hypervisorType = cluster.hypervisorType;
                        });
                    }
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/host/createHost.html';
        }
        CreateHost.prototype.queryClusters = function (zoneUuid, done) {
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'zoneUuid',
                    op: '=',
                    value: zoneUuid
                }
            ];
            this.clusterMgr.query(qobj, function (clusters) {
                done(clusters);
            });
        };
        CreateHost.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateHost__;
            var chain = new Utils.Chain();
            this.$scope.clusterListOptions__.dataSource.data([]);
            this.$scope.button.reset();
            chain.then(function () {
                if (Utils.notNullnotUndefined(_this.options.zone)) {
                    _this.$scope.zoneList.dataSource.data(new kendo.data.ObservableArray([_this.options.zone]));
                    _this.$scope.infoPage.zoneUuid = _this.options.zone.uuid;
                    chain.next();
                }
                else {
                    _this.zoneMgr.query(new ApiHeader.QueryObject(), function (zones, total) {
                        _this.$scope.zoneList.dataSource.data(zones);
                        if (zones) {
                            _this.$scope.infoPage.zoneUuid = zones[0].uuid;
                        }
                        chain.next();
                    });
                }
            }).then(function () {
                if (Utils.notNullnotUndefined(_this.$scope.infoPage.zoneUuid)) {
                    _this.queryClusters(_this.$scope.infoPage.zoneUuid, function (clusters) {
                        _this.$scope.clusterListOptions__.dataSource.data(clusters);
                        var c = clusters[0];
                        if (Utils.notNullnotUndefined(c)) {
                            _this.$scope.infoPage.hypervisorType = c.hypervisorType;
                        }
                        chain.next();
                    });
                }
                else {
                    chain.next();
                }
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreateHost;
    })();
    MHost.CreateHost = CreateHost;
})(MHost || (MHost = {}));
angular.module('root').factory('HostManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MHost.HostManager(api, $rootScope);
    }]).directive('zCreateHost', ['Api', 'ZoneManager', 'HostManager', 'ClusterManager', function (api, zoneMgr, hostMgr, clusterMgr) {
        return new MHost.CreateHost(api, zoneMgr, hostMgr, clusterMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/host', {
            templateUrl: '/static/templates/host/host.html',
            controller: 'MHost.Controller',
            resolve: {
                hypervisorTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getHypervisorTypes(function (hypervisorTypes) {
                        defer.resolve(hypervisorTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/host/:uuid', {
            templateUrl: '/static/templates/host/details.html',
            controller: 'MHost.DetailsController',
            resolve: {
                current: function ($q, $route, HostManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    HostManager.query(qobj, function (hosts) {
                        var host = hosts[0];
                        defer.resolve(host);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MImage;
(function (MImage) {
    var Image = (function (_super) {
        __extends(Image, _super);
        function Image() {
            _super.apply(this, arguments);
        }
        Image.prototype.progressOn = function () {
            this.inProgress = true;
        };
        Image.prototype.progressOff = function () {
            this.inProgress = false;
        };
        Image.prototype.isInProgress = function () {
            return this.inProgress;
        };
        Image.prototype.isEnableShow = function () {
            return this.state == 'Disabled' || this.state == 'Maintenance' || this.state == 'PreMaintenance';
        };
        Image.prototype.isDisableShow = function () {
            return this.state == 'Enabled' || this.state == 'Maintenance' || this.state == 'PreMaintenance';
        };
        Image.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        Image.prototype.statusLabel = function () {
            if (this.status == 'Ready') {
                return 'label label-success';
            }
            else {
                return 'label label-default';
            }
        };
        Image.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('status', inv.status);
            self.set('url', inv.url);
            self.set('format', inv.format);
            self.set('mediaType', inv.mediaType);
            self.set('guestOsType', inv.guestOsType);
            self.set('backupStorageRefs', inv.backupStorageRefs);
            self.set('type', inv.type);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return Image;
    })(ApiHeader.ImageInventory);
    MImage.Image = Image;
    var ImageManager = (function () {
        function ImageManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        ImageManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        ImageManager.prototype.wrap = function (Image) {
            return new kendo.data.ObservableObject(Image);
        };
        ImageManager.prototype.create = function (image, done) {
            var _this = this;
            var msg = new ApiHeader.APIAddImageMsg();
            if (Utils.notNullnotUndefined(image.resourceUuid)) {
                msg.resourceUuid = image.resourceUuid;
            }
            msg.system = image.system;
            msg.name = image.name;
            msg.description = image.description;
            msg.mediaType = image.mediaType;
            msg.url = image.url;
            msg.format = image.format;
            msg.guestOsType = image.guestOsType;
            msg.backupStorageUuids = image.backupStorageUuids;
            msg.platform = image.platform;
            this.api.asyncApi(msg, function (ret) {
                var c = new Image();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Added new Image: {0}', c.name),
                    link: Utils.sprintf('/#/image/{0}', c.uuid)
                });
            });
        };
        ImageManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryImageMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new Image();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        ImageManager.prototype.disable = function (image) {
            var _this = this;
            image.progressOn();
            var msg = new ApiHeader.APIChangeImageStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = image.uuid;
            this.api.asyncApi(msg, function (ret) {
                image.updateObservableObject(ret.inventory);
                image.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Image: {0}', image.name),
                    link: Utils.sprintf('/#/image/{0}', image.uuid)
                });
            });
        };
        ImageManager.prototype.enable = function (image) {
            var _this = this;
            image.progressOn();
            var msg = new ApiHeader.APIChangeImageStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = image.uuid;
            this.api.asyncApi(msg, function (ret) {
                image.updateObservableObject(ret.inventory);
                image.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled Image: {0}', image.name),
                    link: Utils.sprintf('/#/image/{0}', image.uuid)
                });
            });
        };
        ImageManager.prototype.delete = function (image, done) {
            var _this = this;
            image.progressOn();
            var msg = new ApiHeader.APIDeleteImageMsg();
            msg.uuid = image.uuid;
            this.api.asyncApi(msg, function (ret) {
                image.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted Image: {0}', image.name)
                });
            });
        };
        ImageManager.$inject = ['Api', '$rootScope'];
        return ImageManager;
    })();
    MImage.ImageManager = ImageManager;
    var ImageModel = (function (_super) {
        __extends(ImageModel, _super);
        function ImageModel() {
            _super.call(this);
            this.current = new Image();
        }
        return ImageModel;
    })(Utils.Model);
    MImage.ImageModel = ImageModel;
    var OImageGrid = (function (_super) {
        __extends(OImageGrid, _super);
        function OImageGrid($scope, imageMgr) {
            _super.call(this);
            this.imageMgr = imageMgr;
            _super.prototype.init.call(this, $scope, $scope.imageGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"image.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/image/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'mediaType',
                    title: '{{"image.ts.MEIDA TYPE" | translate}}',
                    width: '15%'
                },
                {
                    field: 'state',
                    title: '{{"image.ts.STATE" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'status',
                    title: '{{"image.ts.STATUS" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.statusLabel()}}">{{dataItem.status}}</span>'
                },
                {
                    field: 'guestOsType',
                    title: '{{"image.ts.GUEST OS" | translate}}',
                    width: '15%'
                },
                {
                    field: 'size',
                    title: '{{"image.ts.SIZE" | translate}}',
                    width: '10%',
                    template: '<span>{{dataItem.size | size}}</span>'
                },
                {
                    field: 'format',
                    title: '{{"image.ts.FORMAT" | translate}}',
                    width: '10%'
                },
                {
                    field: 'uuid',
                    title: '{{"image.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                imageMgr.query(qobj, function (images, total) {
                    options.success({
                        data: images,
                        total: total
                    });
                });
            };
        }
        return OImageGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, imageMgr) {
            this.$scope = $scope;
            this.imageMgr = imageMgr;
        }
        Action.prototype.enable = function () {
            this.imageMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.imageMgr.disable(this.$scope.model.current);
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, hypervisorTypes) {
            var _this = this;
            this.$scope = $scope;
            this.hypervisorTypes = hypervisorTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"image.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"image.ts.State" | translate}}',
                            value: FilterBy.STATE
                        },
                        {
                            name: '{{"image.ts.Status" | translate}}',
                            value: FilterBy.STATUS
                        },
                        {
                            name: '{{"image.ts.MediaType" | translate}}',
                            value: FilterBy.TYPE
                        },
                        {
                            name: '{{"image.ts.Format" | translate}}',
                            value: FilterBy.FORMAT
                        },
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATUS) {
                    _this.valueList.dataSource.data(['Creating', 'Downloading', 'Ready']);
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
                else if (_this.field == FilterBy.FORMAT) {
                    _this.valueList.dataSource.data('qcow2', 'raw', 'simulator');
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(['RootVolumeTemplate', 'DataVolumeTemplate', 'ISO']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oImageGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        FilterBy.STATUS = 'status';
        FilterBy.TYPE = 'mediaType';
        FilterBy.FORMAT = 'format';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, imageMgr, $routeParams, tagService, current, bsMgr) {
            var _this = this;
            this.$scope = $scope;
            this.imageMgr = imageMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new ImageModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, imageMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteImage = {
                title: 'DELETE IMAGE',
                width: '350px',
                btnType: 'btn-danger',
                description: function () {
                    return $scope.model.current.name;
                },
                confirm: function () {
                    imageMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeImageVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsBackupStorageGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"image.ts.BACKUP STORAGE NAME" | translate}}',
                        width: '20%',
                        template: '<a href="/\\#/backupStorage/{{dataItem.bsUuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'installPath',
                        title: '{{"image.ts.INSTALL PATH" | translate}}',
                        width: '80%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() <= 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            var chain = new Utils.Chain();
                            var bss = [];
                            var refs = [];
                            chain.then(function () {
                                var bsUuids = [];
                                angular.forEach(current.backupStorageRefs, function (it) {
                                    bsUuids.push(it.backupStorageUuid);
                                });
                                var qobj = new ApiHeader.QueryObject();
                                qobj.limit = options.data.take;
                                qobj.start = options.data.pageSize * (options.data.page - 1);
                                qobj.addCondition({
                                    name: 'uuid',
                                    op: 'in',
                                    value: bsUuids.join()
                                });
                                bsMgr.query(qobj, function (ret, total) {
                                    bss = ret;
                                    chain.next();
                                });
                            }).then(function () {
                                angular.forEach(current.backupStorageRefs, function (it) {
                                    for (var i = 0; i < bss.length; i++) {
                                        if (it.backupStorageUuid == bss[i].uuid) {
                                            var bs = bss[i];
                                            break;
                                        }
                                    }
                                    refs.push({
                                        name: bs.name,
                                        bsUuid: bs.uuid,
                                        installPath: it.installPath
                                    });
                                });
                                chain.next();
                            }).done(function () {
                                options.success({
                                    data: refs,
                                    total: refs.length
                                });
                            }).start();
                        }
                    }
                })
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.imageMgr.query(qobj, function (images, total) {
                _this.$scope.model.current = images[0];
            });
        };
        DetailsController.$inject = ['$scope', 'ImageManager', '$routeParams', 'Tag', 'current', 'BackupStorageManager'];
        return DetailsController;
    })();
    MImage.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, imageMgr, hypervisorTypes, $location) {
            this.$scope = $scope;
            this.imageMgr = imageMgr;
            this.hypervisorTypes = hypervisorTypes;
            this.$location = $location;
            $scope.model = new ImageModel();
            $scope.oImageGrid = new OImageGrid($scope, imageMgr);
            $scope.action = new Action($scope, imageMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"image.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"image.ts.Description" | translate}}',
                        value: 'Description'
                    },
                    {
                        name: '{{"image.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"image.ts.Status" | translate}}',
                        value: 'status'
                    },
                    {
                        name: '{{"image.ts.Hypervisor" | translate}}',
                        value: 'hypervisorType'
                    },
                    {
                        name: '{{"image.ts.Bits" | translate}}',
                        value: 'bits'
                    },
                    {
                        name: '{{"image.ts.Format" | translate}}',
                        value: 'format'
                    },
                    {
                        name: '{{"image.ts.Size" | translate}}',
                        value: 'size'
                    },
                    {
                        name: '{{"image.ts.Guest OS Type" | translate}}',
                        value: 'guestOsType'
                    },
                    {
                        name: '{{"image.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"image.ts.None" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    imageMgr.setSortBy(ret);
                    $scope.oImageGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.ImageInventoryQueryable,
                name: 'Image',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    status: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Creating', 'Downloading', 'Ready']
                    },
                    hypervisorType: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.hypervisorTypes
                    },
                    format: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Template', 'ISO']
                    },
                    bits: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['64', '32']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    imageMgr.query(qobj, function (Images, total) {
                        $scope.oImageGrid.refresh(Images);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/image/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.hypervisorTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateImage = function (win) {
                win.open();
            };
            $scope.funcDeleteImage = function () {
                $scope.deleteImage.open();
            };
            $scope.optionsDeleteImage = {
                title: 'DELETE IMAGE',
                width: '350px',
                btnType: 'btn-danger',
                description: function () {
                    return $scope.model.current.name;
                },
                confirm: function () {
                    imageMgr.delete($scope.model.current, function (ret) {
                        $scope.oImageGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oImageGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateImage = {
                done: function (info) {
                    var img = new Image();
                    info.uuid = Utils.uuid();
                    info.status = 'Downloading';
                    angular.extend(img, info);
                    $scope.oImageGrid.add(img);
                    imageMgr.create(info, function (ret) {
                        $scope.oImageGrid.refresh();
                    });
                }
            };
        }
        Controller.$inject = ['$scope', 'ImageManager', 'hypervisorTypes', '$location'];
        return Controller;
    })();
    MImage.Controller = Controller;
    var CreateImageOptions = (function () {
        function CreateImageOptions() {
        }
        return CreateImageOptions;
    })();
    MImage.CreateImageOptions = CreateImageOptions;
    var CreateImageModel = (function () {
        function CreateImageModel() {
        }
        CreateImageModel.prototype.canCreate = function () {
            return angular.isDefined(this.name) && angular.isDefined(this.hypervisorType) &&
                angular.isDefined(this.format) && Utils.notNullnotUndefined(this.backupStorageUuid);
        };
        return CreateImageModel;
    })();
    MImage.CreateImageModel = CreateImageModel;
    var CreateImage = (function () {
        function CreateImage(api, bsMgr, imageMgr) {
            var _this = this;
            this.api = api;
            this.bsMgr = bsMgr;
            this.imageMgr = imageMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateImage;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateImageOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    url: null,
                    backupStorageUuids: [],
                    guestOsType: null,
                    format: null,
                    system: false,
                    platform: null,
                    mediaType: null,
                    hasBackup: function () {
                        return $scope.backupStorageListOptions__.dataSource.data().length > 0;
                    },
                    isUrlValid: function () {
                        if (Utils.notNullnotUndefined(this.url)) {
                            return this.url.indexOf('http') == 0 || this.url.indexOf('https') == 0 || this.url.indexOf('file') == 0;
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name)
                            && Utils.notNullnotUndefined(this.url)
                            && Utils.notNullnotUndefined(this.platform)
                            && Utils.notNullnotUndefined(this.mediaType)
                            && Utils.notNullnotUndefined(this.format) && this.backupStorageUuids.length > 0 && this.isUrlValid();
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createImageInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createImageInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('image');
                        this.description = null;
                        this.url = null;
                        this.guestOsType = null;
                        this.format = null;
                        this.system = false;
                        this.backupStorageUuids = [];
                        this.activeState = false;
                        this.platform = null;
                        this.mediaType = null;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Add";
                    },
                    finish: function () {
                        _this.options.done(infoPage);
                        $scope.winCreateImage__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage
                ], mediator);
                $scope.winCreateImageOptions__ = {
                    width: '700px',
                    //height: '620px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.formatOptions__ = {
                    dataSource: new kendo.data.DataSource([])
                };
                $scope.mediaTypeOptions__ = {
                    dataSource: CreateImage.MEDIA_TYPES
                };
                $scope.platformOptions__ = {
                    dataSource: new kendo.data.DataSource({
                        data: [
                            'Linux',
                            'Windows',
                            'Other',
                            'Paravirtualization'
                        ]
                    })
                };
                $scope.bitsOptions__ = {
                    dataSource: new kendo.data.DataSource({
                        data: CreateImage.BITS
                    })
                };
                $scope.hypervisorOptions__ = {
                    dataSource: new kendo.data.DataSource({
                        data: []
                    })
                };
                $scope.backupStorageListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">Type:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        Utils.safeApply($scope, function () {
                            var sender = e.sender;
                            var data = sender.dataItems();
                            $scope.infoPage.backupStorageUuids = [];
                            angular.forEach(data, function (it) {
                                $scope.infoPage.backupStorageUuids.push(it.uuid);
                            });
                        });
                    }
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/image/addImage.html';
        }
        CreateImage.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateImage__;
            var chain = new Utils.Chain();
            this.$scope.backupStorageListOptions__.dataSource.data([]);
            this.$scope.formatOptions__.dataSource.data([]);
            this.$scope.button.reset();
            this.$scope.infoPage.mediaType = this.$scope.mediaTypeList__.value();
            this.$scope.infoPage.platform = this.$scope.platformList__.value();
            this.$scope.backupStorageList__.value([]);
            this.$scope.infoPage.backupStorageUuids = [];
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'state',
                        op: '=',
                        value: 'Enabled'
                    },
                    {
                        name: 'status',
                        op: '=',
                        value: 'Connected'
                    }
                ];
                _this.bsMgr.query(qobj, function (bss) {
                    _this.$scope.backupStorageListOptions__.dataSource.data(bss);
                    chain.next();
                });
            }).then(function () {
                _this.api.getVolumeFormats(function (formats) {
                    var fs = [];
                    angular.forEach(formats, function (it) {
                        fs.push(it.format);
                    });
                    _this.$scope.formatOptions__.dataSource.data(fs);
                    if (formats.length > 0) {
                        _this.$scope.infoPage.format = formats[0];
                    }
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        CreateImage.MEDIA_TYPES = ['RootVolumeTemplate', 'DataVolumeTemplate', 'ISO'];
        CreateImage.BITS = [64, 32];
        return CreateImage;
    })();
    MImage.CreateImage = CreateImage;
})(MImage || (MImage = {}));
angular.module('root').factory('ImageManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MImage.ImageManager(api, $rootScope);
    }]).directive('zCreateImage', ['Api', 'BackupStorageManager', 'ImageManager', function (api, bsMgr, imageMgr) {
        return new MImage.CreateImage(api, bsMgr, imageMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/image', {
            templateUrl: '/static/templates/image/image.html',
            controller: 'MImage.Controller',
            resolve: {
                hypervisorTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getHypervisorTypes(function (hypervisorTypes) {
                        defer.resolve(hypervisorTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/image/:uuid', {
            templateUrl: '/static/templates/image/details.html',
            controller: 'MImage.DetailsController',
            resolve: {
                current: function ($q, $route, ImageManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    ImageManager.query(qobj, function (images) {
                        var image = images[0];
                        defer.resolve(image);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MInstanceOffering;
(function (MInstanceOffering) {
    var InstanceOffering = (function (_super) {
        __extends(InstanceOffering, _super);
        function InstanceOffering() {
            _super.apply(this, arguments);
        }
        InstanceOffering.prototype.progressOn = function () {
            this.inProgress = true;
        };
        InstanceOffering.prototype.progressOff = function () {
            this.inProgress = false;
        };
        InstanceOffering.prototype.isInProgress = function () {
            return this.inProgress;
        };
        InstanceOffering.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        InstanceOffering.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        InstanceOffering.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        InstanceOffering.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('cpuNum', inv.cpuNum);
            self.set('cpuSpeed', inv.cpuSpeed);
            self.set('memorySize', inv.memorySize);
            self.set('allocatorStrategy', inv.allocatorStrategy);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return InstanceOffering;
    })(ApiHeader.InstanceOfferingInventory);
    MInstanceOffering.InstanceOffering = InstanceOffering;
    var InstanceOfferingManager = (function () {
        function InstanceOfferingManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        InstanceOfferingManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        InstanceOfferingManager.prototype.wrap = function (InstanceOffering) {
            return new kendo.data.ObservableObject(InstanceOffering);
        };
        InstanceOfferingManager.prototype.create = function (instanceOffering, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateInstanceOfferingMsg();
            msg.name = instanceOffering.name;
            msg.description = instanceOffering.description;
            msg.cpuNum = instanceOffering.cpuNum;
            msg.cpuSpeed = instanceOffering.cpuSpeed;
            msg.memorySize = instanceOffering.memorySize;
            msg.allocatorStrategy = instanceOffering.allocatorStrategy;
            this.api.asyncApi(msg, function (ret) {
                var c = new InstanceOffering();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Added new Instance Offering: {0}', c.name),
                    link: Utils.sprintf('/#/instanceOffering/{0}', c.uuid)
                });
            });
        };
        InstanceOfferingManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryInstanceOfferingMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            msg.conditions.push({
                name: 'type',
                op: '=',
                value: 'UserVm'
            });
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new InstanceOffering();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        InstanceOfferingManager.prototype.disable = function (instanceOffering) {
            var _this = this;
            instanceOffering.progressOn();
            var msg = new ApiHeader.APIChangeInstanceOfferingStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = instanceOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                instanceOffering.updateObservableObject(ret.inventory);
                instanceOffering.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Instance Offering: {0}', instanceOffering.name),
                    link: Utils.sprintf('/#/instanceOffering/{0}', instanceOffering.uuid)
                });
            });
        };
        InstanceOfferingManager.prototype.enable = function (instanceOffering) {
            var _this = this;
            instanceOffering.progressOn();
            var msg = new ApiHeader.APIChangeInstanceOfferingStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = instanceOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                instanceOffering.updateObservableObject(ret.inventory);
                instanceOffering.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled Instance Offering: {0}', instanceOffering.name),
                    link: Utils.sprintf('/#/instanceOffering/{0}', instanceOffering.uuid)
                });
            });
        };
        InstanceOfferingManager.prototype.delete = function (instanceOffering, done) {
            var _this = this;
            instanceOffering.progressOn();
            var msg = new ApiHeader.APIDeleteInstanceOfferingMsg();
            msg.uuid = instanceOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                instanceOffering.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted Instance Offering: {0}', instanceOffering.name)
                });
            });
        };
        InstanceOfferingManager.$inject = ['Api', '$rootScope'];
        return InstanceOfferingManager;
    })();
    MInstanceOffering.InstanceOfferingManager = InstanceOfferingManager;
    var InstanceOfferingModel = (function (_super) {
        __extends(InstanceOfferingModel, _super);
        function InstanceOfferingModel() {
            _super.call(this);
            this.current = new InstanceOffering();
        }
        return InstanceOfferingModel;
    })(Utils.Model);
    MInstanceOffering.InstanceOfferingModel = InstanceOfferingModel;
    var OInstanceOfferingGrid = (function (_super) {
        __extends(OInstanceOfferingGrid, _super);
        function OInstanceOfferingGrid($scope, instanceOfferingMgr) {
            _super.call(this);
            this.instanceOfferingMgr = instanceOfferingMgr;
            _super.prototype.init.call(this, $scope, $scope.instanceOfferingGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"instanceOffering.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/instanceOffering/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"instanceOffering.ts.DESCRIPTION" | translate}}',
                    width: '20%'
                },
                {
                    field: 'cpuNum',
                    title: '{{"instanceOffering.ts.CPU NUMBER" | translate}}',
                    width: '10%'
                },
                {
                    field: 'cpuSpeed',
                    title: '{{"instanceOffering.ts.CPU SPEED" | translate}}',
                    width: '10%'
                },
                {
                    field: 'memorySize',
                    title: '{{"instanceOffering.ts.MEMORY" | translate}}',
                    width: '15%',
                    template: '<span>{{dataItem.memorySize | size}}</span>'
                },
                {
                    field: 'state',
                    title: '{{"instanceOffering.ts.STATE" | translate}}',
                    width: '15%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"instanceOffering.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                instanceOfferingMgr.query(qobj, function (instanceOfferings, total) {
                    options.success({
                        data: instanceOfferings,
                        total: total
                    });
                });
            };
        }
        return OInstanceOfferingGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, instanceOfferingMgr) {
            this.$scope = $scope;
            this.instanceOfferingMgr = instanceOfferingMgr;
        }
        Action.prototype.enable = function () {
            this.instanceOfferingMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.instanceOfferingMgr.disable(this.$scope.model.current);
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, hypervisorTypes) {
            var _this = this;
            this.$scope = $scope;
            this.hypervisorTypes = hypervisorTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"instanceOffering.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"instanceOffering.ts.State" | translate}}',
                            value: FilterBy.STATE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oInstanceOfferingGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, instanceOfferingMgr, $routeParams, tagService, current) {
            var _this = this;
            this.$scope = $scope;
            this.instanceOfferingMgr = instanceOfferingMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new InstanceOfferingModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, instanceOfferingMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteInstanceOffering = {
                title: 'DELETE INSTANCE OFFERING',
                btnType: 'btn-danger',
                width: '350px',
                description: function () {
                    return current.name;
                },
                confirm: function () {
                    instanceOfferingMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeInstanceOfferingVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.instanceOfferingMgr.query(qobj, function (instanceOfferings, total) {
                _this.$scope.model.current = instanceOfferings[0];
            });
        };
        DetailsController.$inject = ['$scope', 'InstanceOfferingManager', '$routeParams', 'Tag', 'current'];
        return DetailsController;
    })();
    MInstanceOffering.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, instanceOfferingMgr, hypervisorTypes, $location) {
            this.$scope = $scope;
            this.instanceOfferingMgr = instanceOfferingMgr;
            this.hypervisorTypes = hypervisorTypes;
            this.$location = $location;
            $scope.model = new InstanceOfferingModel();
            $scope.oInstanceOfferingGrid = new OInstanceOfferingGrid($scope, instanceOfferingMgr);
            $scope.action = new Action($scope, instanceOfferingMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"instanceOffering.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"instanceOffering.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"instanceOffering.ts.CPU Number" | translate}}',
                        value: 'cpuNum'
                    },
                    {
                        name: '{{"instanceOffering.ts.CPU Speed" | translate}}',
                        value: 'cpuSpeed'
                    },
                    {
                        name: '{{"instanceOffering.ts.Memory" | translate}}',
                        value: 'memorySize'
                    },
                    {
                        name: '{{"instanceOffering.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"instanceOffering.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"instanceOffering.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    instanceOfferingMgr.setSortBy(ret);
                    $scope.oInstanceOfferingGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.InstanceOfferingInventoryQueryable,
                name: 'InstanceOffering',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    instanceOfferingMgr.query(qobj, function (InstanceOfferings, total) {
                        $scope.oInstanceOfferingGrid.refresh(InstanceOfferings);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/instanceOffering/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.hypervisorTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateInstanceOffering = function (win) {
                win.open();
            };
            $scope.funcDeleteInstanceOffering = function () {
                $scope.deleteInstanceOffering.open();
            };
            $scope.optionsDeleteInstanceOffering = {
                title: 'DELETE INSTANCE OFFERING',
                btnType: 'btn-danger',
                width: '350px',
                description: function () {
                    return $scope.model.current.name;
                },
                confirm: function () {
                    instanceOfferingMgr.delete($scope.model.current, function (ret) {
                        $scope.oInstanceOfferingGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oInstanceOfferingGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateInstanceOffering = {
                done: function (instanceOffering) {
                    $scope.oInstanceOfferingGrid.add(instanceOffering);
                }
            };
        }
        Controller.$inject = ['$scope', 'InstanceOfferingManager', 'hypervisorTypes', '$location'];
        return Controller;
    })();
    MInstanceOffering.Controller = Controller;
    var CreateInstanceOfferingOptions = (function () {
        function CreateInstanceOfferingOptions() {
        }
        return CreateInstanceOfferingOptions;
    })();
    MInstanceOffering.CreateInstanceOfferingOptions = CreateInstanceOfferingOptions;
    var CreateInstanceOfferingModel = (function () {
        function CreateInstanceOfferingModel() {
        }
        CreateInstanceOfferingModel.prototype.canCreate = function () {
            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.cpuNum) &&
                Utils.notNullnotUndefined(this.cpuSpeed) && Utils.notNullnotUndefined(this.memorySize);
        };
        return CreateInstanceOfferingModel;
    })();
    MInstanceOffering.CreateInstanceOfferingModel = CreateInstanceOfferingModel;
    var CreateInstanceOffering = (function () {
        function CreateInstanceOffering(api, instanceOfferingMgr) {
            var _this = this;
            this.api = api;
            this.instanceOfferingMgr = instanceOfferingMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateInstanceOffering;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateInstanceOfferingOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    memorySize: null,
                    cpuNum: null,
                    cpuSpeed: null,
                    allocatorStrategy: null,
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.memorySize) && Utils.notNullnotUndefined(this.cpuNum)
                            && Utils.notNullnotUndefined(this.cpuSpeed) && this.isCpuNumValid() && this.isCpuSpeedValid() && this.isMemoryValid();
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createInstanceOfferingInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createInstanceOfferingInfo';
                    },
                    isCpuNumValid: function () {
                        if (Utils.notNullnotUndefinedNotEmptyString(this.cpuNum)) {
                            return !isNaN(this.cpuNum);
                        }
                        return true;
                    },
                    isCpuSpeedValid: function () {
                        if (Utils.notNullnotUndefinedNotEmptyString(this.cpuSpeed)) {
                            return !isNaN(this.cpuSpeed);
                        }
                        return true;
                    },
                    isMemoryValid: function () {
                        if (Utils.notNullnotUndefinedNotEmptyString(this.memorySize)) {
                            return Utils.isValidSizeStr(this.memorySize);
                        }
                        return true;
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('ioffering');
                        this.memorySize = null;
                        this.cpuNum = null;
                        this.cpuSpeed = null;
                        this.allocatorStrategy = null;
                        this.description = null;
                        this.activeState = false;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultInstanceOffering;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            if (Utils.notNullnotUndefined($scope.infoPage.allocatorStrategy) && $scope.infoPage.allocatorStrategy == "") {
                                $scope.infoPage.allocatorStrategy = null;
                            }
                            $scope.infoPage.memorySize = Utils.parseSize($scope.infoPage.memorySize);
                            instanceOfferingMgr.create(infoPage, function (ret) {
                                resultInstanceOffering = ret;
                                chain.next();
                            });
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultInstanceOffering);
                            }
                            $scope.winCreateInstanceOffering__.close();
                        }).start();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage
                ], mediator);
                $scope.winCreateInstanceOfferingOptions__ = {
                    width: '700px',
                    //height: '620px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.allocatorStrategyOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] })
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/instanceOffering/addInstanceOffering.html';
        }
        CreateInstanceOffering.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateInstanceOffering__;
            this.$scope.button.reset();
            this.api.getInstanceOfferingAllocatorStrategies(function (ret) {
                ret.unshift("");
                _this.$scope.allocatorStrategyOptions__.dataSource.data(ret);
                win.center();
                win.open();
            });
        };
        return CreateInstanceOffering;
    })();
    MInstanceOffering.CreateInstanceOffering = CreateInstanceOffering;
})(MInstanceOffering || (MInstanceOffering = {}));
angular.module('root').factory('InstanceOfferingManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MInstanceOffering.InstanceOfferingManager(api, $rootScope);
    }]).directive('zCreateInstanceOffering', ['Api', 'InstanceOfferingManager', function (api, instanceOfferingMgr) {
        return new MInstanceOffering.CreateInstanceOffering(api, instanceOfferingMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/instanceOffering', {
            templateUrl: '/static/templates/instanceOffering/instanceOffering.html',
            controller: 'MInstanceOffering.Controller',
            resolve: {
                hypervisorTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getHypervisorTypes(function (hypervisorTypes) {
                        defer.resolve(hypervisorTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/instanceOffering/:uuid', {
            templateUrl: '/static/templates/instanceOffering/details.html',
            controller: 'MInstanceOffering.DetailsController',
            resolve: {
                current: function ($q, $route, InstanceOfferingManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    InstanceOfferingManager.query(qobj, function (instanceOfferings) {
                        var instanceOffering = instanceOfferings[0];
                        defer.resolve(instanceOffering);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MDiskOffering;
(function (MDiskOffering) {
    var DiskOffering = (function (_super) {
        __extends(DiskOffering, _super);
        function DiskOffering() {
            _super.apply(this, arguments);
        }
        DiskOffering.prototype.progressOn = function () {
            this.inProgress = true;
        };
        DiskOffering.prototype.progressOff = function () {
            this.inProgress = false;
        };
        DiskOffering.prototype.isInProgress = function () {
            return this.inProgress;
        };
        DiskOffering.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        DiskOffering.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        DiskOffering.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        DiskOffering.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('diskSize', inv.diskSize);
            self.set('allocatorStrategy', inv.allocatorStrategy);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return DiskOffering;
    })(ApiHeader.DiskOfferingInventory);
    MDiskOffering.DiskOffering = DiskOffering;
    var DiskOfferingManager = (function () {
        function DiskOfferingManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        DiskOfferingManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        DiskOfferingManager.prototype.wrap = function (DiskOffering) {
            return new kendo.data.ObservableObject(DiskOffering);
        };
        DiskOfferingManager.prototype.create = function (diskOffering, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateDiskOfferingMsg();
            msg.name = diskOffering.name;
            msg.description = diskOffering.description;
            msg.diskSize = diskOffering.diskSize;
            msg.allocatorStrategy = diskOffering.allocatorStrategy;
            this.api.asyncApi(msg, function (ret) {
                var c = new DiskOffering();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Added new Disk Offering: {0}', c.name),
                    link: Utils.sprintf('/#/diskOffering/{0}', c.uuid)
                });
            });
        };
        DiskOfferingManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryDiskOfferingMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new DiskOffering();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        DiskOfferingManager.prototype.disable = function (diskOffering) {
            var _this = this;
            diskOffering.progressOn();
            var msg = new ApiHeader.APIChangeDiskOfferingStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = diskOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                diskOffering.updateObservableObject(ret.inventory);
                diskOffering.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Disk Offering: {0}', diskOffering.name),
                    link: Utils.sprintf('/#/diskOffering/{0}', diskOffering.uuid)
                });
            });
        };
        DiskOfferingManager.prototype.enable = function (diskOffering) {
            var _this = this;
            diskOffering.progressOn();
            var msg = new ApiHeader.APIChangeDiskOfferingStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = diskOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                diskOffering.updateObservableObject(ret.inventory);
                diskOffering.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled Disk Offering: {0}', diskOffering.name),
                    link: Utils.sprintf('/#/diskOffering/{0}', diskOffering.uuid)
                });
            });
        };
        DiskOfferingManager.prototype.delete = function (diskOffering, done) {
            var _this = this;
            diskOffering.progressOn();
            var msg = new ApiHeader.APIDeleteDiskOfferingMsg();
            msg.uuid = diskOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                diskOffering.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted Disk Offering: {0}', diskOffering.name)
                });
            });
        };
        DiskOfferingManager.$inject = ['Api', '$rootScope'];
        return DiskOfferingManager;
    })();
    MDiskOffering.DiskOfferingManager = DiskOfferingManager;
    var DiskOfferingModel = (function (_super) {
        __extends(DiskOfferingModel, _super);
        function DiskOfferingModel() {
            _super.call(this);
            this.current = new DiskOffering();
        }
        return DiskOfferingModel;
    })(Utils.Model);
    MDiskOffering.DiskOfferingModel = DiskOfferingModel;
    var ODiskOfferingGrid = (function (_super) {
        __extends(ODiskOfferingGrid, _super);
        function ODiskOfferingGrid($scope, diskOfferingMgr) {
            _super.call(this);
            this.diskOfferingMgr = diskOfferingMgr;
            _super.prototype.init.call(this, $scope, $scope.diskOfferingGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"diskOffering.ts.NAME" | translate}}',
                    width: '20%',
                    template: '<a href="/\\#/diskOffering/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"diskOffering.ts.DESCRIPTION" | translate}}',
                    width: '20%'
                },
                {
                    field: 'diskSize',
                    title: '{{"diskOffering.ts.DISK SIZE" | translate}}',
                    width: '20%',
                    template: '<span>{{dataItem.diskSize | size}}</span>'
                },
                {
                    field: 'state',
                    title: '{{"diskOffering.ts.STATE" | translate}}',
                    width: '20%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"diskOffering.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                diskOfferingMgr.query(qobj, function (diskOfferings, total) {
                    options.success({
                        data: diskOfferings,
                        total: total
                    });
                });
            };
        }
        return ODiskOfferingGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, diskOfferingMgr) {
            this.$scope = $scope;
            this.diskOfferingMgr = diskOfferingMgr;
        }
        Action.prototype.enable = function () {
            this.diskOfferingMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.diskOfferingMgr.disable(this.$scope.model.current);
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope) {
            var _this = this;
            this.$scope = $scope;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"diskOffering.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"diskOffering.ts.State" | translate}}',
                            value: FilterBy.STATE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oDiskOfferingGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, diskOfferingMgr, $routeParams, tagService, current) {
            var _this = this;
            this.$scope = $scope;
            this.diskOfferingMgr = diskOfferingMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new DiskOfferingModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, diskOfferingMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteDiskOffering = {
                title: 'DELETE DISK OFFERING',
                description: function () {
                    return current.name;
                },
                btnType: 'btn-danger',
                width: '350px',
                confirm: function () {
                    diskOfferingMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeDiskOfferingVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.diskOfferingMgr.query(qobj, function (diskOfferings, total) {
                _this.$scope.model.current = diskOfferings[0];
            });
        };
        DetailsController.$inject = ['$scope', 'DiskOfferingManager', '$routeParams', 'Tag', 'current'];
        return DetailsController;
    })();
    MDiskOffering.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, diskOfferingMgr, $location) {
            this.$scope = $scope;
            this.diskOfferingMgr = diskOfferingMgr;
            this.$location = $location;
            $scope.model = new DiskOfferingModel();
            $scope.oDiskOfferingGrid = new ODiskOfferingGrid($scope, diskOfferingMgr);
            $scope.action = new Action($scope, diskOfferingMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"diskOffering.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"diskOffering.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"diskOffering.ts.Disk Size" | translate}}',
                        value: 'diskSize'
                    },
                    {
                        name: '{{"diskOffering.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"diskOffering.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"diskOffering.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    diskOfferingMgr.setSortBy(ret);
                    $scope.oDiskOfferingGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.DiskOfferingInventoryQueryable,
                name: 'DiskOffering',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    diskOfferingMgr.query(qobj, function (DiskOfferings, total) {
                        $scope.oDiskOfferingGrid.refresh(DiskOfferings);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/diskOffering/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateDiskOffering = function (win) {
                win.open();
            };
            $scope.funcDeleteDiskOffering = function () {
                $scope.deleteDiskOffering.open();
            };
            $scope.optionsDeleteDiskOffering = {
                title: 'DELETE DISK OFFERING',
                description: function () {
                    return $scope.model.current.name;
                },
                btnType: 'btn-danger',
                width: '350px',
                confirm: function () {
                    diskOfferingMgr.delete($scope.model.current, function (ret) {
                        $scope.oDiskOfferingGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oDiskOfferingGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateDiskOffering = {
                done: function (diskOffering) {
                    $scope.oDiskOfferingGrid.add(diskOffering);
                }
            };
        }
        Controller.$inject = ['$scope', 'DiskOfferingManager', '$location'];
        return Controller;
    })();
    MDiskOffering.Controller = Controller;
    var CreateDiskOfferingOptions = (function () {
        function CreateDiskOfferingOptions() {
        }
        return CreateDiskOfferingOptions;
    })();
    MDiskOffering.CreateDiskOfferingOptions = CreateDiskOfferingOptions;
    var CreateDiskOfferingModel = (function () {
        function CreateDiskOfferingModel() {
        }
        CreateDiskOfferingModel.prototype.canCreate = function () {
            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.diskSize);
        };
        return CreateDiskOfferingModel;
    })();
    MDiskOffering.CreateDiskOfferingModel = CreateDiskOfferingModel;
    var CreateDiskOffering = (function () {
        function CreateDiskOffering(api, diskOfferingMgr) {
            var _this = this;
            this.api = api;
            this.diskOfferingMgr = diskOfferingMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateDiskOffering;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateDiskOfferingOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    diskSize: null,
                    allocatorStrategy: null,
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.diskSize);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createDiskOfferingInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createDiskOfferingInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('diskOffering');
                        this.diskSize = null;
                        this.allocatorStrategy = null;
                        this.description = null;
                        this.activeState = false;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultDiskOffering;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            if (Utils.notNullnotUndefined($scope.infoPage.allocatorStrategy) && $scope.infoPage.allocatorStrategy == "") {
                                $scope.infoPage.allocatorStrategy = null;
                            }
                            $scope.infoPage.diskSize = Utils.parseSize($scope.infoPage.diskSize);
                            diskOfferingMgr.create(infoPage, function (ret) {
                                resultDiskOffering = ret;
                                chain.next();
                            });
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultDiskOffering);
                            }
                        }).start();
                        $scope.winCreateDiskOffering__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage
                ], mediator);
                $scope.winCreateDiskOfferingOptions__ = {
                    width: '700px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.allocatorStrategyOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] })
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/diskOffering/addDiskOffering.html';
        }
        CreateDiskOffering.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateDiskOffering__;
            this.$scope.button.reset();
            this.api.getDiskOfferingAllocatorStrategies(function (ret) {
                ret.unshift("");
                _this.$scope.allocatorStrategyOptions__.dataSource.data(ret);
                win.center();
                win.open();
            });
        };
        return CreateDiskOffering;
    })();
    MDiskOffering.CreateDiskOffering = CreateDiskOffering;
})(MDiskOffering || (MDiskOffering = {}));
angular.module('root').factory('DiskOfferingManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MDiskOffering.DiskOfferingManager(api, $rootScope);
    }]).directive('zCreateDiskOffering', ['Api', 'DiskOfferingManager', function (api, diskOfferingMgr) {
        return new MDiskOffering.CreateDiskOffering(api, diskOfferingMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/diskOffering', {
            templateUrl: '/static/templates/diskOffering/diskOffering.html',
            controller: 'MDiskOffering.Controller'
        }).when('/diskOffering/:uuid', {
            templateUrl: '/static/templates/diskOffering/details.html',
            controller: 'MDiskOffering.DetailsController',
            resolve: {
                current: function ($q, $route, DiskOfferingManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    DiskOfferingManager.query(qobj, function (diskOfferings) {
                        var diskOffering = diskOfferings[0];
                        defer.resolve(diskOffering);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MApiDetails;
(function (MApiDetails) {
    var Details = (function () {
        function Details() {
        }
        return Details;
    })();
    var Controller = (function () {
        function Controller() {
        }
        return Controller;
    })();
    MApiDetails.Controller = Controller;
    var DetailsController = (function () {
        function DetailsController($scope, $rootScope, apiDetails, $routeParams) {
            this.$routeParams = $routeParams;
            var apiId = $routeParams.apiId;
            var apis = $rootScope.optionsApiGrid.dataSource.data();
            var api = null;
            for (var i = 0; i < apis.length; i++) {
                api = apis[i];
                if (api.apiId == apiId) {
                    $scope.request = JSON.stringify(api.request.toApiMap(), null, 2);
                    $scope.response = JSON.stringify(api.rsp, null, 2);
                    break;
                }
            }
            if (!Utils.notNullnotUndefined(api)) {
                return;
            }
            $scope.isSuccess = function () {
                return api.success;
            };
            $scope.getResultLabel = function () {
                return api.success ? 'label label-success' : 'label label-danger';
            };
        }
        DetailsController.$inject = ['$scope', '$rootScope', 'ApiDetails', '$routeParams'];
        return DetailsController;
    })();
    MApiDetails.DetailsController = DetailsController;
    var ApiDetails = (function () {
        function ApiDetails($rootScope, api, $location) {
            var _this = this;
            this.$rootScope = $rootScope;
            this.api = api;
            this.$location = $location;
            api.installListener(null, function (request, rsp) {
                var d = new Details();
                var apiId = Utils.firstItem(rsp).apiId;
                d.request = request;
                d.requestText = JSON.stringify(request.toApiMap());
                d.rsp = rsp;
                d.rspText = JSON.stringify(rsp);
                d.success = Utils.firstItem(rsp).success;
                d.apiId = apiId;
                $rootScope.optionsApiGrid.dataSource.insert(0, d);
                if (!d.success) {
                    _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                        msg: Utils.sprintf('API failure'),
                        type: 'error',
                        link: Utils.sprintf('/#/apiDetails/{0}', apiId)
                    });
                }
            }, function (error) {
                var d = new Details();
                d.request = JSON.stringify(error.request);
                d.rsp = JSON.stringify({
                    status: error.status,
                    reason: error.data
                });
                d.success = false;
                $rootScope.optionsApiGrid.dataSource.insert(0, d);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    type: 'error',
                    msg: Utils.sprintf('API failure, {0}', d.rsp)
                });
            });
            $rootScope.optionsApiGrid = {
                dataSource: new kendo.data.DataSource({
                    data: []
                }),
                resizable: true,
                scrollable: true,
                selectable: true,
                pageable: true,
                columns: [
                    {
                        field: 'success',
                        title: 'SUCCESS',
                        width: '10%',
                        template: '<span class="label #= success ? \"label-success\" : \"label-danger\" #">#= success ? \"SUCCESS\" : \"FAILURE\" #</span>'
                    },
                    {
                        field: 'requestText',
                        title: 'REQUEST',
                        width: '45%'
                    },
                    {
                        field: 'rspText',
                        title: 'RESPONSE',
                        width: '45%'
                    }
                ],
                change: function (e) {
                    var grid = e.sender;
                    var selected = grid.select();
                    Utils.safeApply($rootScope, function () {
                        $rootScope.currentApiDetails = grid.dataItem(selected);
                    });
                }
            };
            $rootScope.getApiDetailsNum = function () {
                return $rootScope.optionsApiGrid.dataSource.data().length;
            };
            $rootScope.funcApiDetailsGridDoubleClick = function () {
                console.log('xxxxxxxxxxxxxxxx ' + JSON.stringify($rootScope.currentApiDetails));
                if (Utils.notNullnotUndefined($rootScope.currentApiDetails)) {
                    var url = Utils.sprintf('/apiDetails/{0}', $rootScope.currentApiDetails.apiId);
                    $location.path(url);
                }
            };
        }
        ApiDetails.$inject = ['$rootScope', 'Api', '$location'];
        return ApiDetails;
    })();
    MApiDetails.ApiDetails = ApiDetails;
})(MApiDetails || (MApiDetails = {}));
angular.module('root').config(['$routeProvider', function (route) {
        route.when('/apiDetails', {
            templateUrl: '/static/templates/apiDetails.html',
            controller: 'MApiDetails.Controller'
        }).when('/apiDetails/:apiId', {
            templateUrl: '/static/templates/apiDetailsDetails.html',
            controller: 'MApiDetails.DetailsController'
        });
    }]).factory('ApiDetails', ['$rootScope', 'Api', '$location', function ($rootScope, api, $location) {
        return new MApiDetails.ApiDetails($rootScope, api, $location);
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MVmInstance;
(function (MVmInstance) {
    var VmNic = (function (_super) {
        __extends(VmNic, _super);
        function VmNic() {
            _super.apply(this, arguments);
        }
        VmNic.prototype.progressOn = function () {
            this.inProgress = true;
        };
        VmNic.prototype.progressOff = function () {
            this.inProgress = false;
        };
        VmNic.prototype.isInProgress = function () {
            return this.inProgress;
        };
        VmNic.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('vmInstanceUuid', inv.vmInstanceUuid);
            self.set('l3NetworkUuid', inv.l3NetworkUuid);
            self.set('ip', inv.ip);
            self.set('mac', inv.mac);
            self.set('netmask', inv.netmask);
            self.set('gateway', inv.gateway);
            self.set('metaData', inv.metaData);
            self.set('deviceId', inv.deviceId);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return VmNic;
    })(ApiHeader.VmNicInventory);
    MVmInstance.VmNic = VmNic;
    var VmInstance = (function (_super) {
        __extends(VmInstance, _super);
        function VmInstance() {
            _super.apply(this, arguments);
        }
        VmInstance.prototype.progressOn = function () {
            this.inProgress = true;
        };
        VmInstance.prototype.progressOff = function () {
            this.inProgress = false;
        };
        VmInstance.prototype.isInProgress = function () {
            return this.inProgress;
        };
        VmInstance.prototype.stateLabel = function () {
            if (this.state == 'Running') {
                return 'label label-success';
            }
            else if (this.state == 'Stopped') {
                return 'label label-danger';
            }
            else if (this.state == 'Unknown') {
                return 'label label-warning';
            }
            else {
                return 'label label-default';
            }
        };
        VmInstance.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('zoneUuid', inv.zoneUuid);
            self.set('clusterUuid', inv.clusterUuid);
            self.set('hypervisorType', inv.hypervisorType);
            self.set('state', inv.state);
            self.set('hostUuid', inv.hostUuid);
            self.set('lastHostUuid', inv.lastHostUuid);
            self.set('rootVolumeUuid', inv.rootVolumeUuid);
            self.set('defaultL3NetworkUuid', inv.defaultL3NetworkUuid);
            self.set('vmNics', inv.vmNics);
            self.set('type', inv.type);
            self.set('imageUuid', inv.imageUuid);
            self.set('allVolumes', inv.allVolumes);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
            self.set('cpuSpeed', inv.cpuSpeed);
            self.set('cpuNum', inv.cpuNum);
            self.set('allocatorStrategy', inv.allocatorStrategy);
        };
        VmInstance.STATES = ['Running', 'Starting', 'Stopping', 'Stopped', 'Rebooting', 'Migrating', 'Unknown', 'Created'];
        return VmInstance;
    })(ApiHeader.VmInstanceInventory);
    MVmInstance.VmInstance = VmInstance;
    var VmInstanceManager = (function () {
        function VmInstanceManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        VmInstanceManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        VmInstanceManager.prototype.wrap = function (obj) {
            return new kendo.data.ObservableObject(obj);
        };
        VmInstanceManager.prototype.create = function (vm, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateVmInstanceMsg();
            msg.name = vm.name;
            msg.description = vm.description;
            msg.instanceOfferingUuid = vm.instanceOfferingUuid;
            msg.imageUuid = vm.imageUuid;
            msg.l3NetworkUuids = vm.l3NetworkUuids;
            msg.rootDiskOfferingUuid = vm.rootDiskOfferingUuid;
            msg.dataDiskOfferingUuids = vm.dataDiskOfferingUuids;
            msg.zoneUuid = vm.zoneUuid;
            msg.clusterUuid = vm.clusterUuid;
            msg.hostUuid = vm.hostUuid;
            msg.resourceUuid = vm.resourceUuid;
            msg.defaultL3NetworkUuid = vm.defaultL3NetworkUuid;
            msg.systemTags = [];
            for (var i = 0; i < vm.l3NetworkStaticIps.length; ++i) {
                msg.systemTags.push('staticIp::' + vm.l3NetworkStaticIps[i].uuid + '::' + vm.l3NetworkStaticIps[i].staticIp);
            }
            if (Utils.notNullnotUndefined(vm.hostname)) {
                msg.systemTags.push('hostname::' + vm.hostname);
            }
            this.api.asyncApi(msg, function (ret) {
                var c = new VmInstance();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new VmInstance: {0}', c.name),
                    link: Utils.sprintf('/#/vm/{0}', c.uuid)
                });
            });
        };
        VmInstanceManager.prototype.getConsole = function (vm, done) {
            var msg = new ApiHeader.APIRequestConsoleAccessMsg();
            msg.vmInstanceUuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                done(ret.inventory);
            });
        };
        VmInstanceManager.prototype.query = function (qobj, callback, allVm) {
            var _this = this;
            if (allVm === void 0) { allVm = false; }
            var msg = new ApiHeader.APIQueryVmInstanceMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (!allVm) {
                msg.conditions.push({
                    name: "type",
                    op: "=",
                    value: "UserVm"
                });
            }
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new VmInstance();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        VmInstanceManager.prototype.stop = function (vm) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Stopping';
            var msg = new ApiHeader.APIStopVmInstanceMsg();
            msg.uuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Stopped VmInstance: {0}', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            });
        };
        VmInstanceManager.prototype.start = function (vm) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Starting';
            var msg = new ApiHeader.APIStartVmInstanceMsg();
            msg.uuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Started VmInstance: {0}', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            });
        };
        VmInstanceManager.prototype.reboot = function (vm) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Rebooting';
            var msg = new ApiHeader.APIRebootVmInstanceMsg();
            msg.uuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Rebooted VmInstance: {0}', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            }, function () {
                vm.progressOff();
            });
        };
        VmInstanceManager.prototype.delete = function (vm, done) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Destroying';
            var msg = new ApiHeader.APIDestroyVmInstanceMsg();
            msg.uuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted VmInstance: {0}', vm.name)
                });
            });
        };
        VmInstanceManager.prototype.migrate = function (vm, hostUuid, done) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Migrating';
            var msg = new ApiHeader.APIMigrateVmMsg();
            msg.hostUuid = hostUuid;
            msg.vmInstanceUuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Migrated VmInstance: {0}', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            });
        };
        VmInstanceManager.prototype.attachL3Network = function (vm, l3Uuid, done) {
            var _this = this;
            vm.progressOn();
            var msg = new ApiHeader.APIAttachL3NetworkToVmMsg();
            msg.l3NetworkUuid = l3Uuid;
            msg.vmInstanceUuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached a L3 network to the VM: {0}', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            });
        };
        VmInstanceManager.prototype.detachL3Network = function (vm, nicUuid, done) {
            var _this = this;
            vm.progressOn();
            var msg = new ApiHeader.APIDetachL3NetworkFromVmMsg();
            msg.vmNicUuid = nicUuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached a L3 network from the VM: {0}', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            });
        };
        VmInstanceManager.prototype.attachVolume = function (vm, volUuid, done) {
            var _this = this;
            vm.progressOn();
            var msg = new ApiHeader.APIAttachDataVolumeToVmMsg();
            msg.vmInstanceUuid = vm.uuid;
            msg.volumeUuid = volUuid;
            this.api.asyncApi(msg, function (ret) {
                vm.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done(ret.inventory);
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached data volume to vm instance: {0}', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            });
        };
        VmInstanceManager.prototype.detachVolume = function (vm, volUuid, done) {
            var _this = this;
            vm.progressOn();
            var msg = new ApiHeader.APIDetachDataVolumeFromVmMsg();
            msg.uuid = volUuid;
            this.api.asyncApi(msg, function (ret) {
                vm.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached data volume from vm instance: {0}', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            });
        };
        VmInstanceManager.prototype.changeInstanceOffering = function (vm, insUuid, done) {
            var _this = this;
            vm.progressOn();
            var msg = new ApiHeader.APIChangeInstanceOfferingMsg();
            msg.vmInstanceUuid = vm.uuid;
            msg.instanceOfferingUuid = insUuid;
            this.api.asyncApi(msg, function (ret) {
                vm.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Changed the instance offering of the VM instance: {0}; you may need to stop/start the VM', vm.name),
                    link: Utils.sprintf('/#/vmInstance/{0}', vm.uuid)
                });
            });
        };
        VmInstanceManager.prototype.queryVmNic = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryVmNicMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new VmNic();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        VmInstanceManager.$inject = ['Api', '$rootScope'];
        return VmInstanceManager;
    })();
    MVmInstance.VmInstanceManager = VmInstanceManager;
    var VmInstanceModel = (function (_super) {
        __extends(VmInstanceModel, _super);
        function VmInstanceModel() {
            _super.call(this);
            this.current = new VmInstance();
        }
        return VmInstanceModel;
    })(Utils.Model);
    MVmInstance.VmInstanceModel = VmInstanceModel;
    var OVmInstanceGrid = (function (_super) {
        __extends(OVmInstanceGrid, _super);
        function OVmInstanceGrid($scope, vmMgr, hostMgr) {
            var _this = this;
            _super.call(this);
            this.vmMgr = vmMgr;
            this.hostMgr = hostMgr;
            _super.prototype.init.call(this, $scope, $scope.vmGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"vm.ts.NAME" | translate}}',
                    width: '20%',
                    template: '<a href="/\\#/vmInstance/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"vm.ts.DESCRIPTION" | translate}}',
                    width: '20%'
                },
                {
                    field: 'defaultIp',
                    title: '{{"vm.ts.DEFAULT IP" | translate}}',
                    width: '20%',
                    template: '{{dataItem.defaultIp}}'
                },
                {
                    field: 'hostIp',
                    title: '{{"vm.ts.HOST IP" | translate}}',
                    width: '20%',
                    template: '<a href="/\\#/host/{{dataItem.hostUuid}}">{{dataItem.managementIp}}</a>'
                },
                {
                    field: 'state',
                    title: '{{"vm.ts.STATE" | translate}}',
                    width: '20%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"vm.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                vmMgr.query(qobj, function (vms, total) {
                    options.success({
                        data: vms,
                        total: total
                    });
                    for (var i in vms) {
                        var defaultL3NetworkUuid = vms[i].defaultL3NetworkUuid;
                        for (var j in vms[i].vmNics) {
                            if (defaultL3NetworkUuid == vms[i].vmNics[j].l3NetworkUuid) {
                                vms[i].defaultIp = vms[i].vmNics[j].ip;
                                break;
                            }
                        }
                    }
                    var hostUuids = [];
                    for (var j in vms) {
                        var vm = vms[j];
                        if (vm.state == 'Running') {
                            hostUuids.push(vm.hostUuid);
                        }
                    }
                    if (hostUuids.length > 0) {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.addCondition({ name: 'uuid', op: 'in', value: hostUuids.join() });
                        _this.hostMgr.query(qobj, function (hosts, total) {
                            for (var i in vms) {
                                for (var j in hosts) {
                                    if (vms[i].hostUuid == hosts[j].uuid) {
                                        vms[i].managementIp = hosts[j].managementIp;
                                    }
                                }
                            }
                        });
                    }
                });
            };
        }
        return OVmInstanceGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, vmMgr) {
            this.$scope = $scope;
            this.vmMgr = vmMgr;
        }
        Action.prototype.start = function () {
            this.vmMgr.start(this.$scope.model.current);
        };
        Action.prototype.stop = function () {
            this.vmMgr.stop(this.$scope.model.current);
        };
        Action.prototype.reboot = function () {
            this.vmMgr.reboot(this.$scope.model.current);
        };
        Action.prototype.migrate = function () {
            this.$scope.migrateVm.open();
        };
        Action.prototype.attachVolume = function () {
            this.$scope.attachVolume.open();
        };
        Action.prototype.detachVolume = function () {
            this.$scope.detachVolume.open();
        };
        Action.prototype.attachL3Network = function () {
            this.$scope.attachL3Network.open();
        };
        Action.prototype.detachL3Network = function () {
            this.$scope.detachL3Network.open();
        };
        Action.prototype.console = function () {
            this.$scope.console();
        };
        Action.prototype.changeInstanceOffering = function () {
            this.$scope.changeInstanceOffering.open();
        };
        Action.prototype.isActionShow = function (action) {
            if (!Utils.notNullnotUndefined(this.$scope.model.current) || Utils.isEmptyObject(this.$scope.model.current)) {
                return false;
            }
            if (action == 'start') {
                return this.$scope.model.current.state == 'Stopped';
            }
            else if (action == 'stop') {
                return this.$scope.model.current.state == 'Running';
            }
            else if (action == 'reboot') {
                return this.$scope.model.current.state == 'Running';
            }
            else if (action == 'migrate') {
                return this.$scope.model.current.state == 'Running';
            }
            else if (action == 'attachVolume') {
                return this.$scope.model.current.state == 'Running' || this.$scope.model.current.state == 'Stopped';
            }
            else if (action == 'detachVolume' && Utils.notNullnotUndefined(this.$scope.model.current)) {
                return this.$scope.model.current.allVolumes.length > 0;
            }
            else if (action == 'console' && Utils.notNullnotUndefined(this.$scope.model.current)) {
                return this.$scope.model.current.state == 'Starting' || this.$scope.model.current.state == 'Running' || this.$scope.model.current.state == 'Rebooting' || this.$scope.model.current.state == 'Stopping';
            }
            else if (action == 'attachL3Network' && Utils.notNullnotUndefined(this.$scope.model.current)) {
                return this.$scope.model.current.state == 'Running' || this.$scope.model.current.state == 'Stopped';
            }
            else if (action == 'detachL3Network' && Utils.notNullnotUndefined(this.$scope.model.current)) {
                return (this.$scope.model.current.state == 'Running' || this.$scope.model.current.state == 'Stopped') &&
                    this.$scope.model.current.vmNics.length > 0;
            }
            else if (action == 'changeInstanceOffering' && Utils.notNullnotUndefined(this.$scope.model.current)) {
                return this.$scope.model.current.state == 'Running' || this.$scope.model.current.state == 'Stopped';
            }
            else {
                return false;
            }
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, hypervisorTypes) {
            var _this = this;
            this.$scope = $scope;
            this.hypervisorTypes = hypervisorTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"vm.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"vm.ts.State" | translate}}',
                            value: FilterBy.STATE
                        },
                        {
                            name: '{{"vm.ts.HypervisorType" | translate}}',
                            value: FilterBy.TYPE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(VmInstance.STATES);
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(_this.hypervisorTypes);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oVmInstanceGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        FilterBy.TYPE = 'hypervisorType';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, vmMgr, $routeParams, tagService, vm, clusterMgr, $rootScope, $window) {
            var _this = this;
            this.$scope = $scope;
            this.vmMgr = vmMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            var current = vm.vm;
            $scope.model = new VmInstanceModel();
            $scope.model.current = current;
            $scope.hostname = vm.hostname;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, vmMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.funcDeleteVmInstance = function () {
                $scope.deleteVmInstance.open();
            };
            $scope.optionsDeleteVmInstance = {
                title: 'DELETE VM INSTANCE',
                btnType: 'btn-danger',
                width: '350px',
                description: function () {
                    return current.name;
                },
                confirm: function () {
                    vmMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.console = function () {
                vmMgr.getConsole(current, function (inv) {
                    var windowName = current.name + current.uuid;
                    $window.open(Utils.sprintf('/static/templates/console/vnc_auto.html?host={0}&port={1}&token={2}', inv.hostname, inv.port, inv.token), windowName);
                });
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeVmInstanceVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsMigrateVm = {
                vm: current
            };
            $scope.optionsChangeInstanceOffering = {
                vm: current
            };
            $scope.optionsAttachL3Network = {
                vm: current,
                done: function () {
                    $scope.funcRefresh();
                }
            };
            $scope.optionsDetachL3Network = {
                vm: current,
                done: function () {
                    $scope.funcRefresh();
                }
            };
            $scope.optionsAttachVolume = {
                vm: current,
                done: function (vol) {
                    $scope.optionsVolumeGrid.dataSource.insert(0, vol);
                }
            };
            $scope.optionsDetachVolume = {
                vm: current,
                done: function (vol) {
                    var ds = $scope.optionsVolumeGrid.dataSource;
                    var cs = ds.data();
                    for (var i = 0; i < cs.length; i++) {
                        var tcs = cs[i];
                        if (vol.uuid == tcs.uuid) {
                            var row = ds.getByUid(tcs.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
            $scope.optionsNicGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'deviceId',
                        title: '{{"vm.ts.DEVICE ID" | translate}}',
                        width: '4%'
                    },
                    {
                        field: 'l3NetworkUuid',
                        title: '{{"vm.ts.L3 Network" | translate}}',
                        width: '20%',
                        template: '<a href="/\\#/l3Network/{{dataItem.l3NetworkUuid}}">{{dataItem.l3NetworkUuid}}</a>'
                    },
                    {
                        field: 'ip',
                        title: '{{"vm.ts.IP" | translate}}',
                        width: '14%'
                    },
                    {
                        field: 'netmask',
                        title: '{{"vm.ts.NETMASK" | translate}}',
                        width: '14%'
                    },
                    {
                        field: 'gateway',
                        title: '{{"vm.ts.GATEWAY" | translate}}',
                        width: '14%'
                    },
                    {
                        field: 'mac',
                        title: '{{"vm.ts.MAC" | translate}}',
                        width: '14%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"vm.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    data: current.vmNics
                })
            };
            $scope.optionsVolumeGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'deviceId',
                        title: '{{"vm.ts.DEVICE ID" | translate}}',
                        width: '10%',
                        template: '<a href="/\\#/volume/{{dataItem.uuid}}">{{dataItem.deviceId}}</a>'
                    },
                    {
                        field: 'name',
                        title: '{{"vm.ts.NAME" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'type',
                        title: '{{"vm.ts.TYPE" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'state',
                        title: '{{"vm.ts.STATE" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'status',
                        title: '{{"vm.ts.STATUS" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"vm.ts.UUID" | translate}}',
                        width: '18%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    data: current.allVolumes
                })
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.vmMgr.query(qobj, function (vms, total) {
                Utils.safeApply(_this.$scope, function () {
                    var c = _this.$scope.model.current = vms[0];
                    _this.$scope.optionsNicGrid.dataSource.data(c.vmNics);
                    _this.$scope.optionsVolumeGrid.dataSource.data(c.allVolumes);
                });
            });
        };
        DetailsController.$inject = ['$scope', 'VmInstanceManager', '$routeParams', 'Tag', 'current', 'ClusterManager', '$rootScope', '$window'];
        return DetailsController;
    })();
    MVmInstance.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, vmMgr, hostMgr, hypervisorTypes, $location, $rootScope, $window, Translator, $translate) {
            this.$scope = $scope;
            this.vmMgr = vmMgr;
            this.hostMgr = hostMgr;
            this.hypervisorTypes = hypervisorTypes;
            this.$location = $location;
            this.$rootScope = $rootScope;
            this.$window = $window;
            this.Translator = Translator;
            this.$translate = $translate;
            $scope.model = new VmInstanceModel();
            $scope.oVmInstanceGrid = new OVmInstanceGrid($scope, vmMgr, hostMgr);
            $scope.action = new Action($scope, vmMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"vm.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"vm.ts.Description" | translate}}',
                        value: 'Description'
                    },
                    {
                        name: '{{"vm.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"vm.ts.Hypervisor" | translate}}',
                        value: 'hypervisorType'
                    },
                    {
                        name: '{{"vm.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"vm.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    vmMgr.setSortBy(ret);
                    $scope.oVmInstanceGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.VmInstanceInventoryQueryable,
                name: 'VmInstance',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: VmInstance.STATES
                    },
                    hypervisorType: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.hypervisorTypes
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    vmMgr.query(qobj, function (VmInstances, total) {
                        $scope.oVmInstanceGrid.refresh(VmInstances);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/vmInstance/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.hypervisorTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateVmInstance = function (win) {
                win.open();
            };
            $scope.funcDeleteVmInstance = function () {
                $scope.deleteVmInstance.open();
            };
            $scope.optionsDeleteVmInstance = {
                title: 'DELETE VM INSTANCE',
                btnType: 'btn-danger',
                width: '350px',
                description: function () {
                    return $scope.model.current.name;
                },
                confirm: function () {
                    vmMgr.delete($scope.model.current, function (ret) {
                        $scope.oVmInstanceGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oVmInstanceGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateVmInstance = {
                done: function (info) {
                    var vm = new VmInstance();
                    info.uuid = info.resourceUuid = Utils.uuid();
                    info.state = 'Starting';
                    angular.extend(vm, info);
                    vm = vmMgr.wrap(vm);
                    $scope.oVmInstanceGrid.add(vm);
                    vmMgr.create(info, function (ret) {
                        $scope.oVmInstanceGrid.refresh();
                    });
                }
            };
            $scope.console = function () {
                vmMgr.getConsole($scope.model.current, function (inv) {
                    var windowName = $scope.model.current.name + $scope.model.current.uuid;
                    $window.open(Utils.sprintf('/static/templates/console/vnc_auto.html?host={0}&port={1}&token={2}', inv.hostname, inv.port, inv.token), windowName);
                });
            };
            $scope.optionsMigrateVm = {
                vm: null
            };
            $scope.optionsChangeInstanceOffering = {
                vm: null
            };
            $scope.optionsAttachVolume = {
                vm: null
            };
            $scope.optionsDetachVolume = {
                vm: null
            };
            $scope.optionsAttachL3Network = {
                vm: null
            };
            $scope.optionsDetachL3Network = {
                vm: null
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    $scope.optionsMigrateVm.vm = $scope.model.current;
                    $scope.optionsChangeInstanceOffering.vm = $scope.model.current;
                    $scope.optionsAttachVolume.vm = $scope.model.current;
                    $scope.optionsDetachVolume.vm = $scope.model.current;
                    $scope.optionsAttachL3Network.vm = $scope.model.current;
                    $scope.optionsDetachL3Network.vm = $scope.model.current;
                }
            });
        }
        Controller.$inject = ['$scope', 'VmInstanceManager', 'HostManager', 'hypervisorTypes', '$location', '$rootScope', '$window', 'Translator', '$translate'];
        return Controller;
    })();
    MVmInstance.Controller = Controller;
    var ChangeInstanceOffering = (function () {
        function ChangeInstanceOffering(api, vmMgr, insMgr) {
            var _this = this;
            this.api = api;
            this.vmMgr = vmMgr;
            this.insMgr = insMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/vm/changeInstanceOffering.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zChangeInstanceOffering] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.instanceOfferingUuid = null;
                $scope.instanceOfferingOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.CPU Number" | translate}}</span><span>#: cpuNum #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.CPU Speed" | translate}}</span><span>#: cpuSpeed #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Memory" | translate}}</span><span>#: memorySize #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>'
                };
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.instanceOfferingUuid);
                };
                $scope.cancel = function () {
                    $scope.changeInstanceOffering__.close();
                };
                $scope.done = function () {
                    vmMgr.changeInstanceOffering(_this.options.vm, $scope.instanceOfferingUuid, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.changeInstanceOffering__.close();
                };
            };
        }
        ChangeInstanceOffering.prototype.open = function () {
            var _this = this;
            this.$scope.instanceOfferingOptions__.dataSource.data([]);
            this.$scope.instanceOfferingUuid = null;
            var chain = new Utils.Chain();
            chain.then(function () {
                var q = new ApiHeader.QueryObject();
                q.addCondition({ name: 'state', op: '=', value: 'Enabled' });
                q.addCondition({ name: 'uuid', op: '!=', value: _this.options.vm.instanceOfferingUuid });
                _this.insMgr.query(q, function (ins) {
                    _this.$scope.instanceOfferingOptions__.dataSource.data(ins);
                    if (ins.length > 0) {
                        _this.$scope.instanceOfferingUuid = ins[0].uuid;
                    }
                    chain.next();
                });
            }).done(function () {
                _this.$scope.changeInstanceOffering__.center();
                _this.$scope.changeInstanceOffering__.open();
            }).start();
        };
        return ChangeInstanceOffering;
    })();
    MVmInstance.ChangeInstanceOffering = ChangeInstanceOffering;
    var MigrateVm = (function () {
        function MigrateVm(api, vmMgr) {
            var _this = this;
            this.api = api;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/vm/migrateVm.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zMigrateVmInstance] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.hostUuid = null;
                $scope.hostOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Cluster UUID" | translate}}</span><span>#: clusterUuid #</span></div>'
                };
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.hostUuid);
                };
                $scope.cancel = function () {
                    $scope.migrateVm__.close();
                };
                $scope.done = function () {
                    vmMgr.migrate(_this.options.vm, $scope.hostUuid, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.migrateVm__.close();
                };
                $scope.migrateVmOptions__ = {
                    width: '600px'
                };
            };
        }
        MigrateVm.prototype.open = function () {
            var _this = this;
            this.$scope.hostOptions__.dataSource.data([]);
            this.$scope.hostUuid = null;
            var chain = new Utils.Chain();
            chain.then(function () {
                _this.api.getVmMigrationCandidateHosts(_this.options.vm.uuid, function (hosts) {
                    _this.$scope.hostOptions__.dataSource.data(hosts);
                    if (hosts.length > 0) {
                        _this.$scope.hostUuid = hosts[0].uuid;
                    }
                    chain.next();
                });
            }).done(function () {
                _this.$scope.migrateVm__.center();
                _this.$scope.migrateVm__.open();
            }).start();
        };
        return MigrateVm;
    })();
    MVmInstance.MigrateVm = MigrateVm;
    var CreateVmInstanceOptions = (function () {
        function CreateVmInstanceOptions() {
        }
        return CreateVmInstanceOptions;
    })();
    MVmInstance.CreateVmInstanceOptions = CreateVmInstanceOptions;
    var CreateVmInstance = (function () {
        function CreateVmInstance(api, vmMgr, clusterMgr, hostMgr, zoneMgr, instOfferingMgr, diskOfferingMgr, l3Mgr, imageMgr) {
            var _this = this;
            this.api = api;
            this.vmMgr = vmMgr;
            this.clusterMgr = clusterMgr;
            this.hostMgr = hostMgr;
            this.zoneMgr = zoneMgr;
            this.instOfferingMgr = instOfferingMgr;
            this.diskOfferingMgr = diskOfferingMgr;
            this.l3Mgr = l3Mgr;
            this.imageMgr = imageMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateVmInstance;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateVmInstanceOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    instanceOfferingUuid: null,
                    imageUuid: null,
                    l3NetworkUuid: null,
                    l3NetworkIp: null,
                    l3NetworkUuids: [],
                    l3NetworkStaticIps: [],
                    dataDiskOfferingUuids: [],
                    rootDiskOfferingUuid: null,
                    imageMediaType: null,
                    images: {},
                    defaultL3NetworkUuid: null,
                    hostname: null,
                    hasImage: function () {
                        return $scope.imageOptions__.dataSource.data().length > 0;
                    },
                    hasInstanceOffering: function () {
                        return $scope.instanceOfferingOptions__.dataSource.data().length > 0;
                    },
                    hasL3Network: function () {
                        return $scope.l3NetworkGrid__.dataSource.data().length > 0;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        if (this.imageMediaType == 'RootVolumeTemplate') {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.instanceOfferingUuid)
                                && Utils.notNullnotUndefined(this.imageUuid) && this.hasL3Network();
                        }
                        else {
                            return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.instanceOfferingUuid)
                                && Utils.notNullnotUndefined(this.imageUuid) && this.hasL3Network() && Utils.notNullnotUndefined(this.rootDiskOfferingUuid);
                        }
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createVmInstanceInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    syncL3NetworkDataFromView: function () {
                        var l3NetworkGridRawData = $scope.l3NetworkGrid__.dataSource.data();
                        this.l3NetworkUuids = [];
                        this.l3NetworkStaticIps = [];
                        for (var i = 0; i < l3NetworkGridRawData.length; ++i) {
                            this.l3NetworkUuids.push(l3NetworkGridRawData[i].uuid);
                            if (Utils.notNullnotUndefined(this.l3NetworkIp) && this.l3NetworkIp != "") {
                                this.l3NetworkStaticIps.push({
                                    uuid: l3NetworkGridRawData[i].uuid,
                                    staticIp: l3NetworkGridRawData[i].staticIp
                                });
                            }
                        }
                    },
                    addL3Network: function () {
                        if (!this.isStaticIpValid())
                            return;
                        var l3NetworkOptionsRawData = $scope.l3NetworkOptions__.dataSource.data();
                        var l3Network = null;
                        for (var i = 0; i < l3NetworkOptionsRawData.length; ++i) {
                            if (l3NetworkOptionsRawData[i].uuid == this.l3NetworkUuid) {
                                l3Network = l3NetworkOptionsRawData[i];
                                break;
                            }
                        }
                        if (Utils.notNullnotUndefined(this.l3NetworkIp)) {
                            l3Network.staticIp = this.l3NetworkIp.trim();
                        }
                        var l3NetworkGridRawData = $scope.l3NetworkGrid__.dataSource.data();
                        var updated = false;
                        for (var i = 0; i < l3NetworkGridRawData.length; ++i) {
                            if (l3NetworkGridRawData[i].uuid == l3Network.uuid) {
                                l3NetworkGridRawData[i].staticIp = l3Network.staticIp;
                                updated = true;
                                break;
                            }
                        }
                        if (!updated) {
                            $scope.l3NetworkGrid__.dataSource.pushCreate(l3Network);
                        }
                        this.syncL3NetworkDataFromView();
                        $scope.defaultL3NetworkOptions__.dataSource.data($scope.l3NetworkGrid__.dataSource.data());
                        this.l3NetworkIp = "";
                    },
                    delL3Network: function (uid) {
                        var row = $scope.l3NetworkGrid__.dataSource.getByUid(uid);
                        $scope.l3NetworkGrid__.dataSource.remove(row);
                        this.syncL3NetworkDataFromView();
                    },
                    isStaticIpValid: function () {
                        if (Utils.notNullnotUndefined(this.l3NetworkIp)) {
                            if (this.l3NetworkIp.trim() == "")
                                return true;
                            else
                                return Utils.isIpv4Address(this.l3NetworkIp);
                        }
                        return true;
                    },
                    getPageName: function () {
                        return 'createVmInstanceInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('vm');
                        this.description = null;
                        this.imageUuid = null;
                        this.dataDiskOfferingUuids = [];
                        this.l3NetworkIp = null;
                        this.l3NetworkUuids = [];
                        this.instanceOfferingUuid = null;
                        this.activeState = false;
                        this.rootDiskOfferingUuid = null;
                        this.defaultL3NetworkUuid = null;
                        this.images = {};
                        this.hostname = null;
                    }
                };
                $scope.l3NetworkGrid__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            width: '12%',
                            title: '',
                            template: '<button type="button" class="btn btn-xs btn-default" ng-click="infoPage.delL3Network(dataItem.uid)"><i class="fa fa-times"></i></button>'
                        },
                        {
                            field: 'name',
                            title: '{{"vm.ts.NAME" | translate}}',
                            width: '44%'
                        },
                        {
                            field: 'staticIp',
                            title: '{{"vm.ts.STATIC IP" | translate}}',
                            width: '44%'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.total() == 0 || grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource([])
                };
                var locationPage = $scope.locationPage = {
                    activeState: false,
                    zoneUuid: null,
                    clusterUuid: null,
                    hostUuid: null,
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createVmInstanceLocation"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createVmInstanceLocation';
                    },
                    reset: function () {
                        this.activeState = false;
                        this.zoneUuid = null;
                        this.clusterUuid = null;
                        this.hostUuid = null;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        $scope.infoPage.hostUuid = $scope.locationPage.hostUuid;
                        $scope.infoPage.clusterUuid = $scope.locationPage.clusterUuid;
                        $scope.infoPage.zoneUuid = $scope.locationPage.zoneUuid;
                        _this.options.done(infoPage);
                        $scope.winCreateVmInstance__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage, locationPage
                ], mediator);
                $scope.$watch(function () {
                    return $scope.locationPage.zoneUuid;
                }, function () {
                    var zuuid = $scope.locationPage.zoneUuid;
                    if (Utils.notNullnotUndefined(zuuid)) {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'zoneUuid',
                                op: '=',
                                value: zuuid
                            }
                        ];
                        _this.clusterMgr.query(qobj, function (clusters) {
                            _this.$scope.clusterOptions__.dataSource.data(clusters);
                        });
                    }
                });
                $scope.$watch(function () {
                    return $scope.locationPage.clusterUuid;
                }, function () {
                    var clusterUuid = $scope.locationPage.clusterUuid;
                    if (Utils.notNullnotUndefined(clusterUuid)) {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'clusterUuid',
                                op: '=',
                                value: clusterUuid
                            }
                        ];
                        _this.hostMgr.query(qobj, function (hosts) {
                            _this.$scope.hostOptions__.dataSource.data(hosts);
                        });
                    }
                });
                $scope.$watch(function () {
                    return $scope.infoPage.imageUuid;
                }, function () {
                    if (!Utils.notNullnotUndefined($scope.infoPage.imageUuid)) {
                        return;
                    }
                    var img = $scope.infoPage.images[$scope.infoPage.imageUuid];
                    if (Utils.notNullnotUndefined(img)) {
                        $scope.infoPage.imageMediaType = img.mediaType;
                    }
                });
                $scope.zoneOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span>: #: name #</div>' + '<div style="color: black"><span class="z-label">{{"vm.ts.State" | translate}}</span>#: state #</div>' + '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span> #: uuid #</div>',
                    optionLabel: ""
                };
                $scope.winCreateVmInstanceOptions__ = {
                    width: '700px',
                    //height: '620px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.clusterOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    optionLabel: "",
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.NAME" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.HYPERVISOR" | translate}}</span><span>#: hypervisorType #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>'
                };
                $scope.hostOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    optionLabel: "",
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.State" | translate}}</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Status" | translate}}</span><span>#: status #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>'
                };
                $scope.instanceOfferingOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.CPU Number" | translate}}</span><span>#: cpuNum #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.CPU Speed" | translate}}</span><span>#: cpuSpeed #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Memory" | translate}}</span><span>#: memorySize #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>'
                };
                $scope.diskOfferingOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Disk Size" | translate}}</span><span>#: diskSize #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        Utils.safeApply($scope, function () {
                            var list = e.sender;
                            $scope.infoPage.dataDiskOfferingUuids = [];
                            angular.forEach(list.dataItems(), function (it) {
                                $scope.infoPage.dataDiskOfferingUuids.push(it.uuid);
                            });
                        });
                    }
                };
                $scope.rootDiskOfferingOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Disk Size" | translate}}</span><span>#: diskSize #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>'
                };
                $scope.l3NetworkOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>'
                };
                $scope.defaultL3NetworkOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>'
                };
                $scope.imageOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vm.ts.Name" | translate}}</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Platform" | translate}}</span><span>#: platform #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Media Type" | translate}}</span><span>#= mediaType #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.Format" | translate}}</span><span>#: format #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vm.ts.UUID" | translate}}</span><span>#: uuid #</span></div>'
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/vm/createVm.html';
        }
        CreateVmInstance.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateVmInstance__;
            var chain = new Utils.Chain();
            this.$scope.clusterOptions__.dataSource.data([]);
            this.$scope.hostOptions__.dataSource.data([]);
            this.$scope.l3NetworkOptions__.dataSource.data([]);
            this.$scope.l3NetworkGrid__.dataSource.data([]);
            this.$scope.diskOfferingOptions__.dataSource.data([]);
            this.$scope.diskOfferingList__.value([]);
            this.$scope.button.reset();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'state',
                        op: '=',
                        value: 'Enabled'
                    }
                ];
                _this.instOfferingMgr.query(qobj, function (instanceOfferings) {
                    _this.$scope.instanceOfferingOptions__.dataSource.data(instanceOfferings);
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'state',
                        op: '=',
                        value: 'Enabled'
                    }
                ];
                _this.diskOfferingMgr.query(qobj, function (diskOfferings) {
                    _this.$scope.diskOfferingOptions__.dataSource.data(diskOfferings);
                    _this.$scope.rootDiskOfferingOptions__.dataSource.data(diskOfferings);
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'state',
                        op: '=',
                        value: 'Enabled'
                    },
                    {
                        name: 'system',
                        op: '=',
                        value: 'false'
                    }
                ];
                _this.l3Mgr.query(qobj, function (l3s) {
                    _this.$scope.l3NetworkOptions__.dataSource.data(l3s);
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [];
                _this.zoneMgr.query(qobj, function (zones) {
                    //var zs = [{uuid: 'none'}];
                    //zs = zs.concat(zones);
                    _this.$scope.zoneOptions__.dataSource.data(zones);
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'state',
                        op: '=',
                        value: 'Enabled'
                    },
                    {
                        name: 'status',
                        op: '=',
                        value: 'Ready'
                    },
                    {
                        name: 'system',
                        op: '=',
                        value: 'false'
                    },
                    {
                        name: 'mediaType',
                        op: 'in',
                        value: ['RootVolumeTemplate', 'ISO'].join()
                    }
                ];
                _this.imageMgr.query(qobj, function (images) {
                    angular.forEach(images, function (it) {
                        if (!Utils.notNullnotUndefined(it.guestOsType)) {
                            it.guestOsType = "";
                        }
                        _this.$scope.infoPage.images[it.uuid] = it;
                    });
                    _this.$scope.imageOptions__.dataSource.data(images);
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreateVmInstance;
    })();
    MVmInstance.CreateVmInstance = CreateVmInstance;
    var AttachL3Network = (function () {
        function AttachL3Network(api, vmMgr) {
            var _this = this;
            this.api = api;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/vm/attachL3Network.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zVmAttachL3Network] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.l3NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">State:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.cancel = function () {
                    $scope.attachL3Network__.close();
                };
                $scope.done = function () {
                    var vols = $scope.l3NetworkList__.dataItems();
                    angular.forEach(vols, function (it) {
                        vmMgr.attachL3Network(_this.options.vm, it.uuid, function () {
                            if (_this.options.done) {
                                _this.options.done();
                            }
                        });
                    });
                    $scope.attachL3Network__.close();
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                _this.$scope = $scope;
            };
        }
        AttachL3Network.prototype.open = function () {
            var _this = this;
            this.$scope.l3NetworkList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                _this.api.getVmAttachableL3Networks(_this.options.vm.uuid, function (l3s) {
                    _this.$scope.l3NetworkListOptions__.dataSource.data(l3s);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachL3Network__.center();
                _this.$scope.attachL3Network__.open();
            }).start();
        };
        return AttachL3Network;
    })();
    MVmInstance.AttachL3Network = AttachL3Network;
    var DetachL3Network = (function () {
        function DetachL3Network(api, vmMgr, l3Mgr) {
            var _this = this;
            this.api = api;
            this.vmMgr = vmMgr;
            this.l3Mgr = l3Mgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/vm/detachL3Network.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zVmDetachL3Network] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.l3NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "l3NetworkName",
                    dataValueField: "nicUuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">L3 Network:</span><span>#: l3NetworkName #</span></div>' +
                        '<div style="color: black"><span class="z-label">Nic Device ID:</span><span>#: deviceId #</span></div>' +
                        '<div style="color: black"><span class="z-label">Nic UUID:</span><span>#: nicUuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.cancel = function () {
                    $scope.detachL3Network__.close();
                };
                $scope.done = function () {
                    var vols = $scope.l3NetworkList__.dataItems();
                    angular.forEach(vols, function (it) {
                        vmMgr.detachL3Network(_this.options.vm, it.nicUuid, function () {
                            if (_this.options.done) {
                                _this.options.done();
                            }
                        });
                    });
                    $scope.detachL3Network__.close();
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                _this.$scope = $scope;
            };
        }
        DetachL3Network.prototype.open = function () {
            var _this = this;
            this.$scope.l3NetworkList__.value([]);
            var chain = new Utils.Chain();
            var l3Uuids = [];
            chain.then(function () {
                angular.forEach(_this.options.vm.vmNics, function (it) {
                    l3Uuids.push(it.l3NetworkUuid);
                });
                chain.next();
            }).then(function () {
                var l3Networks = [];
                var qobj = new ApiHeader.QueryObject();
                qobj.addCondition({ name: "uuid", op: "in", value: l3Uuids.join() });
                _this.l3Mgr.query(qobj, function (l3s) {
                    angular.forEach(l3s, function (l3) {
                        angular.forEach(_this.options.vm.vmNics, function (nic) {
                            if (l3.uuid == nic.l3NetworkUuid) {
                                var l3obj = {
                                    l3NetworkName: l3.name,
                                    deviceId: nic.deviceId,
                                    nicUuid: nic.uuid
                                };
                                l3Networks.push(l3obj);
                            }
                        });
                    });
                    _this.$scope.l3NetworkListOptions__.dataSource.data(l3Networks);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.detachL3Network__.center();
                _this.$scope.detachL3Network__.open();
            }).start();
        };
        return DetachL3Network;
    })();
    MVmInstance.DetachL3Network = DetachL3Network;
    var AttachVolume = (function () {
        function AttachVolume(api, vmMgr) {
            var _this = this;
            this.api = api;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/vm/attachVolume.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zVmAttachVolume] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.volumeListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">State:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">Status:</span><span>#: status #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.cancel = function () {
                    $scope.attachVolume__.close();
                };
                $scope.done = function () {
                    var vols = $scope.volumeList__.dataItems();
                    angular.forEach(vols, function (it) {
                        vmMgr.attachVolume(_this.options.vm, it.uuid, function (vol) {
                            if (_this.options.done) {
                                _this.options.done(vol);
                            }
                        });
                    });
                    $scope.attachVolume__.close();
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                _this.$scope = $scope;
            };
        }
        AttachVolume.prototype.open = function () {
            var _this = this;
            this.$scope.volumeList__.value([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                _this.api.getVmAttachableVolume(_this.options.vm.uuid, function (vols) {
                    _this.$scope.volumeListOptions__.dataSource.data(vols);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachVolume__.center();
                _this.$scope.attachVolume__.open();
            }).start();
        };
        return AttachVolume;
    })();
    MVmInstance.AttachVolume = AttachVolume;
    var DetachVolume = (function () {
        function DetachVolume(api, vmMgr) {
            var _this = this;
            this.api = api;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/vm/detachVolume.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zVmDetachVolume] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.volumeListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">Name:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">State:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">Status:</span><span>#: status #</span></div>' +
                        '<div style="color: black"><span class="z-label">Size:</span><span>#: size #</span></div>' +
                        '<div style="color: black"><span class="z-label">UUID:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.cancel = function () {
                    $scope.detachVolume__.close();
                };
                $scope.done = function () {
                    var vols = $scope.volumeList__.dataItems();
                    angular.forEach(vols, function (it) {
                        vmMgr.detachVolume(_this.options.vm, it.uuid, function () {
                            if (_this.options.done) {
                                _this.options.done(it);
                            }
                        });
                    });
                    $scope.detachVolume__.close();
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                _this.$scope = $scope;
            };
        }
        DetachVolume.prototype.open = function () {
            var dvols = [];
            this.$scope.volumeList__.value(dvols);
            angular.forEach(this.options.vm.allVolumes, function (it) {
                if (it.type != 'Root') {
                    dvols.push(it);
                }
            });
            this.$scope.volumeListOptions__.dataSource.data(dvols);
            this.$scope.detachVolume__.center();
            this.$scope.detachVolume__.open();
        };
        return DetachVolume;
    })();
    MVmInstance.DetachVolume = DetachVolume;
})(MVmInstance || (MVmInstance = {}));
angular.module('root').factory('VmInstanceManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MVmInstance.VmInstanceManager(api, $rootScope);
    }]).directive('zCreateVmInstance', ['Api', 'VmInstanceManager', 'ClusterManager', 'HostManager',
    'ZoneManager', 'InstanceOfferingManager', 'DiskOfferingManager', 'L3NetworkManager', 'ImageManager',
    function (api, vmMgr, clusterMgr, hostMgr, zoneMgr, instOfferingMgr, diskOfferingMgr, l3Mgr, imageMgr) {
        return new MVmInstance.CreateVmInstance(api, vmMgr, clusterMgr, hostMgr, zoneMgr, instOfferingMgr, diskOfferingMgr, l3Mgr, imageMgr);
    }]).directive('zMigrateVmInstance', ['Api', 'VmInstanceManager', function (api, vmMgr) {
        return new MVmInstance.MigrateVm(api, vmMgr);
    }]).directive('zChangeInstanceOffering', ['Api', 'VmInstanceManager', 'InstanceOfferingManager', function (api, vmMgr, insMgr) {
        return new MVmInstance.ChangeInstanceOffering(api, vmMgr, insMgr);
    }]).directive('zVmAttachVolume', ['Api', 'VmInstanceManager', function (api, vmMgr) {
        return new MVmInstance.AttachVolume(api, vmMgr);
    }]).directive('zVmDetachVolume', ['Api', 'VmInstanceManager', function (api, vmMgr) {
        return new MVmInstance.DetachVolume(api, vmMgr);
    }]).directive('zVmAttachL3Network', ['Api', 'VmInstanceManager', function (api, vmMgr) {
        return new MVmInstance.AttachL3Network(api, vmMgr);
    }]).directive('zVmDetachL3Network', ['Api', 'VmInstanceManager', 'L3NetworkManager', function (api, vmMgr, l3Mgr) {
        return new MVmInstance.DetachL3Network(api, vmMgr, l3Mgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/vmInstance', {
            templateUrl: '/static/templates/vm/vm.html',
            controller: 'MVmInstance.Controller',
            resolve: {
                hypervisorTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getHypervisorTypes(function (hypervisorTypes) {
                        defer.resolve(hypervisorTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/vmInstance/:uuid', {
            templateUrl: '/static/templates/vm/details.html',
            controller: 'MVmInstance.DetailsController',
            resolve: {
                current: function ($q, $route, VmInstanceManager, Api) {
                    var defer = $q.defer();
                    var chain = new Utils.Chain();
                    var ret = {
                        vm: null,
                        hostname: null
                    };
                    chain.then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        var uuid = $route.current.params.uuid;
                        qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                        VmInstanceManager.query(qobj, function (vms) {
                            ret.vm = vms[0];
                            chain.next();
                        }, true);
                    }).then(function () {
                        var msg = new ApiHeader.APIQuerySystemTagMsg();
                        msg.conditions = [{
                                name: 'resourceUuid',
                                op: '=',
                                value: $route.current.params.uuid
                            }, {
                                name: 'tag',
                                op: 'like',
                                value: 'hostname::%'
                            }];
                        Api.syncApi(msg, function (reply) {
                            var invs = reply.inventories;
                            if (invs.length > 0) {
                                var pair = invs[0].tag.split('::');
                                ret.hostname = pair[1];
                            }
                            chain.next();
                        });
                    }).done(function () {
                        defer.resolve(ret);
                    }).start();
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MVolume;
(function (MVolume) {
    var VolumeSnapshot = (function (_super) {
        __extends(VolumeSnapshot, _super);
        function VolumeSnapshot() {
            _super.apply(this, arguments);
        }
        VolumeSnapshot.prototype.progressOn = function () {
            this.inProgress = true;
        };
        VolumeSnapshot.prototype.progressOff = function () {
            this.inProgress = false;
        };
        VolumeSnapshot.prototype.isInProgress = function () {
            return this.inProgress;
        };
        VolumeSnapshot.prototype.isRevertShow = function () {
            return Utils.notNullnotUndefined(this.volumeUuid) && this.status == 'Ready';
        };
        VolumeSnapshot.prototype.isBackupShow = function () {
            return Utils.notNullnotUndefined(this.primaryStorageUuid);
        };
        VolumeSnapshot.prototype.isDeleteFromBackupStorageShow = function () {
            return this.backupStorageRefs.length > 0;
        };
        VolumeSnapshot.prototype.statusLabel = function () {
            if (this.status == 'Ready') {
                return 'label label-success';
            }
            else if (this.status == 'NotInstantiated') {
                return 'label label-warning';
            }
            else {
                return 'label label-default';
            }
        };
        VolumeSnapshot.prototype.updateObservableObject = function (inv) {
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('type', inv.type);
            self.set('volumeUuid', inv.volumeUuid);
            self.set('treeUuid', inv.treeUuid);
            self.set('format', inv.format);
            self.set('parentUuid', inv.parentUuid);
            self.set('primaryStorageUuid', inv.primaryStorageUuid);
            self.set('primaryStorageInstallPath', inv.primaryStorageInstallPath);
            self.set('volumeType', inv.volumeType);
            self.set('latest', inv.latest);
            self.set('size', inv.size);
            self.set('state', inv.state);
            self.set('status', inv.status);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
            self.set('backupStorageRefs', inv.backupStorageRefs);
        };
        VolumeSnapshot.wrap = function (obj) {
            var sp = new VolumeSnapshot();
            angular.extend(sp, obj);
            return new kendo.data.ObservableObject(sp);
        };
        return VolumeSnapshot;
    })(ApiHeader.VolumeSnapshotInventory);
    MVolume.VolumeSnapshot = VolumeSnapshot;
    var Volume = (function (_super) {
        __extends(Volume, _super);
        function Volume() {
            _super.apply(this, arguments);
        }
        Volume.prototype.progressOn = function () {
            this.inProgress = true;
        };
        Volume.prototype.progressOff = function () {
            this.inProgress = false;
        };
        Volume.prototype.isInProgress = function () {
            return this.inProgress;
        };
        Volume.prototype.isDetachShow = function () {
            return this.type == 'Data' && Utils.notNullnotUndefined(this.vmInstanceUuid);
        };
        Volume.prototype.isAttachShow = function () {
            return this.type == 'Data' && this.state == 'Enabled' && this.status != 'Creating' && !this.isDetachShow();
        };
        Volume.prototype.isSnapshotShow = function () {
            return this.status == 'Ready';
        };
        Volume.prototype.isBackupShow = function () {
            return this.type == 'Data' && this.status == 'Ready';
        };
        Volume.prototype.isCreateTemplateShow = function () {
            return this.type == 'Root' && this.status == 'Ready';
        };
        Volume.prototype.isDeleteShow = function () {
            return this.type == 'Data';
        };
        Volume.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        Volume.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        Volume.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        Volume.prototype.statusLabel = function () {
            if (this.status == 'Ready') {
                return 'label label-success';
            }
            else if (this.status == 'NotInstantiated') {
                return 'label label-warning';
            }
            else {
                return 'label label-default';
            }
        };
        Volume.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('primaryStorageUuid', inv.primaryStorageUuid);
            self.set('vmInstanceUuid', inv.vmInstanceUuid);
            self.set('diskOfferingUuid', inv.diskOfferingUuid);
            self.set('rootImageUuid', inv.rootImageUuid);
            self.set('installPath', inv.installPath);
            self.set('type', inv.type);
            self.set('status', inv.status);
            self.set('format', inv.format);
            self.set('size', inv.size);
            self.set('state', inv.state);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return Volume;
    })(ApiHeader.VolumeInventory);
    MVolume.Volume = Volume;
    var VolumeManager = (function () {
        function VolumeManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        VolumeManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        VolumeManager.prototype.wrap = function (Volume) {
            return new kendo.data.ObservableObject(Volume);
        };
        VolumeManager.prototype.backup = function (volume, bsUuid, done) {
            var _this = this;
            var msg = new ApiHeader.APIBackupDataVolumeMsg();
            msg.backupStorageUuid = bsUuid;
            msg.uuid = volume.uuid;
            this.api.asyncApi(msg, function (ret) {
                volume.updateObservableObject(ret.inventory);
                volume.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Backup Data Volume: {0}', volume.name),
                    link: Utils.sprintf('/#/volume/{0}', volume.uuid)
                });
            });
        };
        VolumeManager.prototype.create = function (volume, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateDataVolumeMsg();
            msg.name = volume.name;
            msg.description = volume.description;
            msg.diskOfferingUuid = volume.diskOfferingUuid;
            this.api.asyncApi(msg, function (ret) {
                var c = new Volume();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new Data Volume: {0}', c.name),
                    link: Utils.sprintf('/#/volume/{0}', c.uuid)
                });
            });
        };
        VolumeManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryVolumeMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new Volume();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        VolumeManager.prototype.disable = function (volume) {
            var _this = this;
            volume.progressOn();
            var msg = new ApiHeader.APIChangeVolumeStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = volume.uuid;
            this.api.asyncApi(msg, function (ret) {
                volume.updateObservableObject(ret.inventory);
                volume.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Data Volume: {0}', volume.name),
                    link: Utils.sprintf('/#/volume/{0}', volume.uuid)
                });
            });
        };
        VolumeManager.prototype.enable = function (volume) {
            var _this = this;
            volume.progressOn();
            var msg = new ApiHeader.APIChangeVolumeStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = volume.uuid;
            this.api.asyncApi(msg, function (ret) {
                volume.updateObservableObject(ret.inventory);
                volume.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled Data Volume: {0}', volume.name),
                    link: Utils.sprintf('/#/volume/{0}', volume.uuid)
                });
            });
        };
        VolumeManager.prototype.attach = function (volume, vmUuid, done) {
            var _this = this;
            volume.progressOn();
            var msg = new ApiHeader.APIAttachDataVolumeToVmMsg();
            msg.vmInstanceUuid = vmUuid;
            msg.volumeUuid = volume.uuid;
            this.api.asyncApi(msg, function (ret) {
                volume.progressOff();
                volume.updateObservableObject(ret.inventory);
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached Data Volume: {0}', volume.name),
                    link: Utils.sprintf('/#/volume/{0}', volume.uuid)
                });
            });
        };
        VolumeManager.prototype.detach = function (volume, done) {
            var _this = this;
            volume.progressOn();
            var msg = new ApiHeader.APIDetachDataVolumeFromVmMsg();
            msg.uuid = volume.uuid;
            this.api.asyncApi(msg, function (ret) {
                volume.progressOff();
                volume.updateObservableObject(ret.inventory);
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached Data Volume: {0}', volume.name),
                    link: Utils.sprintf('/#/volume/{0}', volume.uuid)
                });
            });
        };
        VolumeManager.prototype.delete = function (volume, done) {
            var _this = this;
            volume.progressOn();
            var msg = new ApiHeader.APIDeleteDataVolumeMsg();
            msg.uuid = volume.uuid;
            this.api.asyncApi(msg, function (ret) {
                volume.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted Data Volume: {0}', volume.name)
                });
            });
        };
        VolumeManager.prototype.takeSnapshot = function (volume, snapshot, done) {
            var _this = this;
            volume.progressOn();
            var msg = new ApiHeader.APICreateVolumeSnapshotMsg();
            msg.name = snapshot.name;
            msg.description = snapshot.description;
            msg.volumeUuid = volume.uuid;
            this.api.asyncApi(msg, function (ret) {
                volume.progressOff();
                var sp = VolumeSnapshot.wrap(ret.inventory);
                if (Utils.notNullnotUndefined(done)) {
                    done(sp);
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Create snapshot from volume: {0}', volume.name),
                    link: Utils.sprintf('/#/volume/{0}', volume.uuid)
                });
            });
        };
        VolumeManager.prototype.createTemplate = function (volume, info, done) {
            var _this = this;
            volume.progressOn();
            var msg = new ApiHeader.APICreateRootVolumeTemplateFromRootVolumeMsg();
            msg.name = info.name;
            if (Utils.notNullnotUndefined(info.backupStorageUuid)) {
                msg.backupStorageUuids = [info.backupStorageUuid];
            }
            msg.description = info.description;
            msg.guestOsType = info.guestOsType;
            msg.platform = info.platform;
            msg.rootVolumeUuid = volume.uuid;
            this.api.asyncApi(msg, function (ret) {
                volume.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Create template from root volume: {0}', volume.name),
                    link: Utils.sprintf('/#/image/{0}', ret.inventory.uuid)
                });
            });
        };
        VolumeManager.prototype.querySnapshotTree = function (qobj, done) {
            var msg = new ApiHeader.APIQueryVolumeSnapshotTreeMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            this.api.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        VolumeManager.$inject = ['Api', '$rootScope'];
        return VolumeManager;
    })();
    MVolume.VolumeManager = VolumeManager;
    var VolumeModel = (function (_super) {
        __extends(VolumeModel, _super);
        function VolumeModel() {
            _super.call(this);
            this.current = new Volume();
        }
        return VolumeModel;
    })(Utils.Model);
    MVolume.VolumeModel = VolumeModel;
    var SnapshotManager = (function () {
        function SnapshotManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        SnapshotManager.prototype.queryTree = function (qobj, done) {
            var msg = new ApiHeader.APIQueryVolumeSnapshotTreeMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            this.api.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        SnapshotManager.prototype.query = function (qobj, callback) {
            var msg = new ApiHeader.APIQueryVolumeSnapshotMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    pris.push(VolumeSnapshot.wrap(inv));
                });
                callback(pris, ret.total);
            });
        };
        SnapshotManager.prototype.delete = function (sp, done) {
            var msg = new ApiHeader.APIDeleteVolumeSnapshotMsg();
            msg.uuid = sp.uuid;
            this.api.asyncApi(msg, function (ret) {
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
            });
        };
        SnapshotManager.prototype.revert = function (sp, done) {
            var _this = this;
            var msg = new ApiHeader.APIRevertVolumeFromSnapshotMsg();
            msg.uuid = sp.uuid;
            this.api.asyncApi(msg, function (ret) {
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Reverted volume: {0} to a snapshot', sp.volumeUuid),
                    link: Utils.sprintf('/#/volume/{0}', sp.volumeUuid)
                });
            });
        };
        SnapshotManager.prototype.backup = function (sp, bsUuid, done) {
            var _this = this;
            var msg = new ApiHeader.APIBackupVolumeSnapshotMsg();
            msg.backupStorageUuid = bsUuid;
            msg.uuid = sp.uuid;
            this.api.asyncApi(msg, function (ret) {
                sp.updateObservableObject(ret.inventory);
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Backup volume snapshot: {0} to a backup storage', sp.uuid)
                });
            });
        };
        SnapshotManager.prototype.deleteFromBackupStorage = function (sp, bsUuid, done) {
            var _this = this;
            var msg = new ApiHeader.APIDeleteVolumeSnapshotFromBackupStorageMsg();
            msg.backupStorageUuids = [bsUuid];
            msg.uuid = sp.uuid;
            this.api.asyncApi(msg, function (ret) {
                sp.updateObservableObject(ret.inventory);
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted volume snapshot: {0} to a backup storage', sp.uuid)
                });
            });
        };
        return SnapshotManager;
    })();
    MVolume.SnapshotManager = SnapshotManager;
    var OVolumeGrid = (function (_super) {
        __extends(OVolumeGrid, _super);
        function OVolumeGrid($scope, volumeMgr) {
            _super.call(this);
            this.volumeMgr = volumeMgr;
            _super.prototype.init.call(this, $scope, $scope.volumeGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"volume.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/volume/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'hypervisorType',
                    title: '{{"volume.ts.HYPERVISOR" | translate}}',
                    width: '10%'
                },
                {
                    field: 'type',
                    title: '{{"volume.ts.TYPE" | translate}}',
                    width: '10%'
                },
                {
                    field: 'state',
                    title: '{{"volume.ts.STATE" | translate}}',
                    width: '15%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'status',
                    title: '{{"volume.ts.STATUS" | translate}}',
                    width: '15%',
                    template: '<span class="{{dataItem.statusLabel()}}">{{dataItem.status}}</span>'
                },
                {
                    field: 'vmInstanceUuid',
                    title: 'VM INSTANCE UUID',
                    width: '20%',
                    template: '<a href="/\\#/vmInstance/{{dataItem.vmInstanceUuid}}">{{dataItem.vmInstanceUuid}}</a>'
                },
                {
                    field: 'uuid',
                    title: 'UUID',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                volumeMgr.query(qobj, function (volumes, total) {
                    options.success({
                        data: volumes,
                        total: total
                    });
                });
            };
        }
        return OVolumeGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, volumeMgr) {
            this.$scope = $scope;
            this.volumeMgr = volumeMgr;
        }
        Action.prototype.enable = function () {
            this.volumeMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.volumeMgr.disable(this.$scope.model.current);
        };
        Action.prototype.attach = function () {
            this.$scope.attachVm.open();
        };
        Action.prototype.detach = function () {
            this.$scope.detachVm.open();
        };
        Action.prototype.takeSnapshot = function () {
            this.$scope.takeSnapshot.open();
        };
        Action.prototype.backup = function () {
            this.$scope.backupDataVolumeWin.open();
        };
        Action.prototype.createTemplate = function () {
            this.$scope.createTemplateWin.open();
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, hypervisorTypes) {
            var _this = this;
            this.$scope = $scope;
            this.hypervisorTypes = hypervisorTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"volume.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"volume.ts.State" | translate}}',
                            value: FilterBy.STATE
                        },
                        {
                            name: '{{"volume.ts.Status" | translate}}',
                            value: FilterBy.STATUS
                        },
                        {
                            name: '{{"volume.ts.Type" | translate}}',
                            value: FilterBy.TYPE
                        },
                        {
                            name: '{{"volume.ts.HypervisorType" | translate}}',
                            value: FilterBy.TYPE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATUS) {
                    _this.valueList.dataSource.data(['Creating', 'Ready', 'NotInstantiated']);
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
                else if (_this.field == FilterBy.HYPERVISOR) {
                    _this.valueList.dataSource.data(_this.hypervisorTypes);
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(['Root', 'Data']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oVolumeGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        FilterBy.STATUS = 'status';
        FilterBy.TYPE = 'type';
        FilterBy.HYPERVISOR = 'hypervisorType';
        return FilterBy;
    })();
    var SnapshotAction = (function () {
        function SnapshotAction($scope, spMgr) {
            this.$scope = $scope;
            this.spMgr = spMgr;
        }
        SnapshotAction.prototype.revert = function () {
            this.$scope.revertSnapshot.open();
        };
        SnapshotAction.prototype.delete = function () {
            this.$scope.deleteSnapshotWin.open();
        };
        SnapshotAction.prototype.backup = function () {
            this.$scope.backupSnapshotWin.open();
        };
        SnapshotAction.prototype.deleteFromBackupStorage = function () {
            this.$scope.deleteSnapshotFromBackupStorageWin.open();
        };
        return SnapshotAction;
    })();
    var SnapshotDetailsController = (function () {
        function SnapshotDetailsController($scope, spMgr, $routeParams, tagService, current, vmMgr, bsMgr) {
            var _this = this;
            this.$scope = $scope;
            this.spMgr = spMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.bsMgr = bsMgr;
            $scope.model = new VolumeModel();
            $scope.model.current = current;
            this.marshalBackupStorage(current);
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new SnapshotAction($scope, spMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteSnapshot = {
                title: 'DELETE VOLUME SNAPSHOT',
                description: "All descendants of this snapshot will be deleted as well",
                confirm: function () {
                    spMgr.delete($scope.model.current, function () {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeVolumeVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsRevertSnapshot = {
                snapshot: current,
                done: function () {
                    _this.loadSelf(current.uuid);
                }
            };
            $scope.optionsBackupSnapshot = {
                snapshot: current,
                done: function () {
                    _this.loadSelf(current.uuid);
                }
            };
            $scope.optionsDeleteSnapshotFromBackupStorage = {
                snapshot: current,
                done: function () {
                    _this.loadSelf(current.uuid);
                }
            };
            $scope.optionsBackupStorageGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"volume.ts.BACKUP STORAGE NAME" | translate}}',
                        width: '20%',
                        template: '<a href="/\\#/backupStorage/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'installPath',
                        title: '{{"volume.ts.INSTALL PATH" | translate}}',
                        width: '80%'
                    },
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource([])
            };
        }
        SnapshotDetailsController.prototype.marshalBackupStorage = function (sp) {
            var _this = this;
            if (sp.backupStorageRefs.length == 0) {
                if (Utils.notNullnotUndefined(this.$scope.optionsBackupStorageGrid)) {
                    this.$scope.optionsBackupStorageGrid.dataSource.data([]);
                }
                return;
            }
            var bsUuids = [];
            angular.forEach(sp.backupStorageRefs, function (it) {
                bsUuids.push(it.backupStorageUuid);
            });
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [{
                    name: 'uuid',
                    op: 'in',
                    value: bsUuids.join()
                }];
            this.bsMgr.query(qobj, function (bss) {
                var bsMap = {};
                angular.forEach(bss, function (it) {
                    bsMap[it.uuid] = it;
                });
                var bsRef = [];
                angular.forEach(sp.backupStorageRefs, function (it) {
                    var bs = bsMap[it.backupStorageUuid];
                    bsRef.push({
                        uuid: it.backupStorageUuid,
                        name: bs.name,
                        installPath: it.installPath
                    });
                });
                _this.$scope.optionsBackupStorageGrid.dataSource.data(bsRef);
            });
        };
        SnapshotDetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.spMgr.query(qobj, function (sps, total) {
                _this.$scope.model.current = sps[0];
                _this.marshalBackupStorage(sps[0]);
            });
        };
        SnapshotDetailsController.$inject = ['$scope', 'SnapshotManager', '$routeParams', 'Tag', 'current', 'VmInstanceManager', 'BackupStorageManager'];
        return SnapshotDetailsController;
    })();
    MVolume.SnapshotDetailsController = SnapshotDetailsController;
    var DetailsController = (function () {
        function DetailsController($scope, volumeMgr, $routeParams, tagService, vol, vmMgr, spMgr, bsMgr) {
            var _this = this;
            this.$scope = $scope;
            this.volumeMgr = volumeMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.spMgr = spMgr;
            this.bsMgr = bsMgr;
            $scope.model = new VolumeModel();
            var current = vol.volume;
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, volumeMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.funcDeleteVolume = function () {
                $scope.deleteVolume.open();
            };
            $scope.optionsDeleteVolume = {
                title: 'DELETE VOLUME',
                description: function () {
                    return Utils.sprintf("The volume[{0}] will be detached from vm if attached. Confirm delete?", $scope.model.current.name);
                },
                btnType: 'btn-danger',
                confirm: function () {
                    volumeMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsDeleteSnapshot = {
                title: 'DELETE VOLUME SNAPSHOT',
                description: "All descendants of this snapshot will be deleted as well",
                confirm: function () {
                    spMgr.delete($scope.model.snapshot, function () {
                        _this.reloadSnapshot(current.uuid);
                        $scope.model.snapshot = null;
                    });
                }
            };
            $scope.deleteSnapshot = function (sp) {
                $scope.model.snapshot = sp;
                $scope.deleteSnapshotWin.open();
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeVolumeVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsAttachVm = {
                volume: current
            };
            $scope.optionsDetachVm = {
                volume: current
            };
            $scope.optionsTakeSnapshot = {
                volume: current,
                done: function (sp) {
                    _this.reloadSnapshot(sp.volumeUuid);
                }
            };
            $scope.optionsRevertSnapshot = {
                snapshot: null,
                done: function () {
                    _this.loadSelf(current.uuid);
                }
            };
            $scope.revertToSnapshot = function (sp) {
                $scope.optionsRevertSnapshot.snapshot = sp;
                $scope.revertSnapshot.open();
            };
            $scope.optionsBackupSnapshot = {
                snapshot: null
            };
            $scope.backupSnapshot = function (sp) {
                $scope.optionsBackupSnapshot.snapshot = sp;
                $scope.backupSnapshotWin.open();
            };
            $scope.optionsDeleteSnapshotFromBackupStorage = {
                snapshot: null
            };
            $scope.deleteSnapshotFromBackupStorage = function (sp) {
                $scope.optionsDeleteSnapshotFromBackupStorage.snapshot = sp;
                $scope.deleteSnapshotFromBackupStorageWin.open();
            };
            $scope.optionsSnapshotTree = {
                template: '#: item.text #' +
                    '<div class="btn-group" ng-show="dataItem.notChain == true">' +
                    '<button type="button" class="btn btn-xs dropdown-toggle" data-toggle="dropdown">' +
                    '<span class="caret"></span>' +
                    '</button>' +
                    '<ul class="dropdown-menu" role="menu">' +
                    '<li><a href="/\\#/volumeSnapshot/{{dataItem.inventory.uuid}}">See details</a></li>' +
                    '<li><a href ng-click="revertToSnapshot(dataItem.inventory)" ng-show="dataItem.inventory.isRevertShow()">Revert volume to this snapshot</a></li>' +
                    '<li><a href ng-click="backupSnapshot(dataItem.inventory)" ng-show="dataItem.inventory.isBackupShow()">Backup</a></li>' +
                    '<li><a href ng-click="deleteSnapshotFromBackupStorage(dataItem.inventory)" ng-show="dataItem.inventory.isDeleteFromBackupStorageShow()">Delete From Backup Storage</a></li>' +
                    '<li><a href style="color:red" ng-click="deleteSnapshot(dataItem.inventory)">Delete</a></li>' +
                    '</ul>' +
                    '</div>',
                dataSource: new kendo.data.HierarchicalDataSource({
                    data: []
                })
            };
            if (vol.snapshotTree.length > 0) {
                this.buildSnapshotTree(vol.snapshotTree);
            }
            $scope.optionsCreateTemplate = {
                volume: current
            };
            $scope.optionsBackupDataVolume = {
                volume: current,
                done: function () {
                    _this.loadSelf(current.uuid);
                }
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.volumeMgr.query(qobj, function (volumes, total) {
                _this.$scope.model.current = volumes[0];
            });
        };
        DetailsController.prototype.reloadSnapshot = function (volUuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'volumeUuid', op: '=', value: volUuid });
            this.spMgr.queryTree(qobj, function (trees) {
                _this.buildSnapshotTree(trees);
            });
        };
        DetailsController.prototype.buildSnapshotTree = function (trees) {
            var treeToItems = function (leaf) {
                var ret = {};
                ret['text'] = leaf.inventory.name;
                ret['inventory'] = VolumeSnapshot.wrap(leaf.inventory);
                ret['notChain'] = true;
                if (leaf.children.length > 0) {
                    ret['items'] = [];
                    angular.forEach(leaf.children, function (it) {
                        ret['items'].push(treeToItems(it));
                    });
                }
                return ret;
            };
            var strees = [];
            angular.forEach(trees, function (it) {
                strees.push({
                    text: it.current ? 'TREE-' + it.uuid + ' (CURRENT)' : 'TREE-' + it.uuid,
                    items: [
                        treeToItems(it.tree)
                    ]
                });
            });
            this.$scope.optionsSnapshotTree.dataSource.data(strees);
        };
        DetailsController.$inject = ['$scope', 'VolumeManager', '$routeParams', 'Tag', 'current', 'VmInstanceManager', 'SnapshotManager', 'BackupStorageManager'];
        return DetailsController;
    })();
    MVolume.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, volumeMgr, hypervisorTypes, $location) {
            this.$scope = $scope;
            this.volumeMgr = volumeMgr;
            this.hypervisorTypes = hypervisorTypes;
            this.$location = $location;
            $scope.model = new VolumeModel();
            $scope.oVolumeGrid = new OVolumeGrid($scope, volumeMgr);
            $scope.action = new Action($scope, volumeMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"volume.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"volume.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"volume.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"volume.ts.Status" | translate}}',
                        value: 'status'
                    },
                    {
                        name: '{{"volume.ts.Type" | translate}}',
                        value: 'type'
                    },
                    {
                        name: '{{"volume.ts.Format" | translate}}',
                        value: 'format'
                    },
                    {
                        name: '{{"volume.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"volume.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    volumeMgr.setSortBy(ret);
                    $scope.oVolumeGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.VolumeInventoryQueryable,
                name: 'Volume',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    status: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Connecting', 'Connected', 'Disconnected']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    volumeMgr.query(qobj, function (Volumes, total) {
                        $scope.oVolumeGrid.refresh(Volumes);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/volume/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.hypervisorTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateVolume = function (win) {
                win.open();
            };
            $scope.funcDeleteVolume = function () {
                $scope.deleteVolume.open();
            };
            $scope.optionsDeleteVolume = {
                title: 'DELETE DATA VOLUME',
                description: function () {
                    return Utils.sprintf("The volume[{0}] will be detached from vm if attached. Confirm delete?", $scope.model.current.name);
                },
                btnType: 'btn-danger',
                confirm: function () {
                    volumeMgr.delete($scope.model.current, function (ret) {
                        $scope.oVolumeGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oVolumeGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateVolume = {
                done: function (volume) {
                    $scope.oVolumeGrid.add(volume);
                }
            };
            $scope.optionsAttachVm = {
                volume: null
            };
            $scope.optionsDetachVm = {
                volume: null
            };
            $scope.optionsTakeSnapshot = {
                volume: null
            };
            $scope.optionsBackupDataVolume = {
                volume: null
            };
            $scope.optionsCreateTemplate = {
                volume: null
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    $scope.optionsAttachVm.volume = $scope.model.current;
                    $scope.optionsDetachVm.volume = $scope.model.current;
                    $scope.optionsTakeSnapshot.volume = $scope.model.current;
                    $scope.optionsBackupDataVolume.volume = $scope.model.current;
                    $scope.optionsCreateTemplate.volume = $scope.model.current;
                }
            });
        }
        Controller.$inject = ['$scope', 'VolumeManager', 'hypervisorTypes', '$location'];
        return Controller;
    })();
    MVolume.Controller = Controller;
    var CreateVolume = (function () {
        function CreateVolume(api, diskOfferingMgr, volumeMgr, vmMgr) {
            var _this = this;
            this.api = api;
            this.diskOfferingMgr = diskOfferingMgr;
            this.volumeMgr = volumeMgr;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateVolume;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = {};
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    diskOfferingUuid: null,
                    hasDiskOffering: function () {
                        return $scope.diskOfferingOptions__.dataSource.data().length > 0;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.diskOfferingUuid);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createVolumeInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createVolumeInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('volume');
                        this.description = null;
                        this.diskOfferingUuid = null;
                        this.activeState = false;
                    }
                };
                var attachPage = $scope.attachPage = {
                    activeState: true,
                    vmInstanceUuid: null,
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#attachVm"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'attachVm';
                    },
                    hasVm: function () {
                        return $scope.vmOptions__.dataSource.data().length > 0;
                    },
                    reset: function () {
                        this.vmInstanceUuid = null;
                        this.activeState = false;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultVolume;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            volumeMgr.create(infoPage, function (ret) {
                                resultVolume = ret;
                                chain.next();
                            });
                        }).then(function () {
                            if (Utils.notNullnotUndefined($scope.attachPage.vmInstanceUuid) && $scope.attachPage.vmInstanceUuid != '') {
                                volumeMgr.attach(resultVolume, $scope.attachPage.vmInstanceUuid, function () {
                                    chain.next();
                                });
                            }
                            else {
                                chain.next();
                            }
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultVolume);
                            }
                        }).start();
                        $scope.winCreateVolume__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage, attachPage
                ], mediator);
                $scope.winCreateVolumeOptions__ = {
                    width: '700px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.diskOfferingOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"volume.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.DISK SIZE" | translate}}:</span><span>#: diskSize #</span></div>'
                };
                $scope.vmOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    optionLabel: "",
                    template: '<div style="color: black"><span class="z-label">{{"volume.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.Hypervisor" | translate}}:</span><span>#: hypervisorType #</span></div>'
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/createVolume.html';
        }
        CreateVolume.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateVolume__;
            var chain = new Utils.Chain();
            this.$scope.diskOfferingOptions__.dataSource.data([]);
            this.$scope.button.reset();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                _this.diskOfferingMgr.query(qobj, function (dss, total) {
                    _this.$scope.diskOfferingOptions__.dataSource.data(dss);
                    if (dss.length > 0) {
                        _this.$scope.infoPage.diskOfferingUuid = dss[0].uuid;
                    }
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'state',
                        op: 'in',
                        value: ['Running', 'Stopped'].join()
                    }
                ];
                _this.vmMgr.query(qobj, function (vms) {
                    _this.$scope.vmOptions__.dataSource.data(vms);
                    _this.$scope.attachPage.vmInstanceUuid = null;
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreateVolume;
    })();
    MVolume.CreateVolume = CreateVolume;
    var AttachVm = (function () {
        function AttachVm(api, volMgr) {
            var _this = this;
            this.api = api;
            this.volMgr = volMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/attachVm.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zVolumeAttachVm] = _this;
                _this.options = parent[$attrs.zOptions];
                var onSelect = function (e) {
                    $scope.vmInstanceUuid = e.item.context.children[3].children[1].innerText;
                };
                $scope.vmInstanceListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    select: onSelect,
                    template: '<div style="color: black"><span class="z-label">{{"volume.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.Hypervisor" | translate}}:</span><span>#: hypervisorType #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.State" | translate}}:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.hasVm = function () {
                    return $scope.vmInstanceListOptions__.dataSource.data().length > 0;
                };
                $scope.vmInstanceUuid = null;
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.vmInstanceUuid);
                };
                $scope.cancel = function () {
                    $scope.attachVmInstance__.close();
                };
                $scope.done = function () {
                    volMgr.attach(_this.options.volume, $scope.vmInstanceUuid, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.attachVmInstance__.close();
                };
                _this.$scope = $scope;
            };
        }
        AttachVm.prototype.open = function () {
            var _this = this;
            this.$scope.vmInstanceListOptions__.dataSource.data([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                _this.api.getDataVolumeAttachableVm(_this.options.volume.uuid, function (vms) {
                    _this.$scope.vmInstanceListOptions__.dataSource.data(vms);
                    if (vms.length > 0) {
                        _this.$scope.vmInstanceUuid = vms[0].uuid;
                    }
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachVmInstance__.center();
                _this.$scope.attachVmInstance__.open();
            }).start();
        };
        return AttachVm;
    })();
    MVolume.AttachVm = AttachVm;
    var DetachVm = (function () {
        function DetachVm(volMgr, vmMgr) {
            var _this = this;
            this.volMgr = volMgr;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/detachVm.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zVolumeDetachVm] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.cancel = function () {
                    $scope.detachVmInstance__.close();
                };
                $scope.done = function () {
                    volMgr.detach(_this.options.volume, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.detachVmInstance__.close();
                };
                $scope.optionsDetachVm__ = {
                    width: '500px'
                };
                $scope.vmStateLabel = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return '';
                    }
                    var vm = $scope.vm;
                    if (vm.state == 'Running') {
                        return 'label label-success';
                    }
                    else if (vm.state == 'Stopped') {
                        return 'label label-danger';
                    }
                    else if (vm.state == 'Unknown') {
                        return 'label label-warning';
                    }
                    else {
                        return 'label label-default';
                    }
                };
                $scope.isVmInCorrectState = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return true;
                    }
                    return $scope.vm.state == 'Running' || $scope.vm.state == 'Stopped';
                };
                $scope.canProceed = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return false;
                    }
                    return $scope.isVmInCorrectState();
                };
                _this.$scope = $scope;
            };
        }
        DetachVm.prototype.open = function () {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'uuid',
                    op: '=',
                    value: this.options.volume.vmInstanceUuid
                }
            ];
            this.vmMgr.query(qobj, function (vms) {
                if (vms.length > 0) {
                    _this.$scope.vm = vms[0];
                }
                _this.$scope.detachVmInstance__.center();
                _this.$scope.detachVmInstance__.open();
            });
        };
        return DetachVm;
    })();
    MVolume.DetachVm = DetachVm;
    var TakeSnapshot = (function () {
        function TakeSnapshot(volMgr) {
            var _this = this;
            this.volMgr = volMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/takeSnapshot.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zVolumeTakeSnapshot] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.name);
                };
                $scope.cancel = function () {
                    $scope.takeSnapshot__.close();
                };
                $scope.done = function () {
                    volMgr.takeSnapshot(_this.options.volume, {
                        name: $scope.name,
                        description: $scope.description
                    }, function (sp) {
                        if (_this.options.done) {
                            _this.options.done(sp);
                        }
                    });
                    $scope.takeSnapshot__.close();
                };
                _this.$scope = $scope;
            };
        }
        TakeSnapshot.prototype.open = function () {
            this.$scope.name = null;
            this.$scope.description = null;
            this.$scope.takeSnapshot__.center();
            this.$scope.takeSnapshot__.open();
        };
        return TakeSnapshot;
    })();
    MVolume.TakeSnapshot = TakeSnapshot;
    var RevertSnapshot = (function () {
        function RevertSnapshot(spMgr, volMgr, vmMgr) {
            var _this = this;
            this.spMgr = spMgr;
            this.volMgr = volMgr;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/revertSnapshot.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zVolumeRevertToSnapshot] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.cancel = function () {
                    $scope.revertSnapshot__.close();
                };
                $scope.done = function () {
                    spMgr.revert(_this.options.snapshot, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.revertSnapshot__.close();
                };
                $scope.optionsRevertSnapshot__ = {
                    width: '500px'
                };
                $scope.isVmInCorrectState = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return true;
                    }
                    return $scope.vm.state == 'Stopped';
                };
                $scope.canProceed = function () {
                    return $scope.isVmInCorrectState();
                };
                _this.$scope = $scope;
            };
        }
        RevertSnapshot.prototype.open = function () {
            var _this = this;
            this.$scope.snapshot = this.options.snapshot;
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'allVolumes.snapshot.uuid',
                        op: '=',
                        value: _this.options.snapshot.uuid
                    }
                ];
                _this.vmMgr.query(qobj, function (vms) {
                    if (vms.length > 0) {
                        _this.$scope.vm = vms[0];
                    }
                    chain.next();
                });
            }).then(function () {
                if (!Utils.notNullnotUndefined(_this.options.snapshot.volumeUuid)) {
                    chain.next();
                    return;
                }
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'uuid',
                        op: '=',
                        value: _this.options.snapshot.volumeUuid
                    }];
                _this.volMgr.query(qobj, function (vols) {
                    _this.$scope.volume = vols[0];
                    chain.next();
                });
            }).done(function () {
                _this.$scope.revertSnapshot__.center();
                _this.$scope.revertSnapshot__.open();
            }).start();
        };
        return RevertSnapshot;
    })();
    MVolume.RevertSnapshot = RevertSnapshot;
    var BackupSnapshot = (function () {
        function BackupSnapshot(spMgr, psMgr, bsMgr) {
            var _this = this;
            this.spMgr = spMgr;
            this.psMgr = psMgr;
            this.bsMgr = bsMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/backupSnapshot.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zBackupSnapshot] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.backupStorageOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"volume.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.State" | translate}}:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.hasBackupStorage = function () {
                    return $scope.backupStorageOptions__.dataSource.data().length > 0;
                };
                $scope.bsUuid = null;
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.bsUuid);
                };
                $scope.cancel = function () {
                    $scope.backupSnapshot__.close();
                };
                $scope.done = function () {
                    spMgr.backup(_this.options.snapshot, $scope.bsUuid, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.backupSnapshot__.close();
                };
                $scope.backupSnapshotOptions__ = {
                    width: '500px'
                };
                _this.$scope = $scope;
            };
        }
        BackupSnapshot.prototype.open = function () {
            var _this = this;
            var chain = new Utils.Chain();
            var ps = null;
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'uuid',
                        op: '=',
                        value: _this.options.snapshot.primaryStorageUuid
                    }];
                _this.psMgr.query(qobj, function (pss) {
                    ps = pss[0];
                    chain.next();
                });
            }).then(function () {
                var bsUuidsAlreadyOn = [];
                angular.forEach(_this.options.snapshot.backupStorageRefs, function (it) {
                    bsUuidsAlreadyOn.push(it.backupStorageUuid);
                });
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'uuid',
                        op: 'not in',
                        value: bsUuidsAlreadyOn.join()
                    }, {
                        name: 'attachedZoneUuids',
                        op: 'in',
                        value: [ps.zoneUuid].join()
                    }];
                _this.bsMgr.query(qobj, function (bss) {
                    _this.$scope.backupStorageOptions__.dataSource.data(bss);
                    if (bss.length > 0) {
                        _this.$scope.bsUuid = bss[0].uuid;
                    }
                    chain.next();
                });
            }).done(function () {
                _this.$scope.backupSnapshot__.center();
                _this.$scope.backupSnapshot__.open();
            }).start();
        };
        return BackupSnapshot;
    })();
    MVolume.BackupSnapshot = BackupSnapshot;
    var BackupDataVolume = (function () {
        function BackupDataVolume(volMgr, psMgr, bsMgr) {
            var _this = this;
            this.volMgr = volMgr;
            this.psMgr = psMgr;
            this.bsMgr = bsMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/backupVolume.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zBackupDataVolume] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.backupStorageOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"volume.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.State" | translate}}:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.hasBackupStorage = function () {
                    return $scope.backupStorageOptions__.dataSource.data().length > 0;
                };
                $scope.bsUuid = null;
                $scope.canProceed = function () {
                    return $scope.hasBackupStorage();
                };
                $scope.cancel = function () {
                    $scope.backupDataVolume__.close();
                };
                $scope.done = function () {
                    volMgr.backup(_this.options.volume, $scope.bsUuid, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.backupDataVolume__.close();
                };
                $scope.backupDataVolumeOptions__ = {
                    width: '500px'
                };
                _this.$scope = $scope;
            };
        }
        BackupDataVolume.prototype.open = function () {
            var _this = this;
            var chain = new Utils.Chain();
            var ps = null;
            this.$scope.bsUuid = null;
            this.$scope.backupStorageOptions__.dataSource.data([]);
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'uuid',
                        op: '=',
                        value: _this.options.volume.primaryStorageUuid
                    }];
                _this.psMgr.query(qobj, function (pss) {
                    ps = pss[0];
                    chain.next();
                });
            }).then(function () {
                var bsUuidsAlreadyOn = [];
                angular.forEach(_this.options.volume.backupStorageRefs, function (it) {
                    bsUuidsAlreadyOn.push(it.backupStorageUuid);
                });
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'uuid',
                        op: 'not in',
                        value: bsUuidsAlreadyOn.join()
                    }, {
                        name: 'attachedZoneUuids',
                        op: 'in',
                        value: [ps.zoneUuid].join()
                    }];
                _this.bsMgr.query(qobj, function (bss) {
                    _this.$scope.backupStorageOptions__.dataSource.data(bss);
                    if (bss.length > 0) {
                        _this.$scope.bsUuid = bss[0].uuid;
                    }
                    chain.next();
                });
            }).done(function () {
                _this.$scope.backupDataVolume__.center();
                _this.$scope.backupDataVolume__.open();
            }).start();
        };
        return BackupDataVolume;
    })();
    MVolume.BackupDataVolume = BackupDataVolume;
    var DeleteDataVolumeFromBackupStorage = (function () {
        function DeleteDataVolumeFromBackupStorage(volMgr, psMgr, bsMgr) {
            var _this = this;
            this.volMgr = volMgr;
            this.psMgr = psMgr;
            this.bsMgr = bsMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/deleteVolumeFromBackupStorage.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zDeleteDataVolumeFromBackupStorage] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.backupStorageOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"volume.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.State" | translate}}:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.bsUuid = null;
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.bsUuid);
                };
                $scope.cancel = function () {
                    $scope.deleteDataVolumeFromBackupStorage__.close();
                };
                $scope.done = function () {
                    volMgr.backup(_this.options.volume, $scope.bsUuid, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.deleteDataVolumeFromBackupStorage__.close();
                };
                $scope.deleteDataVolumeFromBackupStorageOptions__ = {
                    width: '500px'
                };
                _this.$scope = $scope;
            };
        }
        DeleteDataVolumeFromBackupStorage.prototype.open = function () {
            var _this = this;
            var bsUuidsAlreadyOn = [];
            angular.forEach(this.options.volume.backupStorageRefs, function (it) {
                bsUuidsAlreadyOn.push(it.backupStorageUuid);
            });
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [{
                    name: 'uuid',
                    op: 'in',
                    value: bsUuidsAlreadyOn.join()
                }];
            this.bsMgr.query(qobj, function (bss) {
                _this.$scope.backupStorageOptions__.dataSource.data(bss);
                if (bss.length > 0) {
                    _this.$scope.bsUuid = bss[0].uuid;
                }
                _this.$scope.deleteDataVolumeFromBackupStorage__.center();
                _this.$scope.deleteDataVolumeFromBackupStorage__.open();
            });
        };
        return DeleteDataVolumeFromBackupStorage;
    })();
    MVolume.DeleteDataVolumeFromBackupStorage = DeleteDataVolumeFromBackupStorage;
    var CreateTemplateFromRootVolume = (function () {
        function CreateTemplateFromRootVolume(volMgr, bsMgr, psMgr, vmMgr, api) {
            var _this = this;
            this.volMgr = volMgr;
            this.bsMgr = bsMgr;
            this.psMgr = psMgr;
            this.vmMgr = vmMgr;
            this.api = api;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/createTemplateFromVolume.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zCreateTemplateFromRootVolume] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.backupStorageOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"volume.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.State" | translate}}:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.hasBackupStorage = function () {
                    return $scope.backupStorageOptions__.dataSource.data().length > 0;
                };
                $scope.platformOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [
                            'Linux',
                            'Windows',
                            'Other',
                            'Paravirtualization'
                        ] })
                };
                $scope.bitsOptions__ = {
                    dataSource: new kendo.data.DataSource({
                        data: [64, 32]
                    })
                };
                $scope.isVmInCorrectState = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return false;
                    }
                    return $scope.vm.state == 'Stopped';
                };
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.bsUuid) && $scope.isVmInCorrectState();
                };
                $scope.cancel = function () {
                    $scope.createTemplateFromRootVolume__.close();
                };
                $scope.done = function () {
                    volMgr.createTemplate(_this.options.volume, {
                        backupStorageUuid: $scope.bsUuid,
                        name: $scope.name,
                        description: $scope.description,
                        platform: $scope.platform,
                        guestOsType: $scope.guestOsType,
                        bits: $scope.bits,
                        system: $scope.system
                    }, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.createTemplateFromRootVolume__.close();
                };
                $scope.createTemplateFromRootVolumeOptions__ = {
                    width: '600px'
                };
                _this.$scope = $scope;
            };
        }
        CreateTemplateFromRootVolume.prototype.open = function () {
            var _this = this;
            this.$scope.platform = 'Linux';
            this.$scope.bits = 64;
            this.$scope.name = null;
            this.$scope.description = null;
            this.$scope.system = false;
            this.$scope.guestOsType = null;
            this.$scope.vm = null;
            var chain = new Utils.Chain();
            var ps = null;
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'uuid',
                        op: '=',
                        value: _this.options.volume.primaryStorageUuid
                    }];
                _this.psMgr.query(qobj, function (pss) {
                    ps = pss[0];
                    chain.next();
                });
            }).then(function () {
                var bsUuidsAlreadyOn = [];
                angular.forEach(_this.options.volume.backupStorageRefs, function (it) {
                    bsUuidsAlreadyOn.push(it.backupStorageUuid);
                });
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'attachedZoneUuids',
                        op: 'in',
                        value: [ps.zoneUuid].join()
                    }];
                _this.bsMgr.query(qobj, function (bss) {
                    _this.$scope.backupStorageOptions__.dataSource.data(bss);
                    if (bss.length > 0) {
                        _this.$scope.bsUuid = bss[0].uuid;
                    }
                    chain.next();
                });
            }).then(function () {
                var msg = new ApiHeader.APIQueryVmInstanceMsg();
                msg.conditions = [{
                        name: 'allVolumes.uuid',
                        op: '=',
                        value: _this.options.volume.uuid
                    }];
                _this.api.syncApi(msg, function (ret) {
                    _this.$scope.vm = ret.inventories[0];
                    chain.next();
                });
            }).done(function () {
                _this.$scope.createTemplateFromRootVolume__.center();
                _this.$scope.createTemplateFromRootVolume__.open();
            }).start();
        };
        return CreateTemplateFromRootVolume;
    })();
    MVolume.CreateTemplateFromRootVolume = CreateTemplateFromRootVolume;
    var DeleteSnapshotFromBackupStorage = (function () {
        function DeleteSnapshotFromBackupStorage(spMgr, bsMgr) {
            var _this = this;
            this.spMgr = spMgr;
            this.bsMgr = bsMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/volume/deleteSnapshotFromBackupStorage.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zDeleteSnapshotFromBackupStorage] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.backupStorageOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"volume.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.State" | translate}}:</span><span>#: state #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"volume.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.bsUuid = null;
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.bsUuid);
                };
                $scope.cancel = function () {
                    $scope.deleteSnapshotFromBackupStorage__.close();
                };
                $scope.done = function () {
                    spMgr.deleteFromBackupStorage(_this.options.snapshot, $scope.bsUuid, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.deleteSnapshotFromBackupStorage__.close();
                };
                $scope.deleteSnapshotFromBackupStorageOptions__ = {
                    width: '500px'
                };
                _this.$scope = $scope;
            };
        }
        DeleteSnapshotFromBackupStorage.prototype.open = function () {
            var _this = this;
            var bsUuidsAlreadyOn = [];
            angular.forEach(this.options.snapshot.backupStorageRefs, function (it) {
                bsUuidsAlreadyOn.push(it.backupStorageUuid);
            });
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [{
                    name: 'uuid',
                    op: 'in',
                    value: bsUuidsAlreadyOn.join()
                }];
            this.bsMgr.query(qobj, function (bss) {
                _this.$scope.backupStorageOptions__.dataSource.data(bss);
                if (bss.length > 0) {
                    _this.$scope.bsUuid = bss[0].uuid;
                }
                _this.$scope.deleteSnapshotFromBackupStorage__.center();
                _this.$scope.deleteSnapshotFromBackupStorage__.open();
            });
        };
        return DeleteSnapshotFromBackupStorage;
    })();
    MVolume.DeleteSnapshotFromBackupStorage = DeleteSnapshotFromBackupStorage;
})(MVolume || (MVolume = {}));
angular.module('root').factory('VolumeManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MVolume.VolumeManager(api, $rootScope);
    }]).factory('SnapshotManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MVolume.SnapshotManager(api, $rootScope);
    }]).directive('zCreateVolume', ['Api', 'DiskOfferingManager', 'VolumeManager', 'VmInstanceManager', function (api, diskOfferingMgr, volumeMgr, vmMgr) {
        return new MVolume.CreateVolume(api, diskOfferingMgr, volumeMgr, vmMgr);
    }]).directive('zVolumeAttachVm', ['Api', 'VolumeManager', function (api, volMgr) {
        return new MVolume.AttachVm(api, volMgr);
    }]).directive('zVolumeDetachVm', ['VolumeManager', 'VmInstanceManager', function (volMgr, vmMgr) {
        return new MVolume.DetachVm(volMgr, vmMgr);
    }]).directive('zVolumeTakeSnapshot', ['VolumeManager', function (volMgr) {
        return new MVolume.TakeSnapshot(volMgr);
    }]).directive('zVolumeRevertToSnapshot', ['SnapshotManager', 'VolumeManager', 'VmInstanceManager', function (spMgr, volMgr, vmMgr) {
        return new MVolume.RevertSnapshot(spMgr, volMgr, vmMgr);
    }]).directive('zBackupSnapshot', ['SnapshotManager', 'PrimaryStorageManager', 'BackupStorageManager', function (spMgr, psMgr, bsMgr) {
        return new MVolume.BackupSnapshot(spMgr, psMgr, bsMgr);
    }]).directive('zBackupDataVolume', ['VolumeManager', 'PrimaryStorageManager', 'BackupStorageManager', function (volMgr, psMgr, bsMgr) {
        return new MVolume.BackupDataVolume(volMgr, psMgr, bsMgr);
    }]).directive('zDeleteSnapshotFromBackupStorage', ['SnapshotManager', 'BackupStorageManager', function (spMgr, bsMgr) {
        return new MVolume.DeleteSnapshotFromBackupStorage(spMgr, bsMgr);
    }]).directive('zCreateTemplateFromRootVolume', ['VolumeManager', 'BackupStorageManager', 'PrimaryStorageManager', 'VmInstanceManager', 'Api', function (volMgr, bsMgr, psMgr, vmMgr, api) {
        return new MVolume.CreateTemplateFromRootVolume(volMgr, bsMgr, psMgr, vmMgr, api);
    }]).config(['$routeProvider', function (route) {
        route.when('/volume', {
            templateUrl: '/static/templates/volume/volume.html',
            controller: 'MVolume.Controller',
            resolve: {
                hypervisorTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getHypervisorTypes(function (hypervisorTypes) {
                        defer.resolve(hypervisorTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/volume/:uuid', {
            templateUrl: '/static/templates/volume/details.html',
            controller: 'MVolume.DetailsController',
            resolve: {
                current: function ($q, $route, VolumeManager) {
                    var defer = $q.defer();
                    var chain = new Utils.Chain();
                    var uuid = $route.current.params.uuid;
                    var ret = {
                        volume: null,
                        snapshotTree: null
                    };
                    chain.then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                        VolumeManager.query(qobj, function (volumes) {
                            ret.volume = volumes[0];
                            chain.next();
                        });
                    }).then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [{
                                name: 'volumeUuid',
                                op: '=',
                                value: uuid
                            }];
                        VolumeManager.querySnapshotTree(qobj, function (trees) {
                            ret.snapshotTree = trees;
                            chain.next();
                        });
                    }).done(function () {
                        defer.resolve(ret);
                    }).start();
                    return defer.promise;
                }
            }
        }).when('/volumeSnapshot/:uuid', {
            templateUrl: '/static/templates/volume/snapshotDetails.html',
            controller: 'MVolume.SnapshotDetailsController',
            resolve: {
                current: function ($q, $route, SnapshotManager) {
                    var defer = $q.defer();
                    var uuid = $route.current.params.uuid;
                    var qobj = new ApiHeader.QueryObject();
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    SnapshotManager.query(qobj, function (sps) {
                        defer.resolve(sps[0]);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MSecurityGroup;
(function (MSecurityGroup) {
    var SecurityGroup = (function (_super) {
        __extends(SecurityGroup, _super);
        function SecurityGroup() {
            _super.apply(this, arguments);
        }
        SecurityGroup.prototype.progressOn = function () {
            this.inProgress = true;
        };
        SecurityGroup.prototype.progressOff = function () {
            this.inProgress = false;
        };
        SecurityGroup.prototype.isInProgress = function () {
            return this.inProgress;
        };
        SecurityGroup.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        SecurityGroup.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        SecurityGroup.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        SecurityGroup.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('rules', inv.rules);
            self.set('attachedL3NetworkUuids', inv.attachedL3NetworkUuids);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return SecurityGroup;
    })(ApiHeader.SecurityGroupInventory);
    MSecurityGroup.SecurityGroup = SecurityGroup;
    var SecurityGroupManager = (function () {
        function SecurityGroupManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        SecurityGroupManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        SecurityGroupManager.prototype.wrap = function (sg) {
            return new kendo.data.ObservableObject(sg);
        };
        SecurityGroupManager.prototype.disable = function (sg) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIChangeSecurityGroupStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = sg.uuid;
            this.api.asyncApi(msg, function (ret) {
                sg.updateObservableObject(ret.inventory);
                sg.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Security Group: {0}', sg.name),
                    link: Utils.sprintf('/#/securityGroup/{0}', sg.uuid)
                });
            });
        };
        SecurityGroupManager.prototype.enable = function (sg) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIChangeSecurityGroupStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = sg.uuid;
            this.api.asyncApi(msg, function (ret) {
                sg.updateObservableObject(ret.inventory);
                sg.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled Security Group: {0}', sg.name),
                    link: Utils.sprintf('/#/securityGroup/{0}', sg.uuid)
                });
            });
        };
        SecurityGroupManager.prototype.attachL3Network = function (sg, l3Uuid, done) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIAttachSecurityGroupToL3NetworkMsg();
            msg.l3NetworkUuid = l3Uuid;
            msg.securityGroupUuid = sg.uuid;
            this.api.asyncApi(msg, function (ret) {
                sg.updateObservableObject(ret.inventory);
                sg.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached l3Network to Security Group: {0}', sg.name),
                    link: Utils.sprintf('/#/securityGroup/{0}', sg.uuid)
                });
            });
        };
        SecurityGroupManager.prototype.detachL3Network = function (sg, l3Uuid, done) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIDetachSecurityGroupFromL3NetworkMsg();
            msg.l3NetworkUuid = l3Uuid;
            msg.securityGroupUuid = sg.uuid;
            this.api.asyncApi(msg, function (ret) {
                sg.updateObservableObject(ret.inventory);
                sg.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached l3Network from Security Group: {0}', sg.name),
                    link: Utils.sprintf('/#/securityGroup/{0}', sg.uuid)
                });
            });
        };
        SecurityGroupManager.prototype.addRule = function (sg, rules, done) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIAddSecurityGroupRuleMsg();
            msg.rules = rules;
            msg.securityGroupUuid = sg.uuid;
            this.api.asyncApi(msg, function (ret) {
                sg.updateObservableObject(ret.inventory);
                sg.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Added rule Security Group: {0}', sg.name),
                    link: Utils.sprintf('/#/securityGroup/{0}', sg.uuid)
                });
            });
        };
        SecurityGroupManager.prototype.deleteRule = function (sg, ruleUuids, done) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIDeleteSecurityGroupRuleMsg();
            msg.ruleUuids = ruleUuids;
            this.api.asyncApi(msg, function (ret) {
                sg.updateObservableObject(ret.inventory);
                sg.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted rule from Security Group: {0}', sg.name),
                    link: Utils.sprintf('/#/securityGroup/{0}', sg.uuid)
                });
            });
        };
        SecurityGroupManager.prototype.create = function (sg, done) {
            var _this = this;
            var msg = null;
            msg = new ApiHeader.APICreateSecurityGroupMsg();
            msg.name = sg.name;
            msg.description = sg.description;
            this.api.asyncApi(msg, function (ret) {
                var c = new SecurityGroup();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new Security Group: {0}', c.name),
                    link: Utils.sprintf('/#/securityGroup/{0}', c.uuid)
                });
            });
        };
        SecurityGroupManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQuerySecurityGroupMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new SecurityGroup();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        SecurityGroupManager.prototype.delete = function (sg, done) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIDeleteSecurityGroupMsg();
            msg.uuid = sg.uuid;
            this.api.asyncApi(msg, function (ret) {
                sg.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted Security Group: {0}', sg.name)
                });
            });
        };
        SecurityGroupManager.prototype.getCandidateVmNic = function (sg, done) {
            var msg = new ApiHeader.APIGetCandidateVmNicForSecurityGroupMsg();
            msg.securityGroupUuid = sg.uuid;
            this.api.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        SecurityGroupManager.prototype.addVmNic = function (sg, nicUuids, done) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIAddVmNicToSecurityGroupMsg();
            msg.securityGroupUuid = sg.uuid;
            msg.vmNicUuids = nicUuids;
            this.api.asyncApi(msg, function (ret) {
                sg.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Added vm nics to security group: {0}', sg.name)
                });
            });
        };
        SecurityGroupManager.prototype.removeVmNic = function (sg, nicUuids, done) {
            var _this = this;
            sg.progressOn();
            var msg = new ApiHeader.APIDeleteVmNicFromSecurityGroupMsg();
            msg.securityGroupUuid = sg.uuid;
            msg.vmNicUuids = nicUuids;
            this.api.asyncApi(msg, function (ret) {
                sg.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Removed vm nics from security group: {0}', sg.name)
                });
            });
        };
        SecurityGroupManager.$inject = ['Api', '$rootScope'];
        return SecurityGroupManager;
    })();
    MSecurityGroup.SecurityGroupManager = SecurityGroupManager;
    var SecurityGroupModel = (function (_super) {
        __extends(SecurityGroupModel, _super);
        function SecurityGroupModel() {
            _super.call(this);
            this.current = new SecurityGroup();
        }
        return SecurityGroupModel;
    })(Utils.Model);
    MSecurityGroup.SecurityGroupModel = SecurityGroupModel;
    var OSecurityGroupGrid = (function (_super) {
        __extends(OSecurityGroupGrid, _super);
        function OSecurityGroupGrid($scope, sgMgr) {
            _super.call(this);
            this.sgMgr = sgMgr;
            _super.prototype.init.call(this, $scope, $scope.securityGroupGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"securityGroup.ts.NAME" | translate}}',
                    width: '25%',
                    template: '<a href="/\\#/securityGroup/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"securityGroup.ts.DESCRIPTION" | translate}}',
                    width: '25%'
                },
                {
                    field: 'state',
                    title: '{{"securityGroup.ts.STATE" | translate}}',
                    width: '25%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"securityGroup.ts.UUID" | translate}}',
                    width: '25%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                sgMgr.query(qobj, function (sgs, total) {
                    options.success({
                        data: sgs,
                        total: total
                    });
                });
            };
        }
        return OSecurityGroupGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, sgMgr) {
            this.$scope = $scope;
            this.sgMgr = sgMgr;
        }
        Action.prototype.enable = function () {
            this.sgMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.sgMgr.disable(this.$scope.model.current);
        };
        Action.prototype.addRule = function () {
            this.$scope.addRule.open();
        };
        Action.prototype.deleteRule = function () {
            this.$scope.deleteRule.open();
        };
        Action.prototype.attachL3Network = function () {
            this.$scope.attachL3Network.open();
        };
        Action.prototype.detachL3Network = function () {
            this.$scope.detachL3Network.open();
        };
        Action.prototype.addNic = function () {
            this.$scope.addVmNic.open();
        };
        Action.prototype.removeNic = function () {
            this.$scope.removeVmNic.open();
        };
        Action.prototype.isDeleteRuleShow = function () {
            if (Utils.notNullnotUndefined(this.$scope.model.current.rules)) {
                return this.$scope.model.current.rules.length > 0;
            }
            return false;
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope) {
            var _this = this;
            this.$scope = $scope;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"securityGroup.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"securityGroup.ts.STATE" | translate}}',
                            value: FilterBy.STATE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oSecurityGroupGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, sgMgr, $routeParams, tagService, current, l3Mgr, api) {
            var _this = this;
            this.$scope = $scope;
            this.sgMgr = sgMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.l3Mgr = l3Mgr;
            this.api = api;
            $scope.model = new SecurityGroupModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, sgMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteSecurityGroup = {
                title: 'DELETE SECURITY GROUP',
                html: '<strong><p>Deleting security group will cause:</p></strong>' +
                    '<ul><li><strong>All rules in this security group will be deleted</strong></li>' +
                    '<li><strong>All l3Networks this security group has attached will be detached</strong></li>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    sgMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeSecurityGroupVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsRuleGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: ' ',
                        title: '{{"securityGroup.ts.TYPE" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'startPort',
                        title: '{{"securityGroup.ts.PORT START" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'endPort',
                        title: '{{"securityGroup.ts.PORT END" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'protocol',
                        title: '{{"securityGroup.ts.PROTOCOL" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'allowedCidr',
                        title: '{{"securityGroup.ts.ALLOWED CIDR" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource([])
            };
            $scope.optionsRuleGrid.dataSource.data(current.rules);
            $scope.optionsL3NetworkGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'name',
                        title: '{{"securityGroup.ts.NAME" | translate}}',
                        width: '20%',
                        template: '<a href="/\\#/l3Network/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                    },
                    {
                        field: 'description',
                        title: '{{"securityGroup.ts.DESCRIPTION" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'state',
                        title: '{{"securityGroup.ts.STATE" | translate}}',
                        width: '10%',
                        template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                    },
                    {
                        field: 'type',
                        title: '{{"securityGroup.ts.TYPE" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"securityGroup.ts.UUID" | translate}}',
                        width: '25%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource([])
            };
            if (current.attachedL3NetworkUuids.length > 0) {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'in',
                        value: current.attachedL3NetworkUuids.join()
                    }
                ];
                l3Mgr.query(qobj, function (l3s) {
                    $scope.optionsL3NetworkGrid.dataSource.data(l3s);
                });
            }
            $scope.optionsRulesGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'type',
                        title: '{{"securityGroup.ts.TYPE" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'startPort',
                        title: '{{"securityGroup.ts.PORT START" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'endPort',
                        title: '{{"securityGroup.ts.PORT END" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'protocol',
                        title: '{{"securityGroup.ts.PROTOCOL" | translate}}',
                        width: '20%'
                    },
                    {
                        field: 'allowedCidr',
                        title: '{{"securityGroup.ts.ALLOWED CIDR" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    data: current.rules
                })
            };
            $scope.optionsVmNicGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'ip',
                        title: '{{"securityGroup.ts.IP" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'deviceId',
                        title: '{{"securityGroup.ts.DEBICE ID" | translate}}',
                        width: '25%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"securityGroup.ts.UUID" | translate}}',
                        width: '25%',
                        template: '{{dataItem.uuid}}'
                    },
                    {
                        field: 'vmInstanceUuid',
                        title: '{{"securityGroup.ts.VM" | translate}}',
                        width: '25%',
                        template: '<a href="/\\#/vmInstance/{{dataItem.vmInstanceUuid}}">{{dataItem.vmInstanceUuid}}</a>'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            var msg = new ApiHeader.APIQueryVmNicMsg();
                            msg.conditions = [{
                                    name: "securityGroup.uuid",
                                    op: '=',
                                    value: current.uuid
                                }];
                            msg.replyWithCount = true;
                            _this.api.syncApi(msg, function (reply) {
                                options.success({
                                    data: reply.inventories,
                                    total: reply.total
                                });
                            });
                        }
                    }
                })
            };
            $scope.optionsAttachL3Network = {
                sg: current,
                done: function (l3) {
                    $scope.optionsL3NetworkGrid.dataSource.insert(0, l3);
                }
            };
            $scope.optionsAddRule = {
                sg: current,
                done: function (rules) {
                    angular.forEach(rules, function (it) {
                        $scope.optionsRulesGrid.dataSource.insert(0, it);
                    });
                }
            };
            $scope.optionsDeleteRule = {
                sg: current,
                done: function (rules) {
                    var ds = $scope.optionsRulesGrid.dataSource;
                    var cs = ds.data();
                    angular.forEach(rules, function (it) {
                        for (var i = 0; i < cs.length; i++) {
                            var tcs = cs[i];
                            if (it.uuid == tcs.uuid) {
                                var row = ds.getByUid(tcs.uid);
                                ds.remove(row);
                                break;
                            }
                        }
                    });
                }
            };
            $scope.optionsDetachL3Network = {
                sg: current,
                done: function (l3) {
                    var ds = $scope.optionsL3NetworkGrid.dataSource;
                    var cs = ds.data();
                    for (var i = 0; i < cs.length; i++) {
                        var tcs = cs[i];
                        if (l3.uuid == tcs.uuid) {
                            var row = ds.getByUid(tcs.uid);
                            ds.remove(row);
                            break;
                        }
                    }
                }
            };
            $scope.optionsAddVmNic = {
                sg: current,
                done: function () {
                    $scope.optionsVmNicGrid.dataSource.read();
                }
            };
            $scope.optionsRemoveVmNic = {
                sg: current,
                done: function () {
                    $scope.optionsVmNicGrid.dataSource.read();
                }
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.sgMgr.query(qobj, function (sgs, total) {
                _this.$scope.model.current = sgs[0];
            });
        };
        DetailsController.$inject = ['$scope', 'SecurityGroupManager', '$routeParams', 'Tag', 'current', 'L3NetworkManager', 'Api'];
        return DetailsController;
    })();
    MSecurityGroup.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, sgMgr, $location) {
            this.$scope = $scope;
            this.sgMgr = sgMgr;
            this.$location = $location;
            $scope.model = new SecurityGroupModel();
            $scope.oSecurityGroupGrid = new OSecurityGroupGrid($scope, sgMgr);
            $scope.action = new Action($scope, sgMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"securityGroup.ts.NAME" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"securityGroup.ts.DESCRIPTION" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"securityGroup.ts.STATE" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"securityGroup.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"securityGroup.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    sgMgr.setSortBy(ret);
                    $scope.oSecurityGroupGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.SecurityGroupInventoryQueryable,
                name: 'SecurityGroup',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    sgMgr.query(qobj, function (sgs, total) {
                        $scope.oSecurityGroupGrid.refresh(sgs);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/securityGroup/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateSecurityGroup = function (win) {
                win.open();
            };
            $scope.funcDeleteSecurityGroup = function () {
                $scope.deleteSecurityGroup.open();
            };
            $scope.optionsDeleteSecurityGroup = {
                title: 'DELETE L3 NETWORK',
                html: '<strong><p>Deleting security group will cause:</p></strong>' +
                    '<ul><li><strong>All rules in this security group will be deleted</strong></li>' +
                    '<li><strong>All l3Networks this security group has attached will be detached</strong></li>' +
                    '<strong><p>those results are not recoverable</p></strong>',
                confirm: function () {
                    sgMgr.delete($scope.model.current, function (ret) {
                        $scope.oSecurityGroupGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oSecurityGroupGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateSecurityGroup = {
                done: function (sg) {
                    $scope.oSecurityGroupGrid.add(sg);
                }
            };
            $scope.optionsAddRule = {
                sg: null
            };
            $scope.optionsDeleteRule = {
                sg: null
            };
            $scope.optionsAttachL3Network = {
                sg: null
            };
            $scope.optionsDetachL3Network = {
                sg: null
            };
            $scope.optionsAddVmNic = {
                sg: null
            };
            $scope.optionsRemoveVmNic = {
                sg: null
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    $scope.optionsAddRule.sg = $scope.model.current;
                    $scope.optionsDeleteRule.sg = $scope.model.current;
                    $scope.optionsAttachL3Network.sg = $scope.model.current;
                    $scope.optionsDetachL3Network.sg = $scope.model.current;
                    $scope.optionsAddVmNic.sg = $scope.model.current;
                    $scope.optionsRemoveVmNic.sg = $scope.model.current;
                }
            });
        }
        Controller.$inject = ['$scope', 'SecurityGroupManager', '$location'];
        return Controller;
    })();
    MSecurityGroup.Controller = Controller;
    var AddRule = (function () {
        function AddRule(sgMgr) {
            var _this = this;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zSecurityGroupAddRule;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = {};
                var optionName = $attrs.zOptions;
                _this.options = parentScope[optionName];
                $scope.optionsAddRuleGrid__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            field: 'startPort',
                            title: '{{"securityGroup.ts.START" | translate}}',
                            width: '13%'
                        },
                        {
                            field: 'endPort',
                            title: '{{"securityGroup.ts.END" | translate}}',
                            width: '13%'
                        },
                        {
                            field: 'type',
                            title: '{{"securityGroup.ts.TYPE" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'protocol',
                            title: '{{"securityGroup.ts.PROTOCOL" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'allowedCidr',
                            title: '{{"securityGroup.ts.ALLOWED CIDR" | translate}}',
                            width: '22%'
                        },
                        {
                            width: '10%',
                            title: '',
                            template: '<button type="button" class="btn btn-xs btn-default" ng-show="dataItem.deleteable == true" ng-click="del(dataItem.uid)"><i class="fa fa-times"></i></button>'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource({
                        data: []
                    })
                };
                $scope.$watch(function () {
                    return _this.options.sg;
                }, function () {
                    if (Utils.notNullnotUndefined(_this.options.sg)) {
                        var rules = [];
                        angular.extend(rules, _this.options.sg.rules);
                        $scope.optionsAddRuleGrid__.dataSource.data(rules);
                    }
                });
                $scope.optionsAddRule__ = {
                    width: 500
                };
                $scope.ruleTypeOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [
                            'Ingress', 'Egress'
                        ] })
                };
                $scope.type = 'Ingress';
                $scope.ruleProtocolOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [
                            'TCP', 'UDP', 'ICMP'
                        ] })
                };
                $scope.protocol = 'TCP';
                function getNewRules() {
                    var allRules = $scope.optionsAddRuleGrid__.dataSource.data();
                    var newRules = [];
                    angular.forEach(allRules, function (it) {
                        if (Utils.notNullnotUndefined(it.deleteable)) {
                            newRules.push(it);
                        }
                    });
                    return newRules;
                }
                $scope.canProceed = function () {
                    return getNewRules().length > 0;
                };
                $scope.cancel = function () {
                    $scope.addRule__.close();
                };
                $scope.done = function () {
                    var nrules = getNewRules();
                    angular.forEach(nrules, function (it) {
                        delete it['deleteable'];
                    });
                    sgMgr.addRule(_this.options.sg, nrules, function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done(nrules);
                        }
                    });
                    $scope.addRule__.close();
                };
                $scope.isDuplicateRule = function () {
                    var rs = $scope.optionsAddRuleGrid__.dataSource.data();
                    for (var i = 0; i < rs.length; i++) {
                        var r = rs[i];
                        if ($scope.startPort == r.startPort && $scope.endPort == r.endPort && $scope.protocol == r.protocol
                            && $scope.type == r.type) {
                            if (r.allowedCidr == $scope.allowedCidr) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                $scope.canAdd = function () {
                    if (Utils.notNullnotUndefined($scope.startPort) && Utils.notNullnotUndefined($scope.endPort)
                        && Utils.notNullnotUndefined($scope.type) && Utils.notNullnotUndefined($scope.protocol)
                        && $scope.isStartPortValid()
                        && $scope.isEndPortValid()
                        && $scope.isCIDRValid()) {
                        return !$scope.isDuplicateRule();
                    }
                    else {
                        return false;
                    }
                };
                $scope.add = function () {
                    $scope.allowedCidr = $scope.allowedCidr == "" ? null : $scope.allowedCidr;
                    var rule = {
                        securityGroupUuid: $scope.securityGroupUuid,
                        startPort: $scope.startPort,
                        endPort: $scope.endPort,
                        allowedCidr: !Utils.notNullnotUndefined($scope.allowedCidr) ? '0.0.0.0/0' : $scope.allowedCidr,
                        type: $scope.type,
                        protocol: $scope.protocol,
                        deleteable: true
                    };
                    $scope.optionsAddRuleGrid__.dataSource.insert(0, rule);
                    $scope.startPort = null;
                    $scope.endPort = null;
                    $scope.allowedCidr = null;
                };
                $scope.isGridShow = function () {
                    return _this.$scope.optionsAddRuleGrid__.dataSource.data().length > 0;
                };
                _this.$scope = $scope;
                $scope.del = function (uid) {
                    var row = $scope.optionsAddRuleGrid__.dataSource.getByUid(uid);
                    $scope.optionsAddRuleGrid__.dataSource.remove(row);
                };
                $scope.isStartPortValid = function () {
                    if (Utils.notNullnotUndefined($scope.startPort)) {
                        if ($scope.protocol == 'UDP' || $scope.protocol == 'TCP') {
                            return Utils.isValidPort($scope.startPort);
                        }
                    }
                    return true;
                };
                $scope.isEndPortValid = function () {
                    if (Utils.notNullnotUndefined($scope.endPort)) {
                        if ($scope.protocol == 'UDP' || $scope.protocol == 'TCP') {
                            return Utils.isValidPort($scope.endPort);
                        }
                    }
                    return true;
                };
                $scope.isCIDRValid = function () {
                    if (Utils.notNullnotUndefined($scope.allowedCidr) && $scope.allowedCidr != "") {
                        return Utils.isValidCidr($scope.allowedCidr);
                    }
                    return true;
                };
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/securityGroup/addRule.html';
        }
        AddRule.prototype.open = function () {
            this.$scope.startPort = null;
            this.$scope.endPort = null;
            this.$scope.allowedCidr = null;
            this.$scope.addRule__.center();
            this.$scope.addRule__.open();
        };
        return AddRule;
    })();
    MSecurityGroup.AddRule = AddRule;
    var CreateSecurityGroup = (function () {
        function CreateSecurityGroup(api, sgMgr, l3Mgr) {
            var _this = this;
            this.api = api;
            this.sgMgr = sgMgr;
            this.l3Mgr = l3Mgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateSecurityGroup;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = {};
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createSecurityGroupInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createSecurityGroupInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('sg');
                        this.description = null;
                        this.activeState = false;
                    }
                };
                var rulePage = $scope.rulePage = {
                    activeState: false,
                    startPort: null,
                    endPort: null,
                    type: null,
                    allowedCidr: null,
                    protocol: null,
                    isStartPortValid: function () {
                        if (Utils.notNullnotUndefined(this.startPort)) {
                            if (this.protocol == 'UDP' || this.protocol == 'TCP') {
                                return Utils.isValidPort(this.startPort);
                            }
                        }
                        return true;
                    },
                    isEndPortValid: function () {
                        if (Utils.notNullnotUndefined(this.endPort)) {
                            if (this.protocol == 'UDP' || this.protocol == 'TCP') {
                                return Utils.isValidPort(this.endPort);
                            }
                        }
                        return true;
                    },
                    isCIDRValid: function () {
                        if (Utils.notNullnotUndefined(this.allowedCidr) && this.allowedCidr != "") {
                            return Utils.isValidCidr(this.allowedCidr);
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createSecurityGroupRule"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createSecurityGroupRule';
                    },
                    reset: function () {
                        this.activeState = false;
                    },
                    add: function () {
                        this.allowedCidr = this.allowedCidr == "" ? null : this.allowedCidr;
                        $scope.optionsRuleGrid__.dataSource.insert(0, {
                            startPort: this.startPort,
                            endPort: this.endPort,
                            type: this.type,
                            protocol: this.protocol,
                            allowedCidr: this.allowedCidr == null ? '0.0.0.0/0' : this.allowedCidr
                        });
                        this.startPort = null;
                        this.endPort = null;
                        this.allowedCidr = null;
                    },
                    canAdd: function () {
                        return Utils.notNullnotUndefined(this.startPort)
                            && Utils.notNullnotUndefined(this.endPort)
                            && Utils.notNullnotUndefined(this.type)
                            && Utils.notNullnotUndefined(this.protocol)
                            && this.isStartPortValid()
                            && this.isEndPortValid()
                            && this.isCIDRValid();
                    },
                    isGridShow: function () {
                        return $scope.optionsRuleGrid__.dataSource.data().length > 0;
                    },
                    del: function (uid) {
                        var row = $scope.optionsRuleGrid__.dataSource.getByUid(uid);
                        $scope.optionsRuleGrid__.dataSource.remove(row);
                    }
                };
                var l3Page = $scope.l3Page = {
                    activeState: false,
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return true;
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createSecurityGroupRuleL3Network"]');
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createSecurityGroupRuleL3Network';
                    },
                    reset: function () {
                        this.activeState = false;
                    },
                    canAdd: function () {
                        return Utils.notNullnotUndefined(this.dns);
                    },
                    hasL3Network: function () {
                        return $scope.l3NetworkListOptions__.dataSource.data().length > 0;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultSg;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            sgMgr.create(infoPage, function (ret) {
                                resultSg = ret;
                                chain.next();
                            });
                        }).then(function () {
                            var rules = $scope.optionsRuleGrid__.dataSource.data();
                            if (rules.length == 0) {
                                chain.next();
                                return;
                            }
                            sgMgr.addRule(resultSg, rules, function () {
                                chain.next();
                            });
                        }).then(function () {
                            var l3s = $scope.l3NetworkList__.dataItems();
                            if (l3s.length == 0) {
                                chain.next();
                                return;
                            }
                            var attach = function () {
                                var l3 = l3s.shift();
                                if (!Utils.notNullnotUndefined(l3)) {
                                    chain.next();
                                    return;
                                }
                                _this.sgMgr.attachL3Network(resultSg, l3.uuid, function () {
                                    attach();
                                });
                            };
                            attach();
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultSg);
                            }
                        }).start();
                        $scope.winCreateSecurityGroup__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage, rulePage, l3Page
                ], mediator);
                $scope.l3NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.TYPE" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Zone UUID" | translate}}:</span><span>#: zoneUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.ruleTypeOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [
                            'Ingress', 'Egress'
                        ] })
                };
                $scope.rulePage.type = 'Ingress';
                $scope.ruleProtocolOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [
                            'TCP', 'UDP', 'ICMP'
                        ] })
                };
                $scope.rulePage.protocol = 'TCP';
                $scope.optionsRuleGrid__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            field: 'startPort',
                            title: '{{"securityGroup.ts.START" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'endPort',
                            title: '{{"securityGroup.ts.END" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'type',
                            title: '{{"securityGroup.ts.TYPE" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'protocol',
                            title: '{{"securityGroup.ts.PROTOCOL" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'allowedCidr',
                            title: '{{"securityGroup.ts.ALLOWED CIDR" | translate}}',
                            width: '16%'
                        },
                        {
                            width: '10%',
                            title: '',
                            template: '<button type="button" class="btn btn-xs btn-default" ng-click="rulePage.del(dataItem.uid)"><i class="fa fa-times"></i></button>'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource([])
                };
                $scope.winCreateSecurityGroupOptions__ = {
                    width: '800px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/securityGroup/createSecurityGroup.html';
        }
        CreateSecurityGroup.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateSecurityGroup__;
            this.$scope.button.reset();
            this.$scope.l3NetworkListOptions__.dataSource.data([]);
            this.$scope.optionsRuleGrid__.dataSource.data([]);
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [];
            this.l3Mgr.query(qobj, function (l3s) {
                _this.$scope.l3NetworkListOptions__.dataSource.data(l3s);
                win.center();
                win.open();
            });
        };
        return CreateSecurityGroup;
    })();
    MSecurityGroup.CreateSecurityGroup = CreateSecurityGroup;
    var DeleteRule = (function () {
        function DeleteRule(sgMgr) {
            var _this = this;
            this.sgMgr = sgMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/securityGroup/deleteRule.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zSecurityGroupDeleteRule] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.ruleOptions__ = {
                    pageSize: 20,
                    resizable: true,
                    scrollable: true,
                    pageable: true,
                    columns: [
                        {
                            width: '10%',
                            title: '',
                            template: '<input type="checkbox" ng-model="dataItem.toDelete">'
                        },
                        {
                            field: 'startPort',
                            title: '{{"securityGroup.ts.START" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'endPort',
                            title: '{{"securityGroup.ts.END" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'type',
                            title: '{{"securityGroup.ts.TYPE" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'protocol',
                            title: '{{"securityGroup.ts.PROTOCOL" | translate}}',
                            width: '16%'
                        },
                        {
                            field: 'allowedCidr',
                            title: '{{"securityGroup.ts.ALLOWED CIDR" | translate}}',
                            width: '16%'
                        }
                    ],
                    dataBound: function (e) {
                        var grid = e.sender;
                        if (grid.dataSource.totalPages() == 1) {
                            grid.pager.element.hide();
                        }
                    },
                    dataSource: new kendo.data.DataSource([])
                };
                function getSelectedItems() {
                    var rules = $scope.ruleOptions__.dataSource.data();
                    var ruleToDelete = [];
                    angular.forEach(rules, function (it) {
                        if (it.toDelete == true) {
                            ruleToDelete.push(it);
                        }
                    });
                    return ruleToDelete;
                }
                $scope.canProceed = function () {
                    return getSelectedItems().length > 0;
                };
                $scope.cancel = function () {
                    $scope.deleteRule__.close();
                };
                $scope.done = function () {
                    var ruleUuids = [];
                    var rules = getSelectedItems();
                    angular.forEach(rules, function (rule) {
                        ruleUuids.push(rule.uuid);
                    });
                    sgMgr.deleteRule(_this.options.sg, ruleUuids, function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done(rules);
                        }
                    });
                    $scope.deleteRule__.close();
                };
                $scope.deleteRuleOptions__ = {
                    width: '550px'
                };
                $scope.$watch(function () {
                    return _this.options.sg;
                }, function () {
                    if (Utils.notNullnotUndefined(_this.options.sg)) {
                        var rules = [];
                        angular.extend(rules, _this.options.sg.rules);
                        $scope.ruleOptions__.dataSource.data(rules);
                    }
                });
            };
        }
        DeleteRule.prototype.open = function () {
            this.$scope.ruleOptions__.dataSource.data(this.options.sg.rules);
            this.$scope.deleteRule__.center();
            this.$scope.deleteRule__.open();
        };
        return DeleteRule;
    })();
    MSecurityGroup.DeleteRule = DeleteRule;
    var AddVmNic = (function () {
        function AddVmNic(sgMgr, vmMgr) {
            var _this = this;
            this.sgMgr = sgMgr;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/securityGroup/addVmNic.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zSecurityGroupAddVmNic] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.vmNicListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "id",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"securityGroup.ts.VM Name" | translate}}:</span><span>#: vm.name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Nic IP" | translate}}:</span><span>#: nic.ip #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Nic Device ID" | translate}}:</span><span>#: nic.deviceId #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Nic UUID" | translate}}:</span><span>#: nic.uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasVmNic = function () {
                    return $scope.vmNicListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.addVmNic__.close();
                };
                $scope.done = function () {
                    var nics = $scope.vmNicList__.dataItems();
                    var nicUuids = [];
                    angular.forEach(nics, function (it) {
                        nicUuids.push(it.nic.uuid);
                    });
                    sgMgr.addVmNic(_this.options.sg, nicUuids, function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done();
                        }
                    });
                    $scope.addVmNic__.close();
                };
                $scope.addVmNicOptions__ = {
                    width: '550px'
                };
            };
        }
        AddVmNic.prototype.open = function () {
            var _this = this;
            this.$scope.vmNicListOptions__.dataSource.data([]);
            this.$scope.securityGroupName = this.options.sg.name;
            var chain = new Utils.Chain();
            var nics = [];
            var candidates = [];
            chain.then(function () {
                _this.sgMgr.getCandidateVmNic(_this.options.sg, function (ret) {
                    nics = ret;
                    chain.next();
                });
            }).then(function () {
                if (nics.length == 0) {
                    chain.next();
                    return;
                }
                var nicUuids = [];
                angular.forEach(nics, function (it) {
                    nicUuids.push(it.uuid);
                });
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'vmNics.uuid',
                        op: 'in',
                        value: nicUuids.join()
                    }
                ];
                _this.vmMgr.query(qobj, function (vms) {
                    angular.forEach(nics, function (nic) {
                        for (var i = 0; i < vms.length; i++) {
                            var vm = vms[i];
                            for (var j = 0; j < vm.vmNics.length; j++) {
                                var vnic = vm.vmNics[j];
                                if (vnic.uuid == nic.uuid) {
                                    var tvm = vm;
                                    break;
                                }
                            }
                        }
                        candidates.push({
                            id: tvm.name + ' - ' + nic.ip,
                            vm: tvm,
                            nic: nic
                        });
                    });
                    chain.next();
                });
            }).done(function () {
                _this.$scope.vmNicListOptions__.dataSource.data(candidates);
                _this.$scope.addVmNic__.center();
                _this.$scope.addVmNic__.open();
            }).start();
        };
        return AddVmNic;
    })();
    MSecurityGroup.AddVmNic = AddVmNic;
    var RemoveVmNic = (function () {
        function RemoveVmNic(sgMgr, vmMgr, api) {
            var _this = this;
            this.sgMgr = sgMgr;
            this.vmMgr = vmMgr;
            this.api = api;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/securityGroup/removeVmNic.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zSecurityGroupRemoveVmNic] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.vmNicListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "id",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"securityGroup.ts.VM Name" | translate}}:</span><span>#: vm.name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Nic IP" | translate}}:</span><span>#: nic.ip #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Nic Device ID" | translate}}:</span><span>#: nic.deviceId #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Nic UUID" | translate}}:</span><span>#: nic.uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasVmNic = function () {
                    return $scope.vmNicListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.removeVmNic__.close();
                };
                $scope.done = function () {
                    var nics = $scope.vmNicList__.dataItems();
                    var nicUuids = [];
                    angular.forEach(nics, function (it) {
                        nicUuids.push(it.nic.uuid);
                    });
                    sgMgr.removeVmNic(_this.options.sg, nicUuids, function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done();
                        }
                    });
                    $scope.removeVmNic__.close();
                };
                $scope.addVmNicOptions__ = {
                    width: '550px'
                };
            };
        }
        RemoveVmNic.prototype.open = function () {
            var _this = this;
            this.$scope.vmNicListOptions__.dataSource.data([]);
            this.$scope.securityGroupName = this.options.sg.name;
            var chain = new Utils.Chain();
            var nics = [];
            var candidates = [];
            chain.then(function () {
                var msg = new ApiHeader.APIQueryVmNicMsg();
                msg.conditions = [{
                        name: 'securityGroup.uuid',
                        op: '=',
                        value: _this.options.sg.uuid
                    }];
                _this.api.syncApi(msg, function (reply) {
                    nics = reply.inventories;
                    chain.next();
                });
            }).then(function () {
                if (nics.length == 0) {
                    chain.next();
                    return;
                }
                var nicUuids = [];
                angular.forEach(nics, function (it) {
                    nicUuids.push(it.uuid);
                });
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'vmNics.uuid',
                        op: 'in',
                        value: nicUuids.join()
                    }
                ];
                _this.vmMgr.query(qobj, function (vms) {
                    angular.forEach(nics, function (nic) {
                        for (var i = 0; i < vms.length; i++) {
                            var vm = vms[i];
                            for (var j = 0; j < vm.vmNics.length; j++) {
                                var vnic = vm.vmNics[j];
                                if (vnic.uuid == nic.uuid) {
                                    var tvm = vm;
                                    break;
                                }
                            }
                        }
                        candidates.push({
                            id: tvm.name + ' - ' + nic.ip,
                            vm: tvm,
                            nic: nic
                        });
                    });
                    chain.next();
                });
            }).done(function () {
                _this.$scope.vmNicListOptions__.dataSource.data(candidates);
                _this.$scope.removeVmNic__.center();
                _this.$scope.removeVmNic__.open();
            }).start();
        };
        return RemoveVmNic;
    })();
    MSecurityGroup.RemoveVmNic = RemoveVmNic;
    var AttachL3Network = (function () {
        function AttachL3Network(sgMgr, l3Mgr) {
            var _this = this;
            this.sgMgr = sgMgr;
            this.l3Mgr = l3Mgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/securityGroup/attachL3Network.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zSecurityGroupAttachL3Network] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.l3NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.TYPE" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Zone UUID" | translate}}:</span><span>#: zoneUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.L2 Network UUID" | translate}}:</span><span>#: l2NetworkUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasL3Network = function () {
                    return $scope.l3NetworkListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.attachL3Network__.close();
                };
                $scope.done = function () {
                    var l3s = $scope.l3NetworkList__.dataItems();
                    angular.forEach(l3s, function (it) {
                        sgMgr.attachL3Network(_this.options.sg, it.uuid, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(it);
                            }
                        });
                    });
                    $scope.attachL3Network__.close();
                };
            };
        }
        AttachL3Network.prototype.open = function () {
            var _this = this;
            this.$scope.l3NetworkListOptions__.dataSource.data([]);
            var chain = new Utils.Chain();
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'not in',
                        value: _this.options.sg.attachedL3NetworkUuids.join()
                    },
                ];
                _this.l3Mgr.query(qobj, function (l3s) {
                    _this.$scope.l3NetworkListOptions__.dataSource.data(l3s);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachL3Network__.center();
                _this.$scope.attachL3Network__.open();
            }).start();
        };
        return AttachL3Network;
    })();
    MSecurityGroup.AttachL3Network = AttachL3Network;
    var DetachL3Network = (function () {
        function DetachL3Network(sgMgr, l3Mgr) {
            var _this = this;
            this.sgMgr = sgMgr;
            this.l3Mgr = l3Mgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/securityGroup/detachL3Network.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zSecurityGroupDetachL3Network] = _this;
                _this.options = parent[$attrs.zOptions];
                _this.$scope = $scope;
                $scope.uuid = null;
                $scope.l3NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    itemTemplate: '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.TYPE" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.Zone UUID" | translate}}:</span><span>#: zoneUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.L2 Network UUID" | translate}}:</span><span>#: l2NetworkUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"securityGroup.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>',
                    change: function (e) {
                        var select = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.selectItemNum = select.dataItems().length;
                        });
                    }
                };
                $scope.hasL3Network = function () {
                    return $scope.l3NetworkListOptions__.dataSource.data().length > 0;
                };
                $scope.selectItemNum = 0;
                $scope.canProceed = function () {
                    return $scope.selectItemNum > 0;
                };
                $scope.cancel = function () {
                    $scope.detachL3Network__.close();
                };
                $scope.done = function () {
                    var l3s = $scope.l3NetworkList__.dataItems();
                    angular.forEach(l3s, function (l3) {
                        sgMgr.detachL3Network(_this.options.sg, l3.uuid, function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(l3);
                            }
                        });
                    });
                    $scope.detachL3Network__.close();
                };
                $scope.detachL3NetworkOptions__ = {
                    width: '600px'
                };
            };
        }
        DetachL3Network.prototype.open = function () {
            var _this = this;
            this.$scope.l3NetworkList__.value([]);
            this.$scope.ok = null;
            var chain = new Utils.Chain();
            chain.then(function () {
                if (_this.options.sg.attachedL3NetworkUuids.length == 0) {
                    chain.next();
                    return;
                }
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [
                    {
                        name: 'uuid',
                        op: 'in',
                        value: _this.options.sg.attachedL3NetworkUuids.join()
                    }
                ];
                _this.l3Mgr.query(qobj, function (l3s) {
                    _this.$scope.l3NetworkListOptions__.dataSource.data(l3s);
                    chain.next();
                });
            }).done(function () {
                _this.$scope.detachL3Network__.center();
                _this.$scope.detachL3Network__.open();
            }).start();
        };
        return DetachL3Network;
    })();
    MSecurityGroup.DetachL3Network = DetachL3Network;
})(MSecurityGroup || (MSecurityGroup = {}));
angular.module('root').factory('SecurityGroupManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MSecurityGroup.SecurityGroupManager(api, $rootScope);
    }]).directive('zCreateSecurityGroup', ['Api', 'SecurityGroupManager', 'L3NetworkManager', function (api, sgMgr, l3Mgr) {
        return new MSecurityGroup.CreateSecurityGroup(api, sgMgr, l3Mgr);
    }]).directive('zSecurityGroupAddRule', ['SecurityGroupManager', function (sgMgr) {
        return new MSecurityGroup.AddRule(sgMgr);
    }]).directive('zSecurityGroupDeleteRule', ['SecurityGroupManager', function (sgMgr) {
        return new MSecurityGroup.DeleteRule(sgMgr);
    }]).directive('zSecurityGroupAttachL3Network', ['SecurityGroupManager', 'L3NetworkManager', function (sgMgr, l3Mgr) {
        return new MSecurityGroup.AttachL3Network(sgMgr, l3Mgr);
    }]).directive('zSecurityGroupDetachL3Network', ['SecurityGroupManager', 'L3NetworkManager', function (sgMgr, l3Mgr) {
        return new MSecurityGroup.DetachL3Network(sgMgr, l3Mgr);
    }]).directive('zSecurityGroupAddVmNic', ['SecurityGroupManager', 'VmInstanceManager', function (sgMgr, vmMgr) {
        return new MSecurityGroup.AddVmNic(sgMgr, vmMgr);
    }]).directive('zSecurityGroupRemoveVmNic', ['SecurityGroupManager', 'VmInstanceManager', 'Api', function (sgMgr, vmMgr, api) {
        return new MSecurityGroup.RemoveVmNic(sgMgr, vmMgr, api);
    }]).config(['$routeProvider', function (route) {
        route.when('/securityGroup', {
            templateUrl: '/static/templates/securityGroup/securityGroup.html',
            controller: 'MSecurityGroup.Controller'
        }).when('/securityGroup/:uuid', {
            templateUrl: '/static/templates/securityGroup/details.html',
            controller: 'MSecurityGroup.DetailsController',
            resolve: {
                current: function ($q, $route, SecurityGroupManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    SecurityGroupManager.query(qobj, function (sgs) {
                        var sg = sgs[0];
                        defer.resolve(sg);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MVip;
(function (MVip) {
    var Vip = (function (_super) {
        __extends(Vip, _super);
        function Vip() {
            _super.apply(this, arguments);
        }
        Vip.prototype.progressOn = function () {
            this.inProgress = true;
        };
        Vip.prototype.progressOff = function () {
            this.inProgress = false;
        };
        Vip.prototype.isInProgress = function () {
            return this.inProgress;
        };
        Vip.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        Vip.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        Vip.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        Vip.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('ip', inv.ip);
            self.set('l3NetworkUuid', inv.l3NetworkUuid);
            self.set('netmask', inv.netmask);
            self.set('serviceProvider', inv.serviceProvider);
            self.set('peerL3NetworkUuid', inv.peerL3NetworkUuid);
            self.set('useFor', inv.useFor);
            self.set('gateway', inv.gateway);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return Vip;
    })(ApiHeader.VipInventory);
    MVip.Vip = Vip;
    var VipManager = (function () {
        function VipManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        VipManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        VipManager.prototype.wrap = function (Vip) {
            return new kendo.data.ObservableObject(Vip);
        };
        VipManager.prototype.create = function (vip, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateVipMsg();
            msg.name = vip.name;
            msg.description = vip.description;
            msg.l3NetworkUuid = vip.l3NetworkUuid;
            msg.allocatorStrategy = vip.allocatorStrategy;
            msg.requiredIp = vip.requiredIp;
            this.api.asyncApi(msg, function (ret) {
                var c = new Vip();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new VIP: {0}', c.name),
                    link: Utils.sprintf('/#/vip/{0}', c.uuid)
                });
            });
        };
        VipManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryVipMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new Vip();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        VipManager.prototype.disable = function (vip) {
            var _this = this;
            vip.progressOn();
            var msg = new ApiHeader.APIChangeVipStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = vip.uuid;
            this.api.asyncApi(msg, function (ret) {
                vip.updateObservableObject(ret.inventory);
                vip.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled VIP: {0}', vip.name),
                    link: Utils.sprintf('/#/vip/{0}', vip.uuid)
                });
            });
        };
        VipManager.prototype.enable = function (vip) {
            var _this = this;
            vip.progressOn();
            var msg = new ApiHeader.APIChangeVipStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = vip.uuid;
            this.api.asyncApi(msg, function (ret) {
                vip.updateObservableObject(ret.inventory);
                vip.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled VIP: {0}', vip.name),
                    link: Utils.sprintf('/#/vip/{0}', vip.uuid)
                });
            });
        };
        VipManager.prototype.delete = function (vip, done) {
            var _this = this;
            vip.progressOn();
            var msg = new ApiHeader.APIDeleteVipMsg();
            msg.uuid = vip.uuid;
            this.api.asyncApi(msg, function (ret) {
                vip.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted VIP: {0}', vip.name)
                });
            });
        };
        VipManager.$inject = ['Api', '$rootScope'];
        return VipManager;
    })();
    MVip.VipManager = VipManager;
    var VipModel = (function (_super) {
        __extends(VipModel, _super);
        function VipModel() {
            _super.call(this);
            this.current = new Vip();
        }
        return VipModel;
    })(Utils.Model);
    MVip.VipModel = VipModel;
    var OVipGrid = (function (_super) {
        __extends(OVipGrid, _super);
        function OVipGrid($scope, vipMgr) {
            _super.call(this);
            this.vipMgr = vipMgr;
            _super.prototype.init.call(this, $scope, $scope.vipGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"vip.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/vip/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'state',
                    title: '{{"vip.ts.STATE" | translate}}',
                    width: '6%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'ip',
                    title: '{{"vip.ts.IP" | translate}}',
                    width: '14%'
                },
                {
                    field: 'netmask',
                    title: '{{"vip.ts.NETMASK" | translate}}',
                    width: '14%'
                },
                {
                    field: 'gateway',
                    title: '{{"vip.ts.GATEWAY" | translate}}',
                    width: '14%'
                },
                {
                    field: 'l3NetworkUuid',
                    title: '{{"vip.ts.L3 NETWORK UUID" | translate}}',
                    width: '%14',
                    template: '<a href="/\\#/l3Network/{{dataItem.l3NetworkUuid}}">{{dataItem.l3NetworkUuid}}</a>'
                },
                {
                    field: 'useFor',
                    title: '{{"vip.ts.USE" | translate}}',
                    width: '14%'
                },
                {
                    field: 'serviceProvider',
                    title: '{{"vip.ts.SERVICE PROVIDER" | translate}}',
                    width: '14%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                vipMgr.query(qobj, function (vips, total) {
                    options.success({
                        data: vips,
                        total: total
                    });
                });
            };
        }
        return OVipGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, vipMgr) {
            this.$scope = $scope;
            this.vipMgr = vipMgr;
        }
        Action.prototype.enable = function () {
            this.vipMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.vipMgr.disable(this.$scope.model.current);
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope) {
            var _this = this;
            this.$scope = $scope;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"vip.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"vip.ts.State" | translate}}',
                            value: FilterBy.STATE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oVipGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, vipMgr, $routeParams, tagService, current) {
            var _this = this;
            this.$scope = $scope;
            this.vipMgr = vipMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new VipModel();
            $scope.model.current = current;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, vipMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteVip = {
                title: 'DELETE VIP',
                description: 'Deleting will delete all network services that this VIP is used for. For example, if the VIP is used for EIP, the EIP will be deleted as well',
                confirm: function () {
                    vipMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeVipVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.vipMgr.query(qobj, function (vips, total) {
                _this.$scope.model.current = vips[0];
            });
        };
        DetailsController.$inject = ['$scope', 'VipManager', '$routeParams', 'Tag', 'current'];
        return DetailsController;
    })();
    MVip.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, vipMgr, $location) {
            this.$scope = $scope;
            this.vipMgr = vipMgr;
            this.$location = $location;
            $scope.model = new VipModel();
            $scope.oVipGrid = new OVipGrid($scope, vipMgr);
            $scope.action = new Action($scope, vipMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"vip.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"vip.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"vip.ts.IP" | translate}}',
                        value: 'ip'
                    },
                    {
                        name: '{{"vip.ts.NETMASK" | translate}}',
                        value: 'netmask'
                    },
                    {
                        name: '{{"vip.ts.GATEWAY" | translate}}',
                        value: 'gateway'
                    },
                    {
                        name: '{{"vip.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"vip.ts.USE" | translate}}',
                        value: 'useFor'
                    },
                    {
                        name: '{{"vip.ts.SERVICE PROVIDER" | translate}}',
                        value: 'serviceProvider'
                    },
                    {
                        name: '{{"vip.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"vip.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    vipMgr.setSortBy(ret);
                    $scope.oVipGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.VipInventoryQueryable,
                name: 'Vip',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    vipMgr.query(qobj, function (Vips, total) {
                        $scope.oVipGrid.refresh(Vips);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/vip/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateVip = function (win) {
                win.open();
            };
            $scope.funcDeleteVip = function () {
                $scope.deleteVip.open();
            };
            $scope.optionsDeleteVip = {
                title: 'DELETE VIP',
                description: 'Deleting will delete all network services that this VIP is used for. For example, if the VIP is used for EIP, the EIP will be deleted as well',
                confirm: function () {
                    vipMgr.delete($scope.model.current, function (ret) {
                        $scope.oVipGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oVipGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateVip = {
                done: function (vip) {
                    $scope.oVipGrid.add(vip);
                }
            };
        }
        Controller.$inject = ['$scope', 'VipManager', '$location'];
        return Controller;
    })();
    MVip.Controller = Controller;
    var CreateVipOptions = (function () {
        function CreateVipOptions() {
        }
        return CreateVipOptions;
    })();
    MVip.CreateVipOptions = CreateVipOptions;
    var CreateVip = (function () {
        function CreateVip(api, vipMgr, zoneMgr, l3Mgr) {
            var _this = this;
            this.api = api;
            this.vipMgr = vipMgr;
            this.zoneMgr = zoneMgr;
            this.l3Mgr = l3Mgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateVip;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateVipOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    l3NetworkUuid: null,
                    requiredIp: null,
                    isVipValid: function () {
                        if (Utils.notNullnotUndefined(this.requiredIp) && this.requiredIp != "") {
                            return Utils.isIpv4Address(this.requiredIp);
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.l3NetworkUuid) && this.isVipValid();
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createVipInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createVipInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('vip');
                        this.description = null;
                        this.requiredIp = null;
                        this.l3NetworkUuid = null;
                        this.activeState = false;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultVip;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            $scope.infoPage.requiredIp = $scope.infoPage.requiredIp == "" ? null : $scope.infoPage.requiredIp;
                            vipMgr.create(infoPage, function (ret) {
                                resultVip = ret;
                                chain.next();
                            });
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultVip);
                            }
                        }).start();
                        $scope.winCreateVip__.close();
                    }
                };
                $scope.hasL3Network = function () {
                    return $scope.l3NetworkListOptions__.dataSource.data().length > 0;
                };
                $scope.button = new Utils.WizardButton([
                    infoPage
                ], mediator);
                $scope.winCreateVipOptions__ = {
                    width: '700px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.zoneOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vip.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vip.ts.State" | translate}}:</span><span>#: state #</span></div>'
                };
                $scope.l3NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"vip.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vip.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vip.ts.Zone UUID" | translate}}:</span><span>#: zoneUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vip.ts.L2 Network UUID" | translate}}:</span><span>#: l2NetworkUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"vip.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.$watch(function () {
                    return $scope.zoneUuid;
                }, function () {
                    if (Utils.notNullnotUndefined($scope.zoneUuid)) {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'zoneUuid',
                                op: '=',
                                value: $scope.zoneUuid
                            }
                        ];
                        _this.l3Mgr.query(qobj, function (l3s) {
                            $scope.l3NetworkListOptions__.dataSource.data(l3s);
                            if (l3s.length > 0) {
                                $scope.infoPage.l3NetworkUuid = l3s[0].uuid;
                            }
                        });
                    }
                });
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/vip/createVip.html';
        }
        CreateVip.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateVip__;
            this.$scope.button.reset();
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [];
            this.$scope.zoneUuid = null;
            this.zoneMgr.query(qobj, function (zones) {
                _this.$scope.zoneOptions__.dataSource.data(zones);
                if (zones.length > 0) {
                    _this.$scope.infoPage.zoneUuid = zones[0].uuid;
                }
                win.center();
                win.open();
            });
        };
        return CreateVip;
    })();
    MVip.CreateVip = CreateVip;
})(MVip || (MVip = {}));
angular.module('root').factory('VipManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MVip.VipManager(api, $rootScope);
    }]).directive('zCreateVip', ['Api', 'VipManager', 'ZoneManager', 'L3NetworkManager', function (api, vipMgr, zoneMgr, l3Mgr) {
        return new MVip.CreateVip(api, vipMgr, zoneMgr, l3Mgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/vip', {
            templateUrl: '/static/templates/vip/vip.html',
            controller: 'MVip.Controller'
        }).when('/vip/:uuid', {
            templateUrl: '/static/templates/vip/details.html',
            controller: 'MVip.DetailsController',
            resolve: {
                current: function ($q, $route, VipManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    VipManager.query(qobj, function (vips) {
                        var vip = vips[0];
                        defer.resolve(vip);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MEip;
(function (MEip) {
    var Eip = (function (_super) {
        __extends(Eip, _super);
        function Eip() {
            _super.apply(this, arguments);
        }
        Eip.prototype.progressOn = function () {
            this.inProgress = true;
        };
        Eip.prototype.progressOff = function () {
            this.inProgress = false;
        };
        Eip.prototype.isInProgress = function () {
            return this.inProgress;
        };
        Eip.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        Eip.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        Eip.prototype.isAttachShow = function () {
            return !Utils.notNullnotUndefined(this.vmNicUuid);
        };
        Eip.prototype.isDetachShow = function () {
            return !this.isAttachShow();
        };
        Eip.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        Eip.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('vmNicUuid', inv.vmNicUuid);
            self.set('vipUuid', inv.vipUuid);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        Eip.prototype.extendVip = function (vip) {
            var self = this;
            this['vipIp'] = vip;
            self.set('vipIp', vip);
        };
        Eip.prototype.extendVmNicIp = function (nicIp) {
            var self = this;
            this['vmNicIp'] = nicIp;
            self.set('vmNicIp', nicIp);
        };
        Eip.wrap = function (obj) {
            var eip = new Eip();
            angular.extend(eip, obj);
            return eip;
        };
        return Eip;
    })(ApiHeader.EipInventory);
    MEip.Eip = Eip;
    var EipManager = (function () {
        function EipManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        EipManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        EipManager.prototype.wrap = function (Eip) {
            return new kendo.data.ObservableObject(Eip);
        };
        EipManager.prototype.create = function (eip, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateEipMsg();
            msg.name = eip.name;
            msg.description = eip.description;
            msg.vipUuid = eip.vipUuid;
            msg.vmNicUuid = eip.vmNicUuid;
            this.api.asyncApi(msg, function (ret) {
                var c = new Eip();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new EIP: {0}', c.name),
                    link: Utils.sprintf('/#/eip/{0}', c.uuid)
                });
            });
        };
        EipManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryEipMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new Eip();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        EipManager.prototype.getAttachableVmNicByEipUuid = function (uuid, done) {
            var msg = new ApiHeader.APIGetEipAttachableVmNicsMsg();
            msg.eipUuid = uuid;
            this.api.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        EipManager.prototype.getAttachableVmNicByVipUuid = function (uuid, done) {
            var msg = new ApiHeader.APIGetEipAttachableVmNicsMsg();
            msg.vipUuid = uuid;
            this.api.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        EipManager.prototype.attach = function (eip, vmNicUuid, done) {
            var _this = this;
            eip.progressOn();
            var msg = new ApiHeader.APIAttachEipMsg();
            msg.eipUuid = eip.uuid;
            msg.vmNicUuid = vmNicUuid;
            this.api.asyncApi(msg, function (ret) {
                eip.updateObservableObject(ret.inventory);
                eip.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached EIP: {0}', eip.name),
                    link: Utils.sprintf('/#/eip/{0}', eip.uuid)
                });
            });
        };
        EipManager.prototype.detach = function (eip, done) {
            var _this = this;
            eip.progressOn();
            var msg = new ApiHeader.APIDetachEipMsg();
            msg.uuid = eip.uuid;
            this.api.asyncApi(msg, function (ret) {
                eip.updateObservableObject(ret.inventory);
                eip.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached EIP: {0}', eip.name),
                    link: Utils.sprintf('/#/eip/{0}', eip.uuid)
                });
            });
        };
        EipManager.prototype.disable = function (eip) {
            var _this = this;
            eip.progressOn();
            var msg = new ApiHeader.APIChangeEipStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = eip.uuid;
            this.api.asyncApi(msg, function (ret) {
                eip.updateObservableObject(ret.inventory);
                eip.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled EIP: {0}', eip.name),
                    link: Utils.sprintf('/#/eip/{0}', eip.uuid)
                });
            });
        };
        EipManager.prototype.enable = function (eip) {
            var _this = this;
            eip.progressOn();
            var msg = new ApiHeader.APIChangeEipStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = eip.uuid;
            this.api.asyncApi(msg, function (ret) {
                eip.updateObservableObject(ret.inventory);
                eip.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled EIP: {0}', eip.name),
                    link: Utils.sprintf('/#/eip/{0}', eip.uuid)
                });
            });
        };
        EipManager.prototype.delete = function (eip, done) {
            var _this = this;
            eip.progressOn();
            var msg = new ApiHeader.APIDeleteEipMsg();
            msg.uuid = eip.uuid;
            this.api.asyncApi(msg, function (ret) {
                eip.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted EIP: {0}', eip.name)
                });
            });
        };
        EipManager.$inject = ['Api', '$rootScope'];
        return EipManager;
    })();
    MEip.EipManager = EipManager;
    var EipModel = (function (_super) {
        __extends(EipModel, _super);
        function EipModel() {
            _super.call(this);
            this.current = new Eip();
        }
        return EipModel;
    })(Utils.Model);
    MEip.EipModel = EipModel;
    var OEipGrid = (function (_super) {
        __extends(OEipGrid, _super);
        function OEipGrid($scope, eipMgr, vmMgr, vipMgr) {
            _super.call(this);
            this.eipMgr = eipMgr;
            this.vmMgr = vmMgr;
            this.vipMgr = vipMgr;
            _super.prototype.init.call(this, $scope, $scope.eipGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"eip.ts.NAME" | translate}}',
                    width: '25%',
                    template: '<a href="/\\#/eip/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'state',
                    title: '{{"eip.ts.STATE" | translate}}',
                    width: '25%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'vipIp',
                    title: '{{"eip.ts.VIP IP" | translate}}',
                    width: '25%'
                },
                {
                    field: 'vmNicIp',
                    title: '{{"eip.ts.VM NIC IP" | translate}}',
                    width: '25%'
                },
            ];
            this.options.dataSource.transport.read = function (options) {
                var chain = new Utils.Chain();
                var eips = [];
                var vips = {};
                var vmNics = {};
                var composedEip = [];
                var total = null;
                chain.then(function () {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.limit = options.data.take;
                    qobj.start = options.data.pageSize * (options.data.page - 1);
                    eipMgr.query(qobj, function (ret, amount) {
                        eips = ret;
                        total = amount;
                        chain.next();
                    });
                }).then(function () {
                    if (eips.length == 0) {
                        chain.next();
                        return;
                    }
                    var nicUuids = [];
                    angular.forEach(eips, function (it) {
                        if (Utils.notNullnotUndefined(it.vmNicUuid)) {
                            nicUuids.push(it.vmNicUuid);
                        }
                    });
                    if (nicUuids.length == 0) {
                        chain.next();
                        return;
                    }
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [
                        {
                            name: 'uuid',
                            op: 'in',
                            value: nicUuids.join()
                        }
                    ];
                    vmMgr.queryVmNic(qobj, function (ns) {
                        angular.forEach(ns, function (it) {
                            vmNics[it.uuid] = it;
                        });
                        chain.next();
                    });
                }).then(function () {
                    if (eips.length == 0) {
                        chain.next();
                        return;
                    }
                    var vipUuids = [];
                    angular.forEach(eips, function (it) {
                        vipUuids.push(it.vipUuid);
                    });
                    if (vipUuids.length == 0) {
                        chain.next();
                        return;
                    }
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [
                        {
                            name: 'uuid',
                            op: 'in',
                            value: vipUuids.join()
                        }
                    ];
                    vipMgr.query(qobj, function (vs) {
                        angular.forEach(vs, function (it) {
                            vips[it.uuid] = it;
                        });
                        chain.next();
                    });
                }).then(function () {
                    if (eips.length == 0) {
                        chain.next();
                        return;
                    }
                    angular.forEach(eips, function (it) {
                        if (Utils.notNullnotUndefined(it.vmNicUuid)) {
                            var nic = vmNics[it.vmNicUuid];
                            it.extendVmNicIp(nic.ip);
                        }
                        var vip = vips[it.vipUuid];
                        it.extendVip(vip.ip);
                        composedEip.push(it);
                    });
                    chain.next();
                }).done(function () {
                    options.success({
                        data: composedEip,
                        total: total
                    });
                }).start();
            };
        }
        return OEipGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, eipMgr) {
            this.$scope = $scope;
            this.eipMgr = eipMgr;
        }
        Action.prototype.enable = function () {
            this.eipMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.eipMgr.disable(this.$scope.model.current);
        };
        Action.prototype.attach = function () {
            this.$scope.attachEip.open();
        };
        Action.prototype.detach = function () {
            this.$scope.detachEip.open();
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope) {
            var _this = this;
            this.$scope = $scope;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"eip.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"eip.ts.STATE" | translate}}',
                            value: FilterBy.STATE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oEipGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, eipMgr, $routeParams, tagService, current, vmMgr) {
            var _this = this;
            this.$scope = $scope;
            this.eipMgr = eipMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.vmMgr = vmMgr;
            $scope.model = new EipModel();
            $scope.model.current = current.eip;
            $scope.vip = current.vip;
            $scope.nic = current.nic;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, eipMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteEip = {
                title: 'DELETE EIP',
                btnType: 'btn-danger',
                width: '350px',
                description: function () {
                    return current.name;
                },
                confirm: function () {
                    eipMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeEipVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsDetachEip = {
                eip: current.eip,
                done: function () {
                    $scope.nic = null;
                }
            };
            $scope.optionsAttachEip = {
                eip: current.eip,
                done: function () {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [{
                            name: 'uuid',
                            op: '=',
                            value: current.eip.vmNicUuid
                        }];
                    vmMgr.queryVmNic(qobj, function (nics) {
                        current.eip.extendVmNicIp(nics[0].ip);
                        $scope.nic = nics[0];
                    });
                }
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.eipMgr.query(qobj, function (eips, total) {
                _this.$scope.model.current = eips[0];
            });
        };
        DetailsController.$inject = ['$scope', 'EipManager', '$routeParams', 'Tag', 'current', 'VmInstanceManager'];
        return DetailsController;
    })();
    MEip.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, eipMgr, $location, vipMgr, vmMgr) {
            this.$scope = $scope;
            this.eipMgr = eipMgr;
            this.$location = $location;
            this.vipMgr = vipMgr;
            this.vmMgr = vmMgr;
            $scope.model = new EipModel();
            $scope.oEipGrid = new OEipGrid($scope, eipMgr, vmMgr, vipMgr);
            $scope.action = new Action($scope, eipMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"eip.ts.NAME" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"eip.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"eip.ts.STATE" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"eip.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"eip.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    eipMgr.setSortBy(ret);
                    $scope.oEipGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.EipInventoryQueryable,
                name: 'Eip',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    eipMgr.query(qobj, function (Eips, total) {
                        $scope.oEipGrid.refresh(Eips);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/eip/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateEip = function (win) {
                win.open();
            };
            $scope.funcDeleteEip = function () {
                $scope.deleteEip.open();
            };
            $scope.optionsDeleteEip = {
                title: 'DELETE EIP',
                btnType: 'btn-danger',
                width: '350px',
                description: function () {
                    return $scope.model.current.name;
                },
                confirm: function () {
                    eipMgr.delete($scope.model.current, function (ret) {
                        $scope.oEipGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oEipGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsAttachEip = {
                eip: null,
                done: function () {
                    var eip = $scope.optionsAttachEip.eip;
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [{
                            name: 'uuid',
                            op: '=',
                            value: eip.vmNicUuid
                        }];
                    vmMgr.queryVmNic(qobj, function (nics) {
                        eip.extendVmNicIp(nics[0].ip);
                    });
                }
            };
            $scope.optionsDetachEip = {
                eip: null,
                done: function () {
                    $scope.optionsDetachEip.eip.extendVmNicIp(null);
                }
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    $scope.optionsAttachEip.eip = $scope.model.current;
                    $scope.optionsDetachEip.eip = $scope.model.current;
                }
            });
            $scope.optionsCreateEip = {
                done: function (eip) {
                    var chain = new Utils.Chain();
                    var composedEip = {};
                    angular.extend(composedEip, eip);
                    chain.then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'uuid',
                                op: '=',
                                value: eip.vipUuid
                            }
                        ];
                        vipMgr.query(qobj, function (ret) {
                            var vip = ret[0];
                            eip.extendVip(vip.ip);
                            chain.next();
                        });
                    }).then(function () {
                        if (!Utils.notNullnotUndefined(eip.vmNicUuid)) {
                            chain.next();
                            return;
                        }
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'uuid',
                                op: '=',
                                value: eip.vmNicUuid
                            }
                        ];
                        vmMgr.queryVmNic(qobj, function (ret) {
                            var nic = ret[0];
                            eip.extendVmNicIp(nic.ip);
                            chain.next();
                        });
                    }).done(function () {
                        $scope.oEipGrid.add(eip);
                    }).start();
                }
            };
        }
        Controller.$inject = ['$scope', 'EipManager', '$location', 'VipManager', 'VmInstanceManager'];
        return Controller;
    })();
    MEip.Controller = Controller;
    var CreateEip = (function () {
        function CreateEip(api, eipMgr, vipMgr, l3Mgr, vmMgr) {
            var _this = this;
            this.api = api;
            this.eipMgr = eipMgr;
            this.vipMgr = vipMgr;
            this.l3Mgr = l3Mgr;
            this.vmMgr = vmMgr;
            this.existingVip = {};
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateEip;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = {};
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var vipPage = $scope.vipPage = {
                    activeState: true,
                    method: null,
                    vipUuid: null,
                    l3NetworkUuid: null,
                    vip: null,
                    isVipCreating: false,
                    canCreate: function () {
                        return !Utils.notNullnotUndefined(this.vip) && $scope.l3NetworkListOptions__.dataSource.data().length > 0 && this.method == CreateEip.CREATE_NEW_VIP;
                    },
                    hasL3Network: function () {
                        return $scope.l3NetworkListOptions__.dataSource.data().length > 0;
                    },
                    hasVip: function () {
                        return $scope.vipListOptions__.dataSource.data().length > 0;
                    },
                    create: function () {
                        var _this = this;
                        this.isVipCreating = true;
                        vipMgr.create({
                            name: Utils.sprintf('vip-{0}', Utils.uuid()),
                            l3NetworkUuid: this.l3NetworkUuid
                        }, function (ret) {
                            _this.vip = ret;
                            _this.isVipCreating = false;
                        });
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.vipUuid) || Utils.notNullnotUndefined(this.vip);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createEipVip"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createEipVip';
                    },
                    reset: function () {
                        this.method = CreateEip.CREATE_NEW_VIP;
                        this.l3NetworkUuid = null;
                        this.vip = null;
                        this.vipUuid = null;
                        this.activeState = false;
                    }
                };
                $scope.vipMethodOptions__ = {
                    dataSource: new kendo.data.DataSource({
                        data: [{
                                name: '{{"eip.ts.Create New VIP" | translate}}',
                                field: CreateEip.CREATE_NEW_VIP
                            }, {
                                name: '{{"eip.ts.Use Existing VIP" | translate}}',
                                field: CreateEip.USE_EXISTING_VIP
                            }]
                    }),
                    dataTextField: "name",
                    dataValueField: "field"
                };
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    vmNicUuid: null,
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createEipInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createEipInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('eip');
                        this.description = null;
                        this.vmNicUuid = null;
                        this.activeState = false;
                    },
                    hasVm: function () {
                        return $scope.vmListOptions__.dataSource.data().length > 0;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        var resultEip;
                        var chain = new Utils.Chain();
                        chain.then(function () {
                            var vipUuid = null;
                            if (Utils.notNullnotUndefined($scope.vipPage.vip)) {
                                vipUuid = $scope.vipPage.vip.uuid;
                            }
                            else {
                                vipUuid = $scope.vipPage.vipUuid;
                            }
                            eipMgr.create({
                                vipUuid: vipUuid,
                                vmNicUuid: $scope.infoPage.vmNicUuid == "" ? null : $scope.infoPage.vmNicUuid,
                                name: $scope.infoPage.name,
                                description: $scope.infoPage.description
                            }, function (ret) {
                                resultEip = ret;
                                chain.next();
                            });
                        }).done(function () {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(resultEip);
                            }
                        }).start();
                        $scope.winCreateEip__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    vipPage, infoPage
                ], mediator);
                $scope.winCreateEipOptions__ = {
                    width: '700px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.vipListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"eip.ts.NAME" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.IP" | translate}}:</span><span>#: ip #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Gateway" | translate}}:</span><span>#: gateway #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Netmask" | translate}}:</span><span>#: netmask #</span></div>'
                };
                $scope.l3NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"eip.ts.NAME" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Zone UUID" | translate}}:</span><span>#: zoneUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.L2 Network UUID" | translate}}:</span><span>#: l2NetworkUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.vmListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "nicUuid",
                    template: '<div style="color: black"><span class="z-label">{{"eip.ts.VM Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.VM UUID" | translate}}:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic DeviceId" | translate}}:</span><span>#: nicDeviceId #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic Ip" | translate}}:</span><span>#: nicIp #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic Netmask" | translate}}:</span><span>#: nicNetmask #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic Gateway" | translate}}:</span><span>#: nicGateway #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic Mac" | translate}}:</span><span>#: nicMac #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.L3 Network UUID" | translate}}:</span><span>#: l3NetworkUuid #</span></div>'
                };
                $scope.$watch(function () {
                    return [$scope.vipPage.vipUuid, $scope.vipPage.vip];
                }, function () {
                    var vip = null;
                    if (Utils.notNullnotUndefined($scope.vipPage.vip)) {
                        vip = $scope.vipPage.vip;
                    }
                    else if (Utils.notNullnotUndefined($scope.vipPage.vipUuid)) {
                        vip = _this.existingVip[$scope.vipPage.vipUuid];
                    }
                    if (!Utils.notNullnotUndefined(vip)) {
                        $scope.vipPage.vipUuid = null;
                        $scope.vipPage.vip = null;
                        return;
                    }
                    var chain = new Utils.Chain();
                    var vmNics = [];
                    var composedVms = [];
                    chain.then(function () {
                        _this.eipMgr.getAttachableVmNicByVipUuid(vip.uuid, function (nics) {
                            vmNics = nics;
                            chain.next();
                        });
                    }).done(function () {
                        if (vmNics.length == 0) {
                            $scope.vmListOptions__.dataSource.data(composedVms);
                            $scope.infoPage.vmNicUuid = null;
                            return;
                        }
                        var nicUuids = [];
                        angular.forEach(vmNics, function (it) {
                            nicUuids.push(it.uuid);
                        });
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [{
                                name: 'vmNics.uuid',
                                op: 'in',
                                value: nicUuids.join()
                            }];
                        _this.vmMgr.query(qobj, function (vms) {
                            angular.forEach(vms, function (it) {
                                angular.forEach(it.vmNics, function (nic) {
                                    if (nic.l3NetworkUuid == vip.l3NetworkUuid) {
                                        return;
                                    }
                                    composedVms.push({
                                        name: it.name,
                                        uuid: it.uuid,
                                        nicDeviceId: nic.deviceId,
                                        nicIp: nic.ip,
                                        nicNetmask: nic.netmask,
                                        nicGateway: nic.gateway,
                                        nicMac: nic.mac,
                                        l3NetworkUuid: nic.l3NetworkUuid,
                                        nicUuid: nic.uuid
                                    });
                                });
                            });
                            $scope.vmListOptions__.dataSource.data(composedVms);
                            $scope.infoPage.vmNicUuid = null;
                        });
                    }).start();
                }, true);
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/eip/createEip.html';
        }
        CreateEip.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateEip__;
            this.$scope.button.reset();
            var chain = new Utils.Chain();
            this.existingVip = {};
            this.$scope.vipPage.method = CreateEip.CREATE_NEW_VIP;
            this.$scope.vipPage.isVipCreating = false;
            this.$scope.vipPage.vipUuid = null;
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'state',
                        op: '=',
                        value: 'Enabled'
                    }, {
                        name: 'useFor',
                        op: 'is null',
                        value: null
                    }];
                _this.vipMgr.query(qobj, function (ret) {
                    _this.$scope.vipListOptions__.dataSource.data(ret);
                    if (ret.length > 0) {
                        angular.forEach(ret, function (it) {
                            _this.existingVip[it.uuid] = it;
                        });
                    }
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [];
                _this.l3Mgr.query(qobj, function (ret) {
                    _this.$scope.l3NetworkListOptions__.dataSource.data(ret);
                    if (ret.length > 0) {
                        _this.$scope.vipPage.l3NetworkUuid = ret[0].uuid;
                    }
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        CreateEip.USE_EXISTING_VIP = "existing";
        CreateEip.CREATE_NEW_VIP = "new";
        return CreateEip;
    })();
    MEip.CreateEip = CreateEip;
    var AttachEip = (function () {
        function AttachEip(eipMgr, vmMgr) {
            var _this = this;
            this.eipMgr = eipMgr;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/eip/attachEip.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zEipAttachVm] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.vmListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "nicUuid",
                    template: '<div style="color: black"><span class="z-label">{{"eip.ts.VM Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.VM UUID" | translate}}:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic DeviceId" | translate}}:</span><span>#: nicDeviceId #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic Ip" | translate}}:</span><span>#: nicIp #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic Netmask" | translate}}:</span><span>#: nicNetmask #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic Gateway" | translate}}:</span><span>#: nicGateway #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.Nic Mac" | translate}}:</span><span>#: nicMac #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"eip.ts.L3 Network UUID" | translate}}:</span><span>#: l3NetworkUuid #</span></div>'
                };
                $scope.hasVm = function () {
                    return $scope.vmListOptions__.dataSource.data().length > 0;
                };
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.vmNicUuid);
                };
                $scope.cancel = function () {
                    $scope.attachEip__.close();
                };
                $scope.done = function () {
                    eipMgr.attach(_this.options.eip, $scope.vmNicUuid, function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done();
                        }
                    });
                    $scope.attachEip__.close();
                };
                _this.$scope = $scope;
                $scope.attachEipOptions__ = {
                    width: '550px'
                };
            };
        }
        AttachEip.prototype.open = function () {
            var _this = this;
            this.$scope.vmListOptions__.dataSource.data([]);
            var chain = new Utils.Chain();
            var vmNics = [];
            var composedVms = [];
            chain.then(function () {
                _this.eipMgr.getAttachableVmNicByEipUuid(_this.options.eip.uuid, function (nics) {
                    vmNics = nics;
                    chain.next();
                });
            }).then(function () {
                if (vmNics.length == 0) {
                    _this.$scope.vmListOptions__.dataSource.data(composedVms);
                    _this.$scope.vmNicUuid = null;
                    chain.next();
                    return;
                }
                var nicUuids = [];
                angular.forEach(vmNics, function (it) {
                    nicUuids.push(it.uuid);
                });
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'vmNics.uuid',
                        op: 'in',
                        value: nicUuids.join()
                    }];
                _this.vmMgr.query(qobj, function (vms) {
                    angular.forEach(vms, function (it) {
                        angular.forEach(it.vmNics, function (nic) {
                            if (nicUuids.indexOf(nic.uuid) == -1) {
                                return;
                            }
                            composedVms.push({
                                name: it.name,
                                uuid: it.uuid,
                                nicDeviceId: nic.deviceId,
                                nicIp: nic.ip,
                                nicNetmask: nic.netmask,
                                nicGateway: nic.gateway,
                                nicMac: nic.mac,
                                l3NetworkUuid: nic.l3NetworkUuid,
                                nicUuid: nic.uuid
                            });
                        });
                    });
                    _this.$scope.vmListOptions__.dataSource.data(composedVms);
                    if (composedVms.length > 0) {
                        _this.$scope.vmNicUuid = composedVms[0].nicUuid;
                    }
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachEip__.center();
                _this.$scope.attachEip__.open();
            }).start();
        };
        return AttachEip;
    })();
    MEip.AttachEip = AttachEip;
    var DetachEip = (function () {
        function DetachEip(eipMgr, vmMgr) {
            var _this = this;
            this.eipMgr = eipMgr;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/eip/detachEip.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zEipDetachVm] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.cancel = function () {
                    $scope.detachEip__.close();
                };
                $scope.done = function () {
                    eipMgr.detach(_this.options.eip, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.detachEip__.close();
                };
                $scope.optionsDetachEip__ = {
                    width: '500px'
                };
                $scope.vmStateLabel = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return '';
                    }
                    var vm = $scope.vm;
                    if (vm.state == 'Running') {
                        return 'label label-success';
                    }
                    else if (vm.state == 'Stopped') {
                        return 'label label-danger';
                    }
                    else if (vm.state == 'Unknown') {
                        return 'label label-warning';
                    }
                    else {
                        return 'label label-default';
                    }
                };
                $scope.isVmInCorrectState = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return true;
                    }
                    return $scope.vm.state == 'Running' || $scope.vm.state == 'Stopped';
                };
                $scope.canProceed = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return false;
                    }
                    return $scope.isVmInCorrectState();
                };
                _this.$scope = $scope;
            };
        }
        DetachEip.prototype.open = function () {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'vmNics.uuid',
                    op: '=',
                    value: this.options.eip.vmNicUuid
                }
            ];
            this.vmMgr.query(qobj, function (vms) {
                if (vms.length > 0) {
                    var vm = vms[0];
                    _this.$scope.vm = vm;
                    angular.forEach(vm.vmNics, function (it) {
                        _this.$scope.vm['nicDeviceId'] = it.deviceId;
                        _this.$scope.vm['nicMac'] = it.mac;
                        _this.$scope.vm['nicIp'] = it.ip;
                        _this.$scope.vm['nicNetmask'] = it.netmask;
                        _this.$scope.vm['nicGateway'] = it.gateway;
                    });
                }
                _this.$scope.detachEip__.center();
                _this.$scope.detachEip__.open();
            });
        };
        return DetachEip;
    })();
    MEip.DetachEip = DetachEip;
})(MEip || (MEip = {}));
angular.module('root').factory('EipManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MEip.EipManager(api, $rootScope);
    }]).directive('zCreateEip', ['Api', 'EipManager', 'VipManager', 'L3NetworkManager', 'VmInstanceManager', function (api, eipMgr, vipMgr, l3Mgr, vmMgr) {
        return new MEip.CreateEip(api, eipMgr, vipMgr, l3Mgr, vmMgr);
    }]).directive('zEipAttachVm', ['EipManager', 'VmInstanceManager', function (eipMgr, vmMgr) {
        return new MEip.AttachEip(eipMgr, vmMgr);
    }]).directive('zEipDetachVm', ['EipManager', 'VmInstanceManager', function (eipMgr, vmMgr) {
        return new MEip.DetachEip(eipMgr, vmMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/eip', {
            templateUrl: '/static/templates/eip/eip.html',
            controller: 'MEip.Controller'
        }).when('/eip/:uuid', {
            templateUrl: '/static/templates/eip/details.html',
            controller: 'MEip.DetailsController',
            resolve: {
                current: function ($q, $route, EipManager, VmInstanceManager, VipManager) {
                    var defer = $q.defer();
                    var uuid = $route.current.params.uuid;
                    var ret = {
                        eip: null,
                        nic: null,
                        vip: null
                    };
                    var chain = new Utils.Chain();
                    chain.then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                        EipManager.query(qobj, function (eips) {
                            ret.eip = eips[0];
                            chain.next();
                        });
                    }).then(function () {
                        if (!Utils.notNullnotUndefined(ret.eip.vmNicUuid)) {
                            chain.next();
                            return;
                        }
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [{
                                name: 'uuid',
                                op: '=',
                                value: ret.eip.vmNicUuid
                            }];
                        VmInstanceManager.queryVmNic(qobj, function (nics) {
                            ret.nic = nics[0];
                            chain.next();
                        });
                    }).then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [{
                                name: 'uuid',
                                op: '=',
                                value: ret.eip.vipUuid
                            }];
                        VipManager.query(qobj, function (vips) {
                            ret.vip = vips[0];
                            chain.next();
                        });
                    }).done(function () {
                        defer.resolve(ret);
                    }).start();
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MPortForwarding;
(function (MPortForwarding) {
    var PortForwarding = (function (_super) {
        __extends(PortForwarding, _super);
        function PortForwarding() {
            _super.apply(this, arguments);
        }
        PortForwarding.prototype.progressOn = function () {
            this.inProgress = true;
        };
        PortForwarding.prototype.progressOff = function () {
            this.inProgress = false;
        };
        PortForwarding.prototype.isInProgress = function () {
            return this.inProgress;
        };
        PortForwarding.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        PortForwarding.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        PortForwarding.prototype.isAttachShow = function () {
            return !Utils.notNullnotUndefined(this.vmNicUuid);
        };
        PortForwarding.prototype.isDetachShow = function () {
            return !this.isAttachShow();
        };
        PortForwarding.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        PortForwarding.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('vmNicUuid', inv.vmNicUuid);
            self.set('vipUuid', inv.vipUuid);
            self.set('vipPortStart', inv.vipPortStart);
            self.set('vipPortEnd', inv.vipPortEnd);
            self.set('privatePortStart', inv.privatePortStart);
            self.set('privatePortEnd', inv.privatePortEnd);
            self.set('protocolType', inv.protocolType);
            self.set('allowedCidr', inv.allowedCidr);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        PortForwarding.prototype.extendVip = function (vip) {
            var self = this;
            this['vipIp'] = vip;
            self.set('vipIp', vip);
        };
        PortForwarding.prototype.extendVmNicIp = function (nicIp) {
            var self = this;
            this['vmNicIp'] = nicIp;
            self.set('vmNicIp', nicIp);
        };
        PortForwarding.wrap = function (obj) {
            var pf = new PortForwarding();
            angular.extend(pf, obj);
            return pf;
        };
        return PortForwarding;
    })(ApiHeader.PortForwardingRuleInventory);
    MPortForwarding.PortForwarding = PortForwarding;
    var PortForwardingManager = (function () {
        function PortForwardingManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        PortForwardingManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        PortForwardingManager.prototype.wrap = function (PortForwarding) {
            return new kendo.data.ObservableObject(PortForwarding);
        };
        PortForwardingManager.prototype.create = function (pf, done) {
            var _this = this;
            var msg = new ApiHeader.APICreatePortForwardingRuleMsg();
            msg.name = pf.name;
            msg.description = pf.description;
            msg.vipUuid = pf.vipUuid;
            msg.vmNicUuid = pf.vmNicUuid;
            msg.vipPortStart = pf.vipPortStart;
            msg.vipPortEnd = pf.vipPortEnd;
            msg.privatePortStart = pf.privatePortStart;
            msg.privatePortEnd = pf.privatePortEnd;
            msg.allowedCidr = pf.allowedCidr;
            msg.protocolType = pf.protocolType;
            this.api.asyncApi(msg, function (ret) {
                var c = new PortForwarding();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Created new port forwarding rule: {0}', c.name),
                    link: Utils.sprintf('/#/portForwarding/{0}', c.uuid)
                });
            });
        };
        PortForwardingManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryPortForwardingRuleMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new PortForwarding();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        PortForwardingManager.prototype.getAttachableVmNicByPortForwardingUuid = function (uuid, done) {
            var msg = new ApiHeader.APIGetPortForwardingAttachableVmNicsMsg();
            msg.ruleUuid = uuid;
            this.api.syncApi(msg, function (ret) {
                done(ret.inventories);
            });
        };
        PortForwardingManager.prototype.attach = function (pf, vmNicUuid, done) {
            var _this = this;
            pf.progressOn();
            var msg = new ApiHeader.APIAttachPortForwardingRuleMsg();
            msg.ruleUuid = pf.uuid;
            msg.vmNicUuid = vmNicUuid;
            this.api.asyncApi(msg, function (ret) {
                pf.updateObservableObject(ret.inventory);
                pf.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Attached port forwarding rule: {0}', pf.name),
                    link: Utils.sprintf('/#/portForwarding/{0}', pf.uuid)
                });
            });
        };
        PortForwardingManager.prototype.detach = function (pf, done) {
            var _this = this;
            pf.progressOn();
            var msg = new ApiHeader.APIDetachPortForwardingRuleMsg();
            msg.uuid = pf.uuid;
            this.api.asyncApi(msg, function (ret) {
                pf.updateObservableObject(ret.inventory);
                pf.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Detached port forwarding rule: {0}', pf.name),
                    link: Utils.sprintf('/#/portForwarding/{0}', pf.uuid)
                });
            });
        };
        PortForwardingManager.prototype.disable = function (pf) {
            var _this = this;
            pf.progressOn();
            var msg = new ApiHeader.APIChangePortForwardingRuleStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = pf.uuid;
            this.api.asyncApi(msg, function (ret) {
                pf.updateObservableObject(ret.inventory);
                pf.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled port forwarding rule: {0}', pf.name),
                    link: Utils.sprintf('/#/portForwarding/{0}', pf.uuid)
                });
            });
        };
        PortForwardingManager.prototype.enable = function (pf) {
            var _this = this;
            pf.progressOn();
            var msg = new ApiHeader.APIChangePortForwardingRuleStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = pf.uuid;
            this.api.asyncApi(msg, function (ret) {
                pf.updateObservableObject(ret.inventory);
                pf.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled port forwarding rule: {0}', pf.name),
                    link: Utils.sprintf('/#/portForwarding/{0}', pf.uuid)
                });
            });
        };
        PortForwardingManager.prototype.delete = function (pf, done) {
            var _this = this;
            pf.progressOn();
            var msg = new ApiHeader.APIDeletePortForwardingRuleMsg();
            msg.uuid = pf.uuid;
            this.api.asyncApi(msg, function (ret) {
                pf.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted EIP: {0}', pf.name)
                });
            });
        };
        PortForwardingManager.$inject = ['Api', '$rootScope'];
        return PortForwardingManager;
    })();
    MPortForwarding.PortForwardingManager = PortForwardingManager;
    var PortForwardingModel = (function (_super) {
        __extends(PortForwardingModel, _super);
        function PortForwardingModel() {
            _super.call(this);
            this.current = new PortForwarding();
        }
        return PortForwardingModel;
    })(Utils.Model);
    MPortForwarding.PortForwardingModel = PortForwardingModel;
    var OPortForwardingGrid = (function (_super) {
        __extends(OPortForwardingGrid, _super);
        function OPortForwardingGrid($scope, pfMgr, vmMgr, vipMgr) {
            _super.call(this);
            this.pfMgr = pfMgr;
            this.vmMgr = vmMgr;
            this.vipMgr = vipMgr;
            _super.prototype.init.call(this, $scope, $scope.pfGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"portForwarding.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/pf/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'state',
                    title: '{{"portForwarding.ts.STATE" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'vipPortStart',
                    title: '{{"portForwarding.ts.VIP PORT START" | translate}}',
                    width: '10%'
                },
                {
                    field: 'vipPortEnd',
                    title: '{{"portForwarding.ts.VIP PORT END" | translate}}',
                    width: '10%'
                },
                {
                    field: 'privatePortStart',
                    title: '{{"portForwarding.ts.GUEST PORT START" | translate}}',
                    width: '10%'
                },
                {
                    field: 'privatePortEnd',
                    title: '{{"portForwarding.ts.GUEST PORT END" | translate}}',
                    width: '10%'
                },
                {
                    field: 'vipIp',
                    title: '{{"portForwarding.ts.VIP IP" | translate}}',
                    width: '20%'
                },
                {
                    field: 'vmNicIp',
                    title: '{{"portForwarding.ts.VM NIC IP" | translate}}',
                    width: '20%'
                },
            ];
            this.options.dataSource.transport.read = function (options) {
                var chain = new Utils.Chain();
                var pfs = [];
                var vips = {};
                var vmNics = {};
                var composedPortForwarding = [];
                var total = null;
                chain.then(function () {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.limit = options.data.take;
                    qobj.start = options.data.pageSize * (options.data.page - 1);
                    pfMgr.query(qobj, function (ret, amount) {
                        pfs = ret;
                        total = amount;
                        chain.next();
                    });
                }).then(function () {
                    if (pfs.length == 0) {
                        chain.next();
                        return;
                    }
                    var nicUuids = [];
                    angular.forEach(pfs, function (it) {
                        if (Utils.notNullnotUndefined(it.vmNicUuid)) {
                            nicUuids.push(it.vmNicUuid);
                        }
                    });
                    if (nicUuids.length == 0) {
                        chain.next();
                        return;
                    }
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [
                        {
                            name: 'uuid',
                            op: 'in',
                            value: nicUuids.join()
                        }
                    ];
                    vmMgr.queryVmNic(qobj, function (ns) {
                        angular.forEach(ns, function (it) {
                            vmNics[it.uuid] = it;
                        });
                        chain.next();
                    });
                }).then(function () {
                    if (pfs.length == 0) {
                        chain.next();
                        return;
                    }
                    var vipUuids = [];
                    angular.forEach(pfs, function (it) {
                        vipUuids.push(it.vipUuid);
                    });
                    if (vipUuids.length == 0) {
                        chain.next();
                        return;
                    }
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [
                        {
                            name: 'uuid',
                            op: 'in',
                            value: vipUuids.join()
                        }
                    ];
                    vipMgr.query(qobj, function (vs) {
                        angular.forEach(vs, function (it) {
                            vips[it.uuid] = it;
                        });
                        chain.next();
                    });
                }).then(function () {
                    if (pfs.length == 0) {
                        chain.next();
                        return;
                    }
                    angular.forEach(pfs, function (it) {
                        if (Utils.notNullnotUndefined(it.vmNicUuid)) {
                            var nic = vmNics[it.vmNicUuid];
                            it.extendVmNicIp(nic.ip);
                        }
                        var vip = vips[it.vipUuid];
                        it.extendVip(vip.ip);
                        composedPortForwarding.push(it);
                    });
                    chain.next();
                }).done(function () {
                    options.success({
                        data: composedPortForwarding,
                        total: total
                    });
                }).start();
            };
        }
        return OPortForwardingGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, pfMgr) {
            this.$scope = $scope;
            this.pfMgr = pfMgr;
        }
        Action.prototype.enable = function () {
            this.pfMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.pfMgr.disable(this.$scope.model.current);
        };
        Action.prototype.attach = function () {
            this.$scope.attachPortForwarding.open();
        };
        Action.prototype.detach = function () {
            this.$scope.detachPortForwarding.open();
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope) {
            var _this = this;
            this.$scope = $scope;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"portForwarding.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"portForwarding.ts.State" | translate}}',
                            value: FilterBy.STATE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oPortForwardingGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, pfMgr, $routeParams, tagService, current, vmMgr) {
            var _this = this;
            this.$scope = $scope;
            this.pfMgr = pfMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.vmMgr = vmMgr;
            $scope.model = new PortForwardingModel();
            $scope.model.current = current.pf;
            $scope.vip = current.vip;
            $scope.nic = current.nic;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, pfMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeletePortForwarding = {
                title: 'DELETE PORT FORWARDING RULE',
                description: function () {
                    return current.name;
                },
                btnType: 'btn-danger',
                width: '350px',
                confirm: function () {
                    pfMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypePortForwardingRuleVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsDetachPortForwarding = {
                pf: current.pf,
                done: function () {
                    $scope.nic = null;
                }
            };
            $scope.optionsAttachPortForwarding = {
                pf: current.pf,
                done: function () {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [{
                            name: 'uuid',
                            op: '=',
                            value: current.pf.vmNicUuid
                        }];
                    vmMgr.queryVmNic(qobj, function (nics) {
                        current.pf.extendVmNicIp(nics[0].ip);
                        $scope.nic = nics[0];
                    });
                }
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.pfMgr.query(qobj, function (pfs, total) {
                _this.$scope.model.current = pfs[0];
            });
        };
        DetailsController.$inject = ['$scope', 'PortForwardingManager', '$routeParams', 'Tag', 'current', 'VmInstanceManager'];
        return DetailsController;
    })();
    MPortForwarding.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, pfMgr, $location, vipMgr, vmMgr) {
            this.$scope = $scope;
            this.pfMgr = pfMgr;
            this.$location = $location;
            this.vipMgr = vipMgr;
            this.vmMgr = vmMgr;
            $scope.model = new PortForwardingModel();
            $scope.oPortForwardingGrid = new OPortForwardingGrid($scope, pfMgr, vmMgr, vipMgr);
            $scope.action = new Action($scope, pfMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"portForwarding.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"portForwarding.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"portForwarding.ts.VIP Port Start" | translate}}',
                        value: 'vipPortStart'
                    },
                    {
                        name: '{{"portForwarding.ts.VIP Port End" | translate}}',
                        value: 'vipPortEnd'
                    },
                    {
                        name: '{{"portForwarding.ts.Private Port Start" | translate}}',
                        value: 'privatePortStart'
                    },
                    {
                        name: '{{"portForwarding.ts.Private Port End" | translate}}',
                        value: 'privatePortEnd'
                    },
                    {
                        name: '{{"portForwarding.ts.Protocol" | translate}}',
                        value: 'protocolType'
                    },
                    {
                        name: '{{"portForwarding.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"portForwarding.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"portForwarding.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    pfMgr.setSortBy(ret);
                    $scope.oPortForwardingGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.PortForwardingRuleInventoryQueryable,
                name: 'PortForwarding',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    protocol: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['UDP', 'TCP']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    pfMgr.query(qobj, function (PortForwardings, total) {
                        $scope.oPortForwardingGrid.refresh(PortForwardings);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/portForwarding/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreatePortForwarding = function (win) {
                win.open();
            };
            $scope.funcDeletePortForwarding = function () {
                $scope.deletePortForwarding.open();
            };
            $scope.optionsDeletePortForwarding = {
                title: 'DELETE PORT FORWARDING RULE',
                description: function () {
                    return $scope.model.current.name;
                },
                btnType: 'btn-danger',
                width: '350px',
                confirm: function () {
                    pfMgr.delete($scope.model.current, function (ret) {
                        $scope.oPortForwardingGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oPortForwardingGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsAttachPortForwarding = {
                pf: null,
                done: function () {
                    var pf = $scope.optionsAttachPortForwarding.pf;
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [{
                            name: 'uuid',
                            op: '=',
                            value: pf.vmNicUuid
                        }];
                    vmMgr.queryVmNic(qobj, function (nics) {
                        pf.extendVmNicIp(nics[0].ip);
                    });
                }
            };
            $scope.optionsDetachPortForwarding = {
                pf: null,
                done: function () {
                    $scope.optionsDetachPortForwarding.pf.extendVmNicIp(null);
                }
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    $scope.optionsAttachPortForwarding.pf = $scope.model.current;
                    $scope.optionsDetachPortForwarding.pf = $scope.model.current;
                }
            });
            $scope.optionsCreatePortForwarding = {
                done: function (pf) {
                    var chain = new Utils.Chain();
                    var composedPortForwarding = {};
                    angular.extend(composedPortForwarding, pf);
                    chain.then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'uuid',
                                op: '=',
                                value: pf.vipUuid
                            }
                        ];
                        vipMgr.query(qobj, function (ret) {
                            var vip = ret[0];
                            pf.extendVip(vip.ip);
                            chain.next();
                        });
                    }).then(function () {
                        if (!Utils.notNullnotUndefined(pf.vmNicUuid)) {
                            chain.next();
                            return;
                        }
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'uuid',
                                op: '=',
                                value: pf.vmNicUuid
                            }
                        ];
                        vmMgr.queryVmNic(qobj, function (ret) {
                            var nic = ret[0];
                            pf.extendVmNicIp(nic.ip);
                            chain.next();
                        });
                    }).done(function () {
                        $scope.oPortForwardingGrid.add(pf);
                    }).start();
                }
            };
        }
        Controller.$inject = ['$scope', 'PortForwardingManager', '$location', 'VipManager', 'VmInstanceManager'];
        return Controller;
    })();
    MPortForwarding.Controller = Controller;
    var CreatePortForwarding = (function () {
        function CreatePortForwarding(api, pfMgr, vipMgr, l3Mgr, vmMgr) {
            var _this = this;
            this.api = api;
            this.pfMgr = pfMgr;
            this.vipMgr = vipMgr;
            this.l3Mgr = l3Mgr;
            this.vmMgr = vmMgr;
            this.existingVip = {};
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreatePortForwardingRule;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = {};
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var vipPage = $scope.vipPage = {
                    activeState: true,
                    method: null,
                    vipUuid: null,
                    l3NetworkUuid: null,
                    vip: null,
                    isVipCreating: false,
                    canCreate: function () {
                        return !Utils.notNullnotUndefined(this.vip) && Utils.notNullnotUndefined(this.l3NetworkUuid) && this.method == CreatePortForwarding.CREATE_NEW_VIP;
                    },
                    create: function () {
                        var _this = this;
                        this.isVipCreating = true;
                        vipMgr.create({
                            name: Utils.shortHashName('vip'),
                            l3NetworkUuid: this.l3NetworkUuid
                        }, function (ret) {
                            _this.vip = ret;
                            _this.isVipCreating = false;
                        });
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return (Utils.notNullnotUndefined(this.vipUuid) && this.vipUuid != "") || Utils.notNullnotUndefined(this.vip);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createPortForwardingVip"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createPortForwardingVip';
                    },
                    hasL3Network: function () {
                        return $scope.l3NetworkListOptions__.dataSource.data().length > 0;
                    },
                    hasVip: function () {
                        return $scope.vipListOptions__.dataSource.data().length > 0;
                    },
                    reset: function () {
                        this.method = CreatePortForwarding.CREATE_NEW_VIP;
                        this.l3NetworkUuid = null;
                        this.vip = null;
                        this.vipUuid = null;
                        this.activeState = false;
                    }
                };
                $scope.vipMethodOptions__ = {
                    dataSource: new kendo.data.DataSource({
                        data: [{
                                name: '{{"portForwarding.ts.Create New VIP" | translate}}',
                                field: CreatePortForwarding.CREATE_NEW_VIP
                            }, {
                                name: '{{"portForwarding.ts.Use Existing VIP" | translate}}',
                                field: CreatePortForwarding.USE_EXISTING_VIP
                            }]
                    }),
                    dataTextField: "name",
                    dataValueField: "field"
                };
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    vipPortStart: null,
                    vipPortEnd: null,
                    privatePortEnd: null,
                    privatePortStart: null,
                    protocolType: null,
                    allowedCidr: null,
                    isVipStartPortValid: function () {
                        if (Utils.notNullnotUndefined(this.vipPortStart)) {
                            return Utils.isValidPort(this.vipPortStart);
                        }
                        return true;
                    },
                    isVipEndPortValid: function () {
                        if (Utils.notNullnotUndefined(this.vipPortEnd)) {
                            return Utils.isValidPort(this.vipPortEnd);
                        }
                        return true;
                    },
                    isGuestStartPortValid: function () {
                        if (Utils.notNullnotUndefined(this.privatePortStart)) {
                            return Utils.isValidPort(this.privatePortStart);
                        }
                        return true;
                    },
                    isGuestEndPortValid: function () {
                        if (Utils.notNullnotUndefined(this.privatePortEnd)) {
                            return Utils.isValidPort(this.privatePortEnd);
                        }
                        return true;
                    },
                    isCIDRValid: function () {
                        if (Utils.notNullnotUndefined(this.allowedCidr) && this.allowedCidr != "") {
                            return Utils.isValidCidr(this.allowedCidr);
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return true;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.vipPortStart) && Utils.notNullnotUndefined(this.vipPortEnd)
                            && Utils.notNullnotUndefined(this.privatePortStart) && Utils.notNullnotUndefined(this.privatePortEnd) && Utils.notNullnotUndefined(this.protocolType)
                            && this.isVipStartPortValid() && this.isVipEndPortValid() && this.isGuestStartPortValid() && this.isGuestEndPortValid() && this.isCIDRValid();
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createPortForwardingInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createPortForwardingInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('pf');
                        this.description = null;
                        this.protocolType = null;
                        this.vipPortStart = null;
                        this.vipPortEnd = null;
                        this.privatePortStart = null;
                        this.privatePortEnd = null;
                        this.allowedCidr = null;
                        this.activeState = false;
                    }
                };
                var attachPage = $scope.attachPage = {
                    activeState: true,
                    vmNic: null,
                    pfRule: null,
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.pfRule);
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#attachVm"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'attachVm';
                    },
                    hasVm: function () {
                        return $scope.vmListOptions__.dataSource.data().length > 0;
                    },
                    beforeMoveToNext: function (done) {
                        var _this = this;
                        var vipUuid = null;
                        if (Utils.notNullnotUndefined($scope.vipPage.vip)) {
                            vipUuid = $scope.vipPage.vip.uuid;
                        }
                        else {
                            vipUuid = $scope.vipPage.vipUuid;
                        }
                        var chain = new Utils.Chain();
                        var vmNics = [];
                        var composedVms = [];
                        chain.then(function () {
                            $scope.infoPage.allowedCidr = $scope.infoPage.allowedCidr == "" ? null : $scope.infoPage.allowedCidr;
                            pfMgr.create({
                                vipUuid: vipUuid,
                                name: $scope.infoPage.name,
                                description: $scope.infoPage.description,
                                vipPortStart: $scope.infoPage.vipPortStart,
                                vipPortEnd: $scope.infoPage.vipPortEnd,
                                privatePortStart: $scope.infoPage.privatePortStart,
                                privatePortEnd: $scope.infoPage.privatePortEnd,
                                allowedCidr: $scope.infoPage.allowedCidr == null ? '0.0.0.0/0' : $scope.infoPage.allowedCidr,
                                protocolType: $scope.infoPage.protocolType
                            }, function (ret) {
                                _this.pfRule = ret;
                                chain.next();
                            });
                        }).then(function () {
                            pfMgr.getAttachableVmNicByPortForwardingUuid(_this.pfRule.uuid, function (ret) {
                                vmNics = ret;
                                chain.next();
                            });
                        }).done(function () {
                            if (vmNics.length == 0) {
                                $scope.vmListOptions__.dataSource.data(composedVms);
                                $scope.attachPage.vmNicUuid = null;
                                done();
                                return;
                            }
                            var nicUuids = [];
                            angular.forEach(vmNics, function (it) {
                                nicUuids.push(it.uuid);
                            });
                            var qobj = new ApiHeader.QueryObject();
                            qobj.conditions = [{
                                    name: 'vmNics.uuid',
                                    op: 'in',
                                    value: nicUuids.join()
                                }];
                            vmMgr.query(qobj, function (vms) {
                                angular.forEach(vms, function (it) {
                                    angular.forEach(it.vmNics, function (nic) {
                                        if (nicUuids.indexOf(nic.uuid) == -1) {
                                            return;
                                        }
                                        composedVms.push({
                                            name: it.name,
                                            uuid: it.uuid,
                                            nicDeviceId: nic.deviceId,
                                            nicIp: nic.ip,
                                            nicNetmask: nic.netmask,
                                            nicGateway: nic.gateway,
                                            nicMac: nic.mac,
                                            l3NetworkUuid: nic.l3NetworkUuid,
                                            nicUuid: nic.uuid
                                        });
                                    });
                                });
                                $scope.vmListOptions__.dataSource.data(composedVms);
                                $scope.attachPage.vmNicUuid = null;
                                done();
                            });
                        }).start();
                    },
                    reset: function () {
                        this.vmNicUuid = null;
                        this.activeState = false;
                        this.pfRule = null;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        if ($scope.vmListOptions__.dataSource.data().length > 0 && Utils.notNullnotUndefinedNotEmptyString($scope.attachPage.vmNicUuid)) {
                            pfMgr.attach($scope.attachPage.pfRule, $scope.attachPage.vmNicUuid, function () {
                                if (Utils.notNullnotUndefined(_this.options.done)) {
                                    _this.options.done($scope.attachPage.pfRule);
                                }
                            });
                        }
                        else {
                            _this.options.done($scope.attachPage.pfRule);
                        }
                        $scope.winCreatePortForwarding__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    vipPage, infoPage, attachPage
                ], mediator);
                $scope.winCreatePortForwardingOptions__ = {
                    width: '700px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.protocolOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [
                            'TCP', 'UDP'
                        ] })
                };
                $scope.vipListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.IP" | translate}}:</span><span>#: ip #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Gateway" | translate}}:</span><span>#: gateway #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Netmask" | translate}}:</span><span>#: netmask #</span></div>'
                };
                $scope.l3NetworkListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Type" | translate}}:</span><span>#: type #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Zone UUID" | translate}}:</span><span>#: zoneUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.L2 Network UUID" | translate}}:</span><span>#: l2NetworkUuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.vmListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "nicUuid",
                    template: '<div style="color: black"><span class="z-label">{{"portForwarding.ts.VM Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.VM UUID" | translate}}:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic DeviceId" | translate}}:</span><span>#: nicDeviceId #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic Ip" | translate}}:</span><span>#: nicIp #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic Netmask" | translate}}:</span><span>#: nicNetmask #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic Gateway" | translate}}:</span><span>#: nicGateway #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic Mac" | translate}}:</span><span>#: nicMac #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.L3 Network UUID" | translate}}:</span><span>#: l3NetworkUuid #</span></div>'
                };
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/portForwarding/createPortForwarding.html';
        }
        CreatePortForwarding.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreatePortForwarding__;
            this.$scope.button.reset();
            var chain = new Utils.Chain();
            this.existingVip = {};
            this.$scope.vipPage.method = CreatePortForwarding.CREATE_NEW_VIP;
            this.$scope.vipPage.isVipCreating = false;
            this.$scope.vipPage.vipUuid = null;
            this.$scope.vipPage.vip = null;
            this.$scope.infoPage.protocolType = 'TCP';
            chain.then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'state',
                        op: '=',
                        value: 'Enabled'
                    }, {
                        name: 'useFor',
                        op: 'is null',
                        value: null
                    }];
                _this.vipMgr.query(qobj, function (ret) {
                    _this.$scope.vipListOptions__.dataSource.data(ret);
                    if (ret.length > 0) {
                        angular.forEach(ret, function (it) {
                            _this.existingVip[it.uuid] = it;
                        });
                        _this.$scope.vipPage.vipUuid = null;
                    }
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'state',
                        op: '=',
                        value: 'Enabled'
                    }, {
                        name: 'useFor',
                        op: '=',
                        value: 'PortForwarding'
                    }];
                _this.vipMgr.query(qobj, function (ret) {
                    if (ret.length > 0) {
                        angular.forEach(ret, function (it) {
                            _this.$scope.vipListOptions__.dataSource.add(it);
                            _this.existingVip[it.uuid] = it;
                        });
                        _this.$scope.vipPage.vipUuid = null;
                    }
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [];
                _this.l3Mgr.query(qobj, function (ret) {
                    _this.$scope.l3NetworkListOptions__.dataSource.data(ret);
                    if (ret.length > 0) {
                        _this.$scope.vipPage.l3NetworkUuid = ret[0].uuid;
                    }
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        CreatePortForwarding.USE_EXISTING_VIP = "existing";
        CreatePortForwarding.CREATE_NEW_VIP = "new";
        return CreatePortForwarding;
    })();
    MPortForwarding.CreatePortForwarding = CreatePortForwarding;
    var AttachPortForwarding = (function () {
        function AttachPortForwarding(pfMgr, vmMgr) {
            var _this = this;
            this.pfMgr = pfMgr;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/portForwarding/attachPortForwarding.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zPortForwardingAttachVm] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.vmListOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "nicUuid",
                    template: '<div style="color: black"><span class="z-label">{{"portForwarding.ts.VM Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.VM UUID" | translate}}:</span><span>#: uuid #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic DeviceId" | translate}}:</span><span>#: nicDeviceId #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic Ip" | translate}}:</span><span>#: nicIp #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic Netmask" | translate}}:</span><span>#: nicNetmask #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic Gateway" | translate}}:</span><span>#: nicGateway #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"portForwarding.ts.Nic Mac" | translate}}:</span><span>#: nicMac #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{{{"portForwarding.ts.L3 Network UUID" | translate}}:</span><span>#: l3NetworkUuid #</span></div>'
                };
                $scope.hasVm = function () {
                    return $scope.vmListOptions__.dataSource.data().length > 0;
                };
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.vmNicUuid);
                };
                $scope.cancel = function () {
                    $scope.attachPortForwarding__.close();
                };
                $scope.done = function () {
                    pfMgr.attach(_this.options.pf, $scope.vmNicUuid, function () {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done();
                        }
                    });
                    $scope.attachPortForwarding__.close();
                };
                _this.$scope = $scope;
                $scope.attachPortForwardingOptions__ = {
                    width: '550px'
                };
            };
        }
        AttachPortForwarding.prototype.open = function () {
            var _this = this;
            this.$scope.vmListOptions__.dataSource.data([]);
            var chain = new Utils.Chain();
            var vmNics = [];
            var composedVms = [];
            chain.then(function () {
                _this.pfMgr.getAttachableVmNicByPortForwardingUuid(_this.options.pf.uuid, function (nics) {
                    vmNics = nics;
                    chain.next();
                });
            }).then(function () {
                if (vmNics.length == 0) {
                    _this.$scope.vmListOptions__.dataSource.data(composedVms);
                    _this.$scope.vmNicUuid = null;
                    chain.next();
                    return;
                }
                var nicUuids = [];
                angular.forEach(vmNics, function (it) {
                    nicUuids.push(it.uuid);
                });
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [{
                        name: 'vmNics.uuid',
                        op: 'in',
                        value: nicUuids.join()
                    }];
                _this.vmMgr.query(qobj, function (vms) {
                    angular.forEach(vms, function (it) {
                        angular.forEach(it.vmNics, function (nic) {
                            if (nicUuids.indexOf(nic.uuid) == -1) {
                                return;
                            }
                            composedVms.push({
                                name: it.name,
                                uuid: it.uuid,
                                nicDeviceId: nic.deviceId,
                                nicIp: nic.ip,
                                nicNetmask: nic.netmask,
                                nicGateway: nic.gateway,
                                nicMac: nic.mac,
                                l3NetworkUuid: nic.l3NetworkUuid,
                                nicUuid: nic.uuid
                            });
                        });
                    });
                    _this.$scope.vmListOptions__.dataSource.data(composedVms);
                    if (composedVms.length > 0) {
                        _this.$scope.vmNicUuid = composedVms[0].nicUuid;
                    }
                    chain.next();
                });
            }).done(function () {
                _this.$scope.attachPortForwarding__.center();
                _this.$scope.attachPortForwarding__.open();
            }).start();
        };
        return AttachPortForwarding;
    })();
    MPortForwarding.AttachPortForwarding = AttachPortForwarding;
    var DetachPortForwarding = (function () {
        function DetachPortForwarding(pfMgr, vmMgr) {
            var _this = this;
            this.pfMgr = pfMgr;
            this.vmMgr = vmMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/portForwarding/detachPortForwarding.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zPortForwardingDetachVm] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.cancel = function () {
                    $scope.detachPortForwarding__.close();
                };
                $scope.done = function () {
                    pfMgr.detach(_this.options.pf, function () {
                        if (_this.options.done) {
                            _this.options.done();
                        }
                    });
                    $scope.detachPortForwarding__.close();
                };
                $scope.optionsDetachPortForwarding__ = {
                    width: '500px'
                };
                $scope.vmStateLabel = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return '';
                    }
                    var vm = $scope.vm;
                    if (vm.state == 'Running') {
                        return 'label label-success';
                    }
                    else if (vm.state == 'Stopped') {
                        return 'label label-danger';
                    }
                    else if (vm.state == 'Unknown') {
                        return 'label label-warning';
                    }
                    else {
                        return 'label label-default';
                    }
                };
                $scope.isVmInCorrectState = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return true;
                    }
                    return $scope.vm.state == 'Running' || $scope.vm.state == 'Stopped';
                };
                $scope.canProceed = function () {
                    if (!Utils.notNullnotUndefined($scope.vm)) {
                        return false;
                    }
                    return $scope.isVmInCorrectState();
                };
                _this.$scope = $scope;
            };
        }
        DetachPortForwarding.prototype.open = function () {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            this.$scope.pf = this.options.pf;
            qobj.conditions = [
                {
                    name: 'vmNics.uuid',
                    op: '=',
                    value: this.options.pf.vmNicUuid
                }
            ];
            this.vmMgr.query(qobj, function (vms) {
                if (vms.length > 0) {
                    var vm = vms[0];
                    _this.$scope.vm = vm;
                    angular.forEach(vm.vmNics, function (it) {
                        _this.$scope.vm['nicDeviceId'] = it.deviceId;
                        _this.$scope.vm['nicMac'] = it.mac;
                        _this.$scope.vm['nicIp'] = it.ip;
                        _this.$scope.vm['nicNetmask'] = it.netmask;
                        _this.$scope.vm['nicGateway'] = it.gateway;
                    });
                }
                _this.$scope.detachPortForwarding__.center();
                _this.$scope.detachPortForwarding__.open();
            });
        };
        return DetachPortForwarding;
    })();
    MPortForwarding.DetachPortForwarding = DetachPortForwarding;
})(MPortForwarding || (MPortForwarding = {}));
angular.module('root').factory('PortForwardingManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MPortForwarding.PortForwardingManager(api, $rootScope);
    }]).directive('zCreatePortForwardingRule', ['Api', 'PortForwardingManager', 'VipManager', 'L3NetworkManager', 'VmInstanceManager', function (api, pfMgr, vipMgr, l3Mgr, vmMgr) {
        return new MPortForwarding.CreatePortForwarding(api, pfMgr, vipMgr, l3Mgr, vmMgr);
    }]).directive('zPortForwardingAttachVm', ['PortForwardingManager', 'VmInstanceManager', function (pfMgr, vmMgr) {
        return new MPortForwarding.AttachPortForwarding(pfMgr, vmMgr);
    }]).directive('zPortForwardingDetachVm', ['PortForwardingManager', 'VmInstanceManager', function (pfMgr, vmMgr) {
        return new MPortForwarding.DetachPortForwarding(pfMgr, vmMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/portForwarding', {
            templateUrl: '/static/templates/portForwarding/portForwarding.html',
            controller: 'MPortForwarding.Controller'
        }).when('/portForwarding/:uuid', {
            templateUrl: '/static/templates/portForwarding/details.html',
            controller: 'MPortForwarding.DetailsController',
            resolve: {
                current: function ($q, $route, PortForwardingManager, VmInstanceManager, VipManager) {
                    var defer = $q.defer();
                    var uuid = $route.current.params.uuid;
                    var ret = {
                        pf: null,
                        nic: null,
                        vip: null
                    };
                    var chain = new Utils.Chain();
                    chain.then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                        PortForwardingManager.query(qobj, function (pfs) {
                            ret.pf = pfs[0];
                            chain.next();
                        });
                    }).then(function () {
                        if (!Utils.notNullnotUndefined(ret.pf.vmNicUuid)) {
                            chain.next();
                            return;
                        }
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [{
                                name: 'uuid',
                                op: '=',
                                value: ret.pf.vmNicUuid
                            }];
                        VmInstanceManager.queryVmNic(qobj, function (nics) {
                            ret.nic = nics[0];
                            chain.next();
                        });
                    }).then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [{
                                name: 'uuid',
                                op: '=',
                                value: ret.pf.vipUuid
                            }];
                        VipManager.query(qobj, function (vips) {
                            ret.vip = vips[0];
                            chain.next();
                        });
                    }).done(function () {
                        defer.resolve(ret);
                    }).start();
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MVirtualRouter;
(function (MVirtualRouter) {
    var VmNic = (function (_super) {
        __extends(VmNic, _super);
        function VmNic() {
            _super.apply(this, arguments);
        }
        VmNic.prototype.progressOn = function () {
            this.inProgress = true;
        };
        VmNic.prototype.progressOff = function () {
            this.inProgress = false;
        };
        VmNic.prototype.isInProgress = function () {
            return this.inProgress;
        };
        VmNic.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('vmInstanceUuid', inv.vmInstanceUuid);
            self.set('l3NetworkUuid', inv.l3NetworkUuid);
            self.set('ip', inv.ip);
            self.set('mac', inv.mac);
            self.set('netmask', inv.netmask);
            self.set('gateway', inv.gateway);
            self.set('metaData', inv.metaData);
            self.set('deviceId', inv.deviceId);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        return VmNic;
    })(ApiHeader.VmNicInventory);
    MVirtualRouter.VmNic = VmNic;
    var VirtualRouter = (function (_super) {
        __extends(VirtualRouter, _super);
        function VirtualRouter() {
            _super.apply(this, arguments);
        }
        VirtualRouter.prototype.progressOn = function () {
            this.inProgress = true;
        };
        VirtualRouter.prototype.progressOff = function () {
            this.inProgress = false;
        };
        VirtualRouter.prototype.isInProgress = function () {
            return this.inProgress;
        };
        VirtualRouter.prototype.stateLabel = function () {
            if (this.state == 'Running') {
                return 'label label-success';
            }
            else if (this.state == 'Stopped') {
                return 'label label-danger';
            }
            else if (this.state == 'Unknown') {
                return 'label label-warning';
            }
            else {
                return 'label label-default';
            }
        };
        VirtualRouter.prototype.statusLabel = function () {
            if (this.status == 'Connected') {
                return 'label label-success';
            }
            else if (this.status == 'Disconnected') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        VirtualRouter.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('zoneUuid', inv.zoneUuid);
            self.set('clusterUuid', inv.clusterUuid);
            self.set('hypervisorType', inv.hypervisorType);
            self.set('state', inv.state);
            self.set('status', inv.status);
            self.set('hostUuid', inv.hostUuid);
            self.set('lastHostUuid', inv.lastHostUuid);
            self.set('rootVolumeUuid', inv.rootVolumeUuid);
            self.set('vmNics', inv.vmNics);
            self.set('type', inv.type);
            self.set('imageUuid', inv.imageUuid);
            self.set('allVolumes', inv.allVolumes);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
        };
        VirtualRouter.STATES = ['Running', 'Starting', 'Stopping', 'Stopped', 'Rebooting', 'Migrating', 'Unknown', 'Created'];
        return VirtualRouter;
    })(ApiHeader.ApplianceVmInventory);
    MVirtualRouter.VirtualRouter = VirtualRouter;
    var VirtualRouterManager = (function () {
        function VirtualRouterManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        VirtualRouterManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        VirtualRouterManager.prototype.wrap = function (obj) {
            return new kendo.data.ObservableObject(obj);
        };
        VirtualRouterManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryApplianceVmMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            msg.conditions.push({
                name: "applianceVmType",
                op: "=",
                value: "VirtualRouter"
            });
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new VirtualRouter();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        VirtualRouterManager.prototype.getConsole = function (vm, done) {
            var msg = new ApiHeader.APIRequestConsoleAccessMsg();
            msg.vmInstanceUuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                done(ret.inventory);
            });
        };
        VirtualRouterManager.prototype.stop = function (vm) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Stopping';
            var msg = new ApiHeader.APIStopVmInstanceMsg();
            msg.uuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Stopped virtual router: {0}', vm.name),
                    link: Utils.sprintf('/#/virtualRouter/{0}', vm.uuid)
                });
            });
        };
        VirtualRouterManager.prototype.start = function (vm) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Starting';
            var msg = new ApiHeader.APIStartVmInstanceMsg();
            msg.uuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Started virtual router: {0}', vm.name),
                    link: Utils.sprintf('/#/virtualRouter/{0}', vm.uuid)
                });
            });
        };
        VirtualRouterManager.prototype.reboot = function (vm) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Rebooting';
            var msg = new ApiHeader.APIRebootVmInstanceMsg();
            msg.uuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Rebooted virtual router: {0}', vm.name),
                    link: Utils.sprintf('/#/virtualRouter/{0}', vm.uuid)
                });
            }, function () {
                vm.progressOff();
            });
        };
        VirtualRouterManager.prototype.delete = function (vm, done) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Destroying';
            var msg = new ApiHeader.APIDestroyVmInstanceMsg();
            msg.uuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted virtual router: {0}', vm.name)
                });
            });
        };
        VirtualRouterManager.prototype.migrate = function (vm, hostUuid, done) {
            var _this = this;
            vm.progressOn();
            vm.state = 'Migrating';
            var msg = new ApiHeader.APIMigrateVmMsg();
            msg.hostUuid = hostUuid;
            msg.vmInstanceUuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Migrated virtual router: {0}', vm.name),
                    link: Utils.sprintf('/#/virtualRouter/{0}', vm.uuid)
                });
            });
        };
        VirtualRouterManager.prototype.reconnect = function (vm, done) {
            var _this = this;
            vm.progressOn();
            vm.status = 'Connecting';
            var msg = new ApiHeader.APIReconnectVirtualRouterMsg();
            msg.vmInstanceUuid = vm.uuid;
            this.api.asyncApi(msg, function (ret) {
                vm.updateObservableObject(ret.inventory);
                vm.progressOff();
                if (Utils.notNullnotUndefined(done)) {
                    done();
                }
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Reconnected virtual router: {0}', vm.name),
                    link: Utils.sprintf('/#/virtualRouter/{0}', vm.uuid)
                });
            });
        };
        VirtualRouterManager.$inject = ['Api', '$rootScope'];
        return VirtualRouterManager;
    })();
    MVirtualRouter.VirtualRouterManager = VirtualRouterManager;
    var VirtualRouterModel = (function (_super) {
        __extends(VirtualRouterModel, _super);
        function VirtualRouterModel() {
            _super.call(this);
            this.current = new VirtualRouter();
        }
        return VirtualRouterModel;
    })(Utils.Model);
    MVirtualRouter.VirtualRouterModel = VirtualRouterModel;
    var OVirtualRouterGrid = (function (_super) {
        __extends(OVirtualRouterGrid, _super);
        function OVirtualRouterGrid($scope, vmMgr) {
            _super.call(this);
            this.vmMgr = vmMgr;
            _super.prototype.init.call(this, $scope, $scope.vmGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"virtualRouter.ts.NAME" | translate}}',
                    width: '20%',
                    template: '<a href="/\\#/vmInstance/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"virtualRouter.ts.DESCRIPTION" | translate}}',
                    width: '20%'
                },
                {
                    field: 'hypervisorType',
                    title: '{{"virtualRouter.ts.HYPERVISOR" | translate}}',
                    width: '20%'
                },
                {
                    field: 'state',
                    title: '{{"virtualRouter.ts.STATE" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'status',
                    title: '{{"virtualRouter.ts.STATUS" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.statusLabel()}}">{{dataItem.status}}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"virtualRouter.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                vmMgr.query(qobj, function (vms, total) {
                    options.success({
                        data: vms,
                        total: total
                    });
                });
            };
        }
        return OVirtualRouterGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, vmMgr) {
            this.$scope = $scope;
            this.vmMgr = vmMgr;
        }
        Action.prototype.start = function () {
            this.vmMgr.start(this.$scope.model.current);
        };
        Action.prototype.stop = function () {
            this.vmMgr.stop(this.$scope.model.current);
        };
        Action.prototype.reboot = function () {
            this.vmMgr.reboot(this.$scope.model.current);
        };
        Action.prototype.migrate = function () {
            this.$scope.migrateVm.open();
        };
        Action.prototype.delete = function () {
            this.$scope.deleteVirtualRouter.open();
        };
        Action.prototype.reconnect = function () {
            this.$scope.reconnectVirtualRouter.open();
        };
        Action.prototype.console = function () {
            this.$scope.console();
        };
        Action.prototype.isActionShow = function (action) {
            if (!Utils.notNullnotUndefined(this.$scope.model.current) || Utils.isEmptyObject(this.$scope.model.current)) {
                return false;
            }
            if (action == 'start') {
                return this.$scope.model.current.state == 'Stopped';
            }
            else if (action == 'stop') {
                return this.$scope.model.current.state == 'Running';
            }
            else if (action == 'reboot') {
                return this.$scope.model.current.state == 'Running';
            }
            else if (action == 'migrate') {
                return this.$scope.model.current.state == 'Running';
            }
            else if (action == 'reconnect') {
                return this.$scope.model.current.state == 'Running';
            }
            else if (action == 'console' && Utils.notNullnotUndefined(this.$scope.model.current)) {
                return this.$scope.model.current.state == 'Starting' || this.$scope.model.current.state == 'Running' || this.$scope.model.current.state == 'Rebooting' || this.$scope.model.current.state == 'Stopping';
            }
            else {
                return false;
            }
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, hypervisorTypes) {
            var _this = this;
            this.$scope = $scope;
            this.hypervisorTypes = hypervisorTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"virtualRouter.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"virtualRouter.ts.State" | translate}}',
                            value: FilterBy.STATE
                        },
                        {
                            name: '{{"virtualRouter.ts.HypervisorType" | translate}}',
                            value: FilterBy.TYPE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(VirtualRouter.STATES);
                }
                else if (_this.field == FilterBy.TYPE) {
                    _this.valueList.dataSource.data(_this.hypervisorTypes);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oVirtualRouterGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        FilterBy.TYPE = 'hypervisorType';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, vmMgr, $routeParams, tagService, current, clusterMgr, $rootScope, $window) {
            var _this = this;
            this.$scope = $scope;
            this.vmMgr = vmMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            this.$rootScope = $rootScope;
            this.$window = $window;
            $scope.model = new VirtualRouterModel();
            $scope.model.current = current;
            $scope.console = function () {
                var current = $scope.model.current;
                vmMgr.getConsole(current, function (inv) {
                    var windowName = current.name + current.uuid;
                    $window.open(Utils.sprintf('/static/templates/console/vnc_auto.html?host={0}&port={1}&token={2}', inv.hostname, inv.port, inv.token), windowName);
                });
            };
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, vmMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteVirtualRouter = {
                title: 'DELETE VIRTUAL ROUTER',
                confirm: function () {
                    vmMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeApplianceVmVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
            $scope.optionsMigrateVm = {
                vm: current
            };
            $scope.optionsNicGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'deviceId',
                        title: '{{"virtualRouter.ts.DEVICE ID" | translate}}',
                        width: '4%'
                    },
                    {
                        field: 'l3NetworkUuid',
                        title: '{{"virtualRouter.ts.L3 Network" | translate}}',
                        width: '20%',
                        template: '<a href="/\\#/l3Network/{{dataItem.l3NetworkUuid}}">{{dataItem.l3NetworkUuid}}</a>'
                    },
                    {
                        field: 'ip',
                        title: '{{"virtualRouter.ts.IP" | translate}}',
                        width: '14%'
                    },
                    {
                        field: 'netmask',
                        title: '{{"virtualRouter.ts.NETMASK" | translate}}',
                        width: '14%'
                    },
                    {
                        field: 'gateway',
                        title: '{{"virtualRouter.ts.GATEWAY" | translate}}',
                        width: '14%'
                    },
                    {
                        field: 'mac',
                        title: '{{"virtualRouter.ts.MAC" | translate}}',
                        width: '14%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"virtualRouter.ts.UUID" | translate}}',
                        width: '20%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    data: current.vmNics
                })
            };
            $scope.optionsVolumeGrid = {
                pageSize: 20,
                resizable: true,
                scrollable: true,
                pageable: true,
                columns: [
                    {
                        field: 'deviceId',
                        title: '{{"virtualRouter.ts.DEVICE ID" | translate}}',
                        width: '10%',
                        template: '<a href="/\\#/volume/{{dataItem.uuid}}">{{dataItem.deviceId}}</a>'
                    },
                    {
                        field: 'name',
                        title: '{{"virtualRouter.ts.NAME" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'type',
                        title: '{{"virtualRouter.ts.TYPE" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'state',
                        title: '{{"virtualRouter.ts.STATE" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'status',
                        title: '{{"virtualRouter.ts.STATUS" | translate}}',
                        width: '18%'
                    },
                    {
                        field: 'uuid',
                        title: '{{"virtualRouter.ts.UUID" | translate}}',
                        width: '18%'
                    }
                ],
                dataBound: function (e) {
                    var grid = e.sender;
                    if (grid.dataSource.totalPages() == 1) {
                        grid.pager.element.hide();
                    }
                },
                dataSource: new kendo.data.DataSource({
                    data: current.allVolumes
                })
            };
            $scope.optionsReconnectVirtualRouter = {
                title: '{{"virtualRouter.ts.RECONNECT VIRTUAL ROUTER" | translate}}',
                btnType: 'btn-primary',
                width: '350px',
                description: function () {
                    return "Reconnect agent on virtual router: " + current.name;
                },
                confirm: function () {
                    vmMgr.reconnect($scope.model.current, function () {
                        $scope.model.resetCurrent();
                    });
                }
            };
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.vmMgr.query(qobj, function (vms, total) {
                _this.$scope.model.current = vms[0];
            });
        };
        DetailsController.$inject = ['$scope', 'VirtualRouterManager', '$routeParams', 'Tag', 'current', 'ClusterManager', '$rootScope', '$window'];
        return DetailsController;
    })();
    MVirtualRouter.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, vmMgr, hypervisorTypes, $location, $rootScope, $window) {
            this.$scope = $scope;
            this.vmMgr = vmMgr;
            this.hypervisorTypes = hypervisorTypes;
            this.$location = $location;
            this.$rootScope = $rootScope;
            this.$window = $window;
            $scope.model = new VirtualRouterModel();
            $scope.oVirtualRouterGrid = new OVirtualRouterGrid($scope, vmMgr);
            $scope.action = new Action($scope, vmMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"virtualRouter.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"virtualRouter.ts.Description" | translate}}',
                        value: 'Description'
                    },
                    {
                        name: '{{"virtualRouter.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"virtualRouter.ts.Hypervisor" | translate}}',
                        value: 'hypervisorType'
                    },
                    {
                        name: '{{"virtualRouter.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"virtualRouter.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    vmMgr.setSortBy(ret);
                    $scope.oVirtualRouterGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.ApplianceVmInventoryQueryable,
                name: 'VirtualRouter',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: VirtualRouter.STATES
                    },
                    hypervisorType: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: this.hypervisorTypes
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    vmMgr.query(qobj, function (VirtualRouters, total) {
                        $scope.oVirtualRouterGrid.refresh(VirtualRouters);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/virtualRouter/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.hypervisorTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateVirtualRouter = function (win) {
                win.open();
            };
            $scope.funcDeleteVirtualRouter = function () {
                $scope.deleteVirtualRouter.open();
            };
            $scope.optionsDeleteVirtualRouter = {
                title: 'DELETE VIRTUAL ROUTER',
                confirm: function () {
                    vmMgr.delete($scope.model.current, function (ret) {
                        $scope.oVirtualRouterGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oVirtualRouterGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateVirtualRouter = {
                done: function (vm) {
                    $scope.oVirtualRouterGrid.add(vm);
                }
            };
            $scope.optionsMigrateVm = {
                vm: null
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    $scope.optionsMigrateVm.vm = $scope.model.current;
                }
            });
            $scope.optionsReconnectVirtualRouter = {
                title: 'RECONNECT VIRTUAL ROUTER',
                btnType: 'btn-primary',
                width: '350px',
                description: function () {
                    return "Reconnect agent on virtual router: " + $scope.model.current.name;
                },
                confirm: function () {
                    vmMgr.reconnect($scope.model.current, function () {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.console = function () {
                var current = $scope.model.current;
                vmMgr.getConsole(current, function (inv) {
                    var windowName = current.name + current.uuid;
                    $window.open(Utils.sprintf('/static/templates/console/vnc_auto.html?host={0}&port={1}&token={2}', inv.hostname, inv.port, inv.token), windowName);
                });
            };
        }
        Controller.$inject = ['$scope', 'VirtualRouterManager', 'hypervisorTypes', '$location', '$rootScope', '$window'];
        return Controller;
    })();
    MVirtualRouter.Controller = Controller;
})(MVirtualRouter || (MVirtualRouter = {}));
angular.module('root').factory('VirtualRouterManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MVirtualRouter.VirtualRouterManager(api, $rootScope);
    }]).config(['$routeProvider', function (route) {
        route.when('/virtualRouter', {
            templateUrl: '/static/templates/virtualRouter/virtualRouter.html',
            controller: 'MVirtualRouter.Controller',
            resolve: {
                hypervisorTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getHypervisorTypes(function (hypervisorTypes) {
                        defer.resolve(hypervisorTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/virtualRouter/:uuid', {
            templateUrl: '/static/templates/virtualRouter/details.html',
            controller: 'MVirtualRouter.DetailsController',
            resolve: {
                current: function ($q, $route, VirtualRouterManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var uuid = $route.current.params.uuid;
                    qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                    VirtualRouterManager.query(qobj, function (vms) {
                        var vm = vms[0];
                        defer.resolve(vm);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MVirtualRouterOffering;
(function (MVirtualRouterOffering) {
    var VirtualRouterOffering = (function (_super) {
        __extends(VirtualRouterOffering, _super);
        function VirtualRouterOffering() {
            _super.apply(this, arguments);
        }
        VirtualRouterOffering.prototype.progressOn = function () {
            this.inProgress = true;
        };
        VirtualRouterOffering.prototype.progressOff = function () {
            this.inProgress = false;
        };
        VirtualRouterOffering.prototype.isInProgress = function () {
            return this.inProgress;
        };
        VirtualRouterOffering.prototype.isEnableShow = function () {
            return this.state == 'Disabled';
        };
        VirtualRouterOffering.prototype.isDisableShow = function () {
            return this.state == 'Enabled';
        };
        VirtualRouterOffering.prototype.stateLabel = function () {
            if (this.state == 'Enabled') {
                return 'label label-success';
            }
            else if (this.state == 'Disabled') {
                return 'label label-danger';
            }
            else {
                return 'label label-default';
            }
        };
        VirtualRouterOffering.prototype.isDefaultLabel = function () {
            if (this.isDefault) {
                return 'label label-primary';
            }
            return null;
        };
        VirtualRouterOffering.prototype.updateObservableObject = function (inv) {
            // self : ObservableObject
            var self = this;
            self.set('uuid', inv.uuid);
            self.set('name', inv.name);
            self.set('description', inv.description);
            self.set('state', inv.state);
            self.set('cpuNum', inv.cpuNum);
            self.set('cpuSpeed', inv.cpuSpeed);
            self.set('memorySize', inv.memorySize);
            self.set('allocatorStrategy', inv.allocatorStrategy);
            self.set('createDate', inv.createDate);
            self.set('lastOpDate', inv.lastOpDate);
            self.set('publicNetworkUuid', inv.publicNetworkUuid);
            self.set('managementL3NetworkUuid', inv.managementNetworkUuid);
            self.set('zoneUuid', inv.zoneUuid);
            self.set('isDefault', inv.isDefault);
            self.set('imageUuid', inv.imageUuid);
        };
        return VirtualRouterOffering;
    })(ApiHeader.VirtualRouterOfferingInventory);
    MVirtualRouterOffering.VirtualRouterOffering = VirtualRouterOffering;
    var VirtualRouterOfferingManager = (function () {
        function VirtualRouterOfferingManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        VirtualRouterOfferingManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        VirtualRouterOfferingManager.prototype.wrap = function (VirtualRouterOffering) {
            return new kendo.data.ObservableObject(VirtualRouterOffering);
        };
        VirtualRouterOfferingManager.prototype.create = function (virtualRouterOffering, done) {
            var _this = this;
            var msg = new ApiHeader.APICreateVirtualRouterOfferingMsg();
            msg.name = virtualRouterOffering.name;
            msg.description = virtualRouterOffering.description;
            msg.cpuNum = virtualRouterOffering.cpuNum;
            msg.cpuSpeed = virtualRouterOffering.cpuSpeed;
            msg.memorySize = virtualRouterOffering.memorySize;
            msg.allocatorStrategy = virtualRouterOffering.allocatorStrategy;
            msg.managementNetworkUuid = virtualRouterOffering.managementNetworkUuid;
            msg.publicNetworkUuid = virtualRouterOffering.publicNetworkUuid;
            msg.zoneUuid = virtualRouterOffering.zoneUuid;
            msg.isDefault = virtualRouterOffering.isDefault;
            msg.imageUuid = virtualRouterOffering.imageUuid;
            this.api.asyncApi(msg, function (ret) {
                var c = new VirtualRouterOffering();
                angular.extend(c, ret.inventory);
                done(_this.wrap(c));
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Added new virtual router offering: {0}', c.name),
                    link: Utils.sprintf('/#/virtualRouterOffering/{0}', c.uuid)
                });
            });
        };
        VirtualRouterOfferingManager.prototype.query = function (qobj, callback) {
            var _this = this;
            var msg = new ApiHeader.APIQueryVirtualRouterOfferingMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            msg.conditions.push({
                name: "type",
                op: "=",
                value: "VirtualRouterOffering"
            });
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                var pris = [];
                ret.inventories.forEach(function (inv) {
                    var c = new VirtualRouterOffering();
                    angular.extend(c, inv);
                    pris.push(_this.wrap(c));
                });
                callback(pris, ret.total);
            });
        };
        VirtualRouterOfferingManager.prototype.disable = function (virtualRouterOffering) {
            var _this = this;
            virtualRouterOffering.progressOn();
            var msg = new ApiHeader.APIChangeInstanceOfferingStateMsg();
            msg.stateEvent = 'disable';
            msg.uuid = virtualRouterOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                virtualRouterOffering.updateObservableObject(ret.inventory);
                virtualRouterOffering.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Disabled Instance Offering: {0}', virtualRouterOffering.name),
                    link: Utils.sprintf('/#/virtualRouterOffering/{0}', virtualRouterOffering.uuid)
                });
            });
        };
        VirtualRouterOfferingManager.prototype.enable = function (virtualRouterOffering) {
            var _this = this;
            virtualRouterOffering.progressOn();
            var msg = new ApiHeader.APIChangeInstanceOfferingStateMsg();
            msg.stateEvent = 'enable';
            msg.uuid = virtualRouterOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                virtualRouterOffering.updateObservableObject(ret.inventory);
                virtualRouterOffering.progressOff();
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Enabled virtual router offering: {0}', virtualRouterOffering.name),
                    link: Utils.sprintf('/#/virtualRouterOffering/{0}', virtualRouterOffering.uuid)
                });
            });
        };
        VirtualRouterOfferingManager.prototype.delete = function (virtualRouterOffering, done) {
            var _this = this;
            virtualRouterOffering.progressOn();
            var msg = new ApiHeader.APIDeleteInstanceOfferingMsg();
            msg.uuid = virtualRouterOffering.uuid;
            this.api.asyncApi(msg, function (ret) {
                virtualRouterOffering.progressOff();
                done(ret);
                _this.$rootScope.$broadcast(MRoot.Events.NOTIFICATION, {
                    msg: Utils.sprintf('Deleted virtual router offering: {0}', virtualRouterOffering.name)
                });
            });
        };
        VirtualRouterOfferingManager.$inject = ['Api', '$rootScope'];
        return VirtualRouterOfferingManager;
    })();
    MVirtualRouterOffering.VirtualRouterOfferingManager = VirtualRouterOfferingManager;
    var VirtualRouterOfferingModel = (function (_super) {
        __extends(VirtualRouterOfferingModel, _super);
        function VirtualRouterOfferingModel() {
            _super.call(this);
            this.current = new VirtualRouterOffering();
        }
        return VirtualRouterOfferingModel;
    })(Utils.Model);
    MVirtualRouterOffering.VirtualRouterOfferingModel = VirtualRouterOfferingModel;
    var OVirtualRouterOfferingGrid = (function (_super) {
        __extends(OVirtualRouterOfferingGrid, _super);
        function OVirtualRouterOfferingGrid($scope, virtualRouterOfferingMgr) {
            _super.call(this);
            this.virtualRouterOfferingMgr = virtualRouterOfferingMgr;
            _super.prototype.init.call(this, $scope, $scope.virtualRouterOfferingGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"virtualRouterOffering.ts.NAME" | translate}}',
                    width: '10%',
                    template: '<a href="/\\#/virtualRouterOffering/{{dataItem.uuid}}">{{dataItem.name}}</a>'
                },
                {
                    field: 'description',
                    title: '{{"virtualRouterOffering.ts.DESCRIPTION" | translate}}',
                    width: '15%'
                },
                {
                    field: 'cpuNum',
                    title: '{{"virtualRouterOffering.ts.CPU NUMBER" | translate}}',
                    width: '10%'
                },
                {
                    field: 'cpuSpeed',
                    title: '{{"virtualRouterOffering.ts.CPU SPEED" | translate}}',
                    width: '10%'
                },
                {
                    field: 'memorySize',
                    title: '{{"virtualRouterOffering.ts.MEMORY" | translate}}',
                    width: '15%',
                    template: '<span>{{dataItem.memorySize | size}}</span>'
                },
                {
                    field: 'state',
                    title: '{{"virtualRouterOffering.ts.STATE" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.stateLabel()}}">{{dataItem.state}}</span>'
                },
                {
                    field: 'isDefault',
                    title: '{{"virtualRouterOffering.ts.DEFAULT OFFERING" | translate}}',
                    width: '10%',
                    template: '<span class="{{dataItem.isDefaultLabel()}}">{{dataItem.isDefault ? "TRUE" : "" }}</span>'
                },
                {
                    field: 'uuid',
                    title: '{{"virtualRouterOffering.ts.UUID" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                virtualRouterOfferingMgr.query(qobj, function (virtualRouterOfferings, total) {
                    options.success({
                        data: virtualRouterOfferings,
                        total: total
                    });
                });
            };
        }
        return OVirtualRouterOfferingGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, virtualRouterOfferingMgr) {
            this.$scope = $scope;
            this.virtualRouterOfferingMgr = virtualRouterOfferingMgr;
        }
        Action.prototype.enable = function () {
            this.virtualRouterOfferingMgr.enable(this.$scope.model.current);
        };
        Action.prototype.disable = function () {
            this.virtualRouterOfferingMgr.disable(this.$scope.model.current);
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, hypervisorTypes) {
            var _this = this;
            this.$scope = $scope;
            this.hypervisorTypes = hypervisorTypes;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"virtualRouterOffering.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"virtualRouterOffering.ts.State" | translate}}',
                            value: FilterBy.STATE
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.field == FilterBy.NONE) {
                    _this.valueList.dataSource.data([]);
                    _this.value = null;
                }
                else if (_this.field == FilterBy.STATE) {
                    _this.valueList.dataSource.data(['Enabled', 'Disabled']);
                }
            });
        }
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oVirtualRouterOfferingGrid.setFilter(this.toKendoFilter());
            this.name = !Utils.notNullnotUndefined(this.value) ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (!Utils.notNullnotUndefined(this.value)) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.STATE = 'state';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, virtualRouterOfferingMgr, $routeParams, tagService, current) {
            var _this = this;
            this.$scope = $scope;
            this.virtualRouterOfferingMgr = virtualRouterOfferingMgr;
            this.$routeParams = $routeParams;
            this.tagService = tagService;
            $scope.model = new VirtualRouterOfferingModel();
            $scope.model.current = current.offering;
            $scope.mgmtL3 = current.mgmtL3;
            $scope.pubL3 = current.pubL3;
            $scope.funcDelete = function (win) {
                win.open();
            };
            $scope.action = new Action($scope, virtualRouterOfferingMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current.uuid);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.optionsDeleteVirtualRouterOffering = {
                title: 'DELETE VIRTUAL ROUTER OFFERING',
                btnType: 'btn-danger',
                description: function () {
                    return $scope.model.current.name;
                },
                width: '400px',
                confirm: function () {
                    virtualRouterOfferingMgr.delete($scope.model.current, function (ret) {
                        $scope.model.resetCurrent();
                    });
                }
            };
            $scope.optionsTag = {
                tags: [],
                createTag: function (item) {
                    _this.tagService.createTag(item.tag, $scope.model.current.uuid, ApiHeader.TagResourceTypeVirtualRouterOfferingVO, function (ret) {
                        angular.forEach($scope.optionsTag.tags, function (it) {
                            if (it.tag === item.tag) {
                                angular.extend(it, ret);
                            }
                        });
                    });
                },
                deleteTag: function (item) {
                    _this.tagService.deleteTag(item.uuid);
                },
                isShow: function () {
                    return Utils.notNullnotUndefined($scope.model.current);
                }
            };
            this.tagService.queryTag($scope.model.current.uuid, function (tags) {
                $scope.optionsTag.tags = tags;
            });
        }
        DetailsController.prototype.loadSelf = function (uuid) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
            this.virtualRouterOfferingMgr.query(qobj, function (virtualRouterOfferings, total) {
                _this.$scope.model.current = virtualRouterOfferings[0];
            });
        };
        DetailsController.$inject = ['$scope', 'VirtualRouterOfferingManager', '$routeParams', 'Tag', 'current'];
        return DetailsController;
    })();
    MVirtualRouterOffering.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, virtualRouterOfferingMgr, hypervisorTypes, $location) {
            this.$scope = $scope;
            this.virtualRouterOfferingMgr = virtualRouterOfferingMgr;
            this.hypervisorTypes = hypervisorTypes;
            this.$location = $location;
            $scope.model = new VirtualRouterOfferingModel();
            $scope.oVirtualRouterOfferingGrid = new OVirtualRouterOfferingGrid($scope, virtualRouterOfferingMgr);
            $scope.action = new Action($scope, virtualRouterOfferingMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"virtualRouterOffering.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"virtualRouterOffering.ts.Description" | translate}}',
                        value: 'description'
                    },
                    {
                        name: '{{"virtualRouterOffering.ts.CPU Number" | translate}}',
                        value: 'cpuNum'
                    },
                    {
                        name: '{{"virtualRouterOffering.ts.CPU Speed" | translate}}',
                        value: 'cpuSpeed'
                    },
                    {
                        name: '{{"virtualRouterOffering.ts.Memory" | translate}}',
                        value: 'memorySize'
                    },
                    {
                        name: '{{"virtualRouterOffering.ts.State" | translate}}',
                        value: 'state'
                    },
                    {
                        name: '{{"virtualRouterOffering.ts.Created Date" | translate}}',
                        value: 'createDate'
                    },
                    {
                        name: '{{"virtualRouterOffering.ts.Last Updated Date" | translate}}',
                        value: 'lastOpDate'
                    }
                ],
                done: function (ret) {
                    virtualRouterOfferingMgr.setSortBy(ret);
                    $scope.oVirtualRouterOfferingGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.VirtualRouterOfferingInventoryQueryable,
                name: 'VirtualRouterOffering',
                schema: {
                    state: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_LIST,
                        list: ['Enabled', 'Disabled']
                    },
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    virtualRouterOfferingMgr.query(qobj, function (VirtualRouterOfferings, total) {
                        $scope.oVirtualRouterOfferingGrid.refresh(VirtualRouterOfferings);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/virtualRouterOffering/{0}', $scope.model.current.uuid);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            $scope.filterBy = new FilterBy($scope, this.hypervisorTypes);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcCreateVirtualRouterOffering = function (win) {
                win.open();
            };
            $scope.funcDeleteVirtualRouterOffering = function () {
                $scope.deleteVirtualRouterOffering.open();
            };
            $scope.optionsDeleteVirtualRouterOffering = {
                title: 'DELETE VIRTUAL ROUTER OFFERING',
                btnType: 'btn-danger',
                description: function () {
                    return $scope.model.current.name;
                },
                width: '400px',
                confirm: function () {
                    virtualRouterOfferingMgr.delete($scope.model.current, function (ret) {
                        $scope.oVirtualRouterOfferingGrid.deleteCurrent();
                    });
                }
            };
            $scope.funcRefresh = function () {
                $scope.oVirtualRouterOfferingGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return Utils.notNullnotUndefined($scope.model.current) && $scope.model.current.isInProgress();
            };
            $scope.optionsCreateVirtualRouterOffering = {
                done: function (virtualRouterOffering) {
                    $scope.oVirtualRouterOfferingGrid.refresh();
                }
            };
        }
        Controller.$inject = ['$scope', 'VirtualRouterOfferingManager', 'hypervisorTypes', '$location'];
        return Controller;
    })();
    MVirtualRouterOffering.Controller = Controller;
    var CreateVirtualRouterOfferingOptions = (function () {
        function CreateVirtualRouterOfferingOptions() {
        }
        return CreateVirtualRouterOfferingOptions;
    })();
    MVirtualRouterOffering.CreateVirtualRouterOfferingOptions = CreateVirtualRouterOfferingOptions;
    var CreateVirtualRouterOffering = (function () {
        function CreateVirtualRouterOffering(api, virtualRouterOfferingMgr, l3Mgr, imgMgr, zoneMgr, bsMgr) {
            var _this = this;
            this.api = api;
            this.virtualRouterOfferingMgr = virtualRouterOfferingMgr;
            this.l3Mgr = l3Mgr;
            this.imgMgr = imgMgr;
            this.zoneMgr = zoneMgr;
            this.bsMgr = bsMgr;
            this.scope = true;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zCreateVirtualRouterOffering;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                _this.options = new CreateVirtualRouterOfferingOptions();
                var optionName = $attrs.zOptions;
                if (angular.isDefined(optionName)) {
                    _this.options = parentScope[optionName];
                    $scope.$watch(function () {
                        return parentScope[optionName];
                    }, function () {
                        _this.options = parentScope[optionName];
                    });
                }
                var infoPage = $scope.infoPage = {
                    activeState: true,
                    name: null,
                    description: null,
                    memorySize: null,
                    cpuNum: null,
                    cpuSpeed: null,
                    allocatorStrategy: null,
                    zoneUuid: null,
                    managementNetworkUuid: null,
                    publicNetworkUuid: null,
                    imageUuid: null,
                    system: null,
                    hasZone: function () {
                        return $scope.zoneOptions__.dataSource.data().length > 0;
                    },
                    hasL3Network: function () {
                        return $scope.mgmtL3Options__.dataSource.data().length > 0;
                    },
                    hasImage: function () {
                        return $scope.imageOptions__.dataSource.data().length > 0;
                    },
                    isCpuNumValid: function () {
                        if (Utils.notNullnotUndefined(this.cpuNum)) {
                            return !isNaN(this.cpuNum);
                        }
                        return true;
                    },
                    isCpuSpeedValid: function () {
                        if (Utils.notNullnotUndefined(this.cpuSpeed)) {
                            return !isNaN(this.cpuSpeed);
                        }
                        return true;
                    },
                    isMemoryValid: function () {
                        if (Utils.notNullnotUndefined(this.memorySize)) {
                            return Utils.isValidSizeStr(this.memorySize);
                        }
                        return true;
                    },
                    canMoveToPrevious: function () {
                        return false;
                    },
                    canMoveToNext: function () {
                        return Utils.notNullnotUndefined(this.name) && Utils.notNullnotUndefined(this.memorySize) && Utils.notNullnotUndefined(this.cpuNum)
                            && Utils.notNullnotUndefined(this.cpuSpeed) && Utils.notNullnotUndefined(this.zoneUuid) && Utils.notNullnotUndefined(this.managementNetworkUuid)
                            && Utils.notNullnotUndefined(this.publicNetworkUuid) && Utils.notNullnotUndefined(this.imageUuid)
                            && this.isCpuNumValid() && this.isCpuSpeedValid() && this.isMemoryValid();
                    },
                    show: function () {
                        this.getAnchorElement().tab('show');
                    },
                    getAnchorElement: function () {
                        return $('.nav a[data-target="#createVirtualRouterOfferingInfo"]');
                    },
                    active: function () {
                        this.activeState = true;
                    },
                    isActive: function () {
                        return this.activeState;
                    },
                    getPageName: function () {
                        return 'createVirtualRouterOfferingInfo';
                    },
                    reset: function () {
                        this.name = Utils.shortHashName('vrOffering');
                        this.memorySize = null;
                        this.cpuNum = null;
                        this.cpuSpeed = null;
                        this.allocatorStrategy = null;
                        this.description = null;
                        this.managementNetworkUuid = null;
                        this.publicNetworkUuid = null;
                        this.system = false;
                        this.imageUuid = null;
                        this.zoneUuid = null;
                        this.activeState = false;
                    }
                };
                var mediator = $scope.mediator = {
                    currentPage: infoPage,
                    movedToPage: function (page) {
                        $scope.mediator.currentPage = page;
                    },
                    finishButtonName: function () {
                        return "Create";
                    },
                    finish: function () {
                        if (Utils.notNullnotUndefined($scope.infoPage.allocatorStrategy) && $scope.infoPage.allocatorStrategy == "") {
                            $scope.infoPage.allocatorStrategy = null;
                        }
                        $scope.infoPage.memorySize = Utils.parseSize($scope.infoPage.memorySize);
                        virtualRouterOfferingMgr.create(infoPage, function (ret) {
                            if (Utils.notNullnotUndefined(_this.options.done)) {
                                _this.options.done(ret);
                            }
                        });
                        $scope.winCreateVirtualRouterOffering__.close();
                    }
                };
                $scope.button = new Utils.WizardButton([
                    infoPage
                ], mediator);
                $scope.winCreateVirtualRouterOfferingOptions__ = {
                    width: '700px',
                    animation: false,
                    modal: true,
                    draggable: false,
                    resizable: false
                };
                $scope.allocatorStrategyOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] })
                };
                $scope.mgmtL3Options__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.pubL3Options__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.imageOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.Name" | translate}}:</span><span>#: name #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.Format" | translate}}:</span><span>#: format #</span></div>' +
                        '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.UUID" | translate}}:</span><span>#: uuid #</span></div>'
                };
                $scope.zoneOptions__ = {
                    dataSource: new kendo.data.DataSource({ data: [] }),
                    dataTextField: "name",
                    dataValueField: "uuid",
                    template: '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.Name" | translate}}</span>: #: name #</div>' + '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.Name" | translate}}:</span>#: state #</div>' + '<div style="color: black"><span class="z-label">{{"virtualRouterOffering.ts.UUID" | translate}}:</span> #: uuid #</div>'
                };
                $scope.$watch(function () {
                    return $scope.infoPage.zoneUuid;
                }, function () {
                    var zoneUuid = $scope.infoPage.zoneUuid;
                    if (!Utils.notNullnotUndefined(zoneUuid)) {
                        return;
                    }
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = [
                        {
                            name: 'zoneUuid',
                            op: '=',
                            value: zoneUuid
                        }
                    ];
                    l3Mgr.query(qobj, function (l3s) {
                        $scope.mgmtL3Options__.dataSource.data(l3s);
                        $scope.pubL3Options__.dataSource.data(l3s);
                        if (l3s.length > 0) {
                            $scope.infoPage.publicNetworkUuid = l3s[0].uuid;
                            $scope.infoPage.managementNetworkUuid = l3s[0].uuid;
                        }
                    });
                    var chain = new Utils.Chain();
                    var bsUuids = [];
                    chain.then(function () {
                        qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'attachedZoneUuids',
                                op: 'in',
                                value: zoneUuid
                            }
                        ];
                        bsMgr.query(qobj, function (bss) {
                            angular.forEach(bss, function (it) {
                                bsUuids.push(it.uuid);
                            });
                            chain.next();
                        });
                    }).then(function () {
                        if (bsUuids.length == 0) {
                            chain.next();
                            return;
                        }
                        qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [
                            {
                                name: 'backupStorageRefs.backupStorageUuid',
                                op: 'in',
                                value: bsUuids.join()
                            },
                            {
                                name: 'status',
                                op: '=',
                                value: 'Ready'
                            }
                        ];
                        imgMgr.query(qobj, function (imgs) {
                            $scope.imageOptions__.dataSource.data(imgs);
                            if (imgs.length > 0) {
                                $scope.infoPage.imageUuid = imgs[0].uuid;
                            }
                            chain.next();
                        });
                    }).start();
                });
                _this.$scope = $scope;
            };
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/virtualRouterOffering/addVirtualRouterOffering.html';
        }
        CreateVirtualRouterOffering.prototype.open = function () {
            var _this = this;
            var win = this.$scope.winCreateVirtualRouterOffering__;
            this.$scope.button.reset();
            var chain = new Utils.Chain();
            chain.then(function () {
                _this.api.getInstanceOfferingAllocatorStrategies(function (ret) {
                    ret.unshift("");
                    _this.$scope.allocatorStrategyOptions__.dataSource.data(ret);
                    chain.next();
                });
            }).then(function () {
                var qobj = new ApiHeader.QueryObject();
                qobj.conditions = [];
                _this.zoneMgr.query(qobj, function (zones) {
                    _this.$scope.zoneOptions__.dataSource.data(zones);
                    if (zones.length > 0) {
                        _this.$scope.infoPage.zoneUuid = zones[0].uuid;
                    }
                    chain.next();
                });
            }).done(function () {
                win.center();
                win.open();
            }).start();
        };
        return CreateVirtualRouterOffering;
    })();
    MVirtualRouterOffering.CreateVirtualRouterOffering = CreateVirtualRouterOffering;
})(MVirtualRouterOffering || (MVirtualRouterOffering = {}));
angular.module('root').factory('VirtualRouterOfferingManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MVirtualRouterOffering.VirtualRouterOfferingManager(api, $rootScope);
    }]).directive('zCreateVirtualRouterOffering', ['Api', 'VirtualRouterOfferingManager', 'L3NetworkManager', 'ImageManager', 'ZoneManager', 'BackupStorageManager',
    function (api, virtualRouterOfferingMgr, l3Mgr, imgMgr, zoneMgr, bsMgr) {
        return new MVirtualRouterOffering.CreateVirtualRouterOffering(api, virtualRouterOfferingMgr, l3Mgr, imgMgr, zoneMgr, bsMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/virtualRouterOffering', {
            templateUrl: '/static/templates/virtualRouterOffering/virtualRouterOffering.html',
            controller: 'MVirtualRouterOffering.Controller',
            resolve: {
                hypervisorTypes: function ($q, Api) {
                    var defer = $q.defer();
                    Api.getHypervisorTypes(function (hypervisorTypes) {
                        defer.resolve(hypervisorTypes);
                    });
                    return defer.promise;
                }
            }
        }).when('/virtualRouterOffering/:uuid', {
            templateUrl: '/static/templates/virtualRouterOffering/details.html',
            controller: 'MVirtualRouterOffering.DetailsController',
            resolve: {
                current: function ($q, $route, VirtualRouterOfferingManager, L3NetworkManager) {
                    var defer = $q.defer();
                    var chain = new Utils.Chain();
                    var ret = {
                        offering: null,
                        mgmtL3: null,
                        pubL3: null
                    };
                    chain.then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        var uuid = $route.current.params.uuid;
                        qobj.addCondition({ name: 'uuid', op: '=', value: uuid });
                        VirtualRouterOfferingManager.query(qobj, function (virtualRouterOfferings) {
                            ret.offering = virtualRouterOfferings[0];
                            chain.next();
                        });
                    }).then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [{
                                name: "uuid",
                                op: "=",
                                value: ret.offering.managementNetworkUuid
                            }];
                        L3NetworkManager.query(qobj, function (l3s) {
                            ret.mgmtL3 = l3s[0];
                            chain.next();
                        });
                    }).then(function () {
                        var qobj = new ApiHeader.QueryObject();
                        qobj.conditions = [{
                                name: "uuid",
                                op: "=",
                                value: ret.offering.publicNetworkUuid
                            }];
                        L3NetworkManager.query(qobj, function (l3s) {
                            ret.pubL3 = l3s[0];
                            chain.next();
                        });
                    }).done(function () {
                        defer.resolve(ret);
                    }).start();
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MDashboard;
(function (MDashboard) {
    var DashboardManager = (function () {
        function DashboardManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        DashboardManager.$inject = ['Api'];
        return DashboardManager;
    })();
    MDashboard.DashboardManager = DashboardManager;
    var Controller = (function () {
        function Controller($scope, api, $location, zoneMgr, Translator, $translate) {
            this.$scope = $scope;
            this.api = api;
            this.$location = $location;
            this.zoneMgr = zoneMgr;
            this.Translator = Translator;
            this.$translate = $translate;
            var cpu = new kendo.data.ObservableObject({
                total: 0,
                available: 0,
                percent: 0
            });
            Translator.addProperty(cpu, 'name', 'dashboard.CPU');
            var memory = new kendo.data.ObservableObject({
                total: 0,
                available: 0,
                percent: 0
            });
            Translator.addProperty(memory, 'name', 'dashboard.MEMORY');
            var priCap = new kendo.data.ObservableObject({
                total: 0,
                available: 0,
                percent: 0
            });
            Translator.addProperty(priCap, 'name', 'dashboard.PRIMARY STORAGE');
            var backupCap = new kendo.data.ObservableObject({
                total: 0,
                available: 0,
                percent: 0
            });
            Translator.addProperty(backupCap, 'name', 'dashboard.BACKUP STORAGE');
            var ip = new kendo.data.ObservableObject({
                total: 0,
                available: 0,
                percent: 0
            });
            Translator.addProperty(ip, 'name', 'dashboard.IP ADDRESS');
            $scope.capacityGrid = {
                resizable: true,
                scrollable: true,
                pageable: false,
                columns: [
                    {
                        field: 'name',
                        title: '{{ "dashboard.CAPACITY NAME" | translate }}',
                        width: '25%'
                    },
                    {
                        field: 'total',
                        title: '{{ "dashboard.TOTAL CAPACITY" | translate }}',
                        width: '25%'
                    },
                    {
                        field: 'available',
                        title: '{{ "dashboard.AVAILABLE CAPACITY" | translate }}',
                        width: '25%'
                    },
                    {
                        field: 'percent',
                        title: '{{ "dashboard.AVAILABLE PERCENTAGE" | translate }}',
                        width: '25%'
                    }
                ],
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            var chain = new Utils.Chain();
                            chain.then(function () {
                                api.getMemoryCpuCapacityByAll(function (ret) {
                                    cpu.set('total', Utils.toHZString(ret.totalCpu));
                                    cpu.set('available', Utils.toHZString(ret.availableCpu));
                                    cpu.set('percent', Utils.toPercentageString(ret.totalCpu == 0 ? 0 : ret.availableCpu / ret.totalCpu));
                                    memory.set('total', Utils.toSizeString(ret.totalMemory));
                                    memory.set('available', Utils.toSizeString(ret.availableMemory));
                                    memory.set('percent', Utils.toPercentageString(ret.totalMemory == 0 ? 0 : ret.availableMemory / ret.totalMemory));
                                });
                                chain.next();
                            }).then(function () {
                                api.getPirmaryStorageCapacityByAll(function (ret) {
                                    priCap.set('total', Utils.toSizeString(ret.totalCapacity));
                                    priCap.set('available', Utils.toSizeString(ret.availableCapacity));
                                    priCap.set('percent', Utils.toPercentageString(ret.totalCapacity == 0 ? 0 : ret.availableCapacity / ret.totalCapacity));
                                });
                                chain.next();
                            }).then(function () {
                                api.getBackupStorageCapacityByAll(function (ret) {
                                    backupCap.set('total', Utils.toSizeString(ret.totalCapacity));
                                    backupCap.set('available', Utils.toSizeString(ret.availableCapacity));
                                    backupCap.set('percent', Utils.toPercentageString(ret.totalCapacity == 0 ? 0 : ret.availableCapacity / ret.totalCapacity));
                                });
                                chain.next();
                            }).then(function () {
                                api.getIpAddressCapacityByAll(function (ret) {
                                    ip.set('total', ret.totalCapacity);
                                    ip.set('available', ret.availableCapacity);
                                    ip.set('percent', Utils.toPercentageString(ret.totalCapacity == 0 ? 0 : ret.availableCapacity / ret.totalCapacity));
                                });
                                chain.next();
                            }).start();
                            options.success({
                                data: [
                                    cpu,
                                    memory,
                                    priCap,
                                    backupCap,
                                    ip
                                ],
                                total: 5
                            });
                        }
                    }
                })
            };
            var vm = new kendo.data.ObservableObject({
                name: 'VM INSTANCE',
                link: 'vmInstance',
                amount: 0
            });
            var volume = new kendo.data.ObservableObject({
                name: 'VOLUME',
                link: 'volume',
                amount: 0
            });
            var securityGroup = new kendo.data.ObservableObject({
                name: 'SECURITY GROUP',
                link: 'securityGroup',
                amount: 0
            });
            var eip = new kendo.data.ObservableObject({
                name: 'EIP',
                link: 'eip',
                amount: 0
            });
            var portForwarding = new kendo.data.ObservableObject({
                name: 'PORT FORWARDING',
                link: 'portForwarding',
                amount: 0
            });
            var zone = new kendo.data.ObservableObject({
                name: 'ZONE',
                link: 'zone',
                amount: 0
            });
            var cluster = new kendo.data.ObservableObject({
                name: 'CLUSTER',
                link: 'cluster',
                amount: 0
            });
            var host = new kendo.data.ObservableObject({
                name: 'HOST',
                link: 'host',
                amount: 0
            });
            var primaryStorage = new kendo.data.ObservableObject({
                name: 'PRIMARY STORAGE',
                link: 'primaryStorage',
                amount: 0
            });
            var backupStorage = new kendo.data.ObservableObject({
                name: 'BACKUP STORAGE',
                link: 'backupStorage',
                amount: 0
            });
            var l2Network = new kendo.data.ObservableObject({
                name: 'L2 NETWORK',
                link: 'l2Network',
                amount: 0
            });
            var l3Network = new kendo.data.ObservableObject({
                name: 'L3 NETWORK',
                link: 'l3Network',
                amount: 0
            });
            var instanceOffering = new kendo.data.ObservableObject({
                name: 'INSTANCE OFFERING',
                link: 'instanceOffering',
                amount: 0
            });
            var diskOffering = new kendo.data.ObservableObject({
                name: 'DISK OFFERING',
                link: 'diskOffering',
                amount: 0
            });
            var vrOffering = new kendo.data.ObservableObject({
                name: 'VIRTUAL ROUTER OFFERING',
                link: 'virtualRouterOffering',
                amount: 0
            });
            var image = new kendo.data.ObservableObject({
                name: 'IMAGE',
                link: 'image',
                amount: 0
            });
            var virtualRouter = new kendo.data.ObservableObject({
                name: 'VIRTUAL ROUTER',
                link: 'virtualRouter',
                amount: 0
            });
            $scope.resourceAmountGrid = {
                resizable: true,
                scrollable: true,
                pageable: false,
                columns: [
                    {
                        field: 'name',
                        title: '{{"dashboard.ts.RESOURCE NAME" | translate}}',
                        template: '<a href="/\\#/{{dataItem.link}}">{{dataItem.name}}</a>',
                        width: '50%'
                    },
                    {
                        field: 'amount',
                        title: '{{"dashboard.ts.COUNT" | translate}}',
                        width: '50%'
                    }
                ],
                dataSource: new kendo.data.DataSource({
                    schema: {
                        data: 'data',
                        total: 'total'
                    },
                    transport: {
                        read: function (options) {
                            var chain = new Utils.Chain();
                            chain.then(function () {
                                var msg = new ApiHeader.APIQueryVmInstanceMsg();
                                msg.count = true;
                                msg.conditions = [{
                                        name: 'type',
                                        op: '=',
                                        value: 'UserVm'
                                    }];
                                api.syncApi(msg, function (ret) {
                                    vm.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryVolumeMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    volume.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQuerySecurityGroupMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    securityGroup.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryEipMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    eip.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryPortForwardingRuleMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    portForwarding.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryZoneMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    zone.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryClusterMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    cluster.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryHostMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    host.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryPrimaryStorageMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    primaryStorage.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryBackupStorageMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    backupStorage.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryL2NetworkMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    l2Network.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryL3NetworkMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    l3Network.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryInstanceOfferingMsg();
                                msg.count = true;
                                msg.conditions = [{
                                        name: 'type',
                                        op: '=',
                                        value: 'UserVm'
                                    }];
                                api.syncApi(msg, function (ret) {
                                    instanceOffering.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryDiskOfferingMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    diskOffering.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryVirtualRouterOfferingMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    vrOffering.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryImageMsg();
                                msg.count = true;
                                msg.conditions = [];
                                api.syncApi(msg, function (ret) {
                                    image.set('amount', ret.total);
                                });
                                chain.next();
                            }).then(function () {
                                var msg = new ApiHeader.APIQueryApplianceVmMsg();
                                msg.count = true;
                                msg.conditions = [{
                                        name: 'applianceVmType',
                                        op: '=',
                                        value: 'VirtualRouter'
                                    }];
                                api.syncApi(msg, function (ret) {
                                    virtualRouter.set('amount', ret.total);
                                });
                                chain.next();
                            }).start();
                            options.success({
                                data: [
                                    vm,
                                    volume,
                                    securityGroup,
                                    eip,
                                    portForwarding,
                                    zone,
                                    cluster,
                                    host,
                                    image,
                                    primaryStorage,
                                    backupStorage,
                                    l2Network,
                                    l3Network,
                                    virtualRouter,
                                    instanceOffering,
                                    diskOffering,
                                    vrOffering
                                ],
                                total: 16
                            });
                        }
                    }
                })
            };
        }
        Controller.$inject = ['$scope', 'Api', '$location', 'ZoneManager', 'Translator', '$translate'];
        return Controller;
    })();
    MDashboard.Controller = Controller;
})(MDashboard || (MDashboard = {}));
angular.module('root').factory('DashboardManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MDashboard.DashboardManager(api, $rootScope);
    }]).config(['$routeProvider', function (route) {
        route.when('/dashboard', {
            templateUrl: '/static/templates/dashboard/dashboard.html',
            controller: 'MDashboard.Controller'
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
var MGlobalConfig;
(function (MGlobalConfig) {
    var GlobalConfigManager = (function () {
        function GlobalConfigManager(api, $rootScope) {
            this.api = api;
            this.$rootScope = $rootScope;
        }
        GlobalConfigManager.prototype.setSortBy = function (sortBy) {
            this.sortBy = sortBy;
        };
        GlobalConfigManager.prototype.query = function (qobj, callback) {
            var msg = new ApiHeader.APIQueryGlobalConfigMsg();
            msg.count = qobj.count === true;
            msg.start = qobj.start;
            msg.limit = qobj.limit;
            msg.replyWithCount = true;
            msg.conditions = qobj.conditions ? qobj.conditions : [];
            if (Utils.notNullnotUndefined(this.sortBy) && this.sortBy.isValid()) {
                msg.sortBy = this.sortBy.field;
                msg.sortDirection = this.sortBy.direction;
            }
            this.api.syncApi(msg, function (ret) {
                callback(ret.inventories, ret.total);
            });
        };
        GlobalConfigManager.prototype.update = function (config, done) {
            var msg = new ApiHeader.APIUpdateGlobalConfigMsg();
            msg.name = config.name;
            msg.category = config.category;
            msg.value = config.value;
            this.api.asyncApi(msg, function (ret) {
                if (Utils.notNullnotUndefined(done)) {
                    done(ret.inventory);
                }
            });
        };
        GlobalConfigManager.$inject = ['Api', '$rootScope'];
        return GlobalConfigManager;
    })();
    MGlobalConfig.GlobalConfigManager = GlobalConfigManager;
    var GlobalConfigModel = (function (_super) {
        __extends(GlobalConfigModel, _super);
        function GlobalConfigModel() {
            _super.call(this);
            this.current = null;
        }
        return GlobalConfigModel;
    })(Utils.Model);
    MGlobalConfig.GlobalConfigModel = GlobalConfigModel;
    var OGlobalConfigGrid = (function (_super) {
        __extends(OGlobalConfigGrid, _super);
        function OGlobalConfigGrid($scope, globalConfigMgr) {
            _super.call(this);
            this.globalConfigMgr = globalConfigMgr;
            _super.prototype.init.call(this, $scope, $scope.globalConfigGrid);
            this.options.columns = [
                {
                    field: 'name',
                    title: '{{"globalConfig.ts.NAME" | translate}}',
                    width: '20%'
                },
                {
                    field: 'category',
                    title: '{{"globalConfig.ts.CATEGORY" | translate}}',
                    width: '20%'
                },
                {
                    field: 'description',
                    title: '{{"globalConfig.ts.DESCRIPTION" | translate}}',
                    width: '40%'
                },
                {
                    field: 'value',
                    title: '{{"globalConfig.ts.VALUE" | translate}}',
                    width: '20%'
                }
            ];
            this.options.dataSource.transport.read = function (options) {
                var qobj = new ApiHeader.QueryObject();
                qobj.limit = options.data.take;
                qobj.start = options.data.pageSize * (options.data.page - 1);
                globalConfigMgr.query(qobj, function (configs, total) {
                    options.success({
                        data: configs,
                        total: total
                    });
                });
            };
            this.options.dataSource.pageSize(30);
        }
        return OGlobalConfigGrid;
    })(Utils.OGrid);
    var Action = (function () {
        function Action($scope, globalConfigMgr) {
            this.$scope = $scope;
            this.globalConfigMgr = globalConfigMgr;
        }
        Action.prototype.edit = function () {
            this.$scope.editGlobalConfigWin.open();
        };
        return Action;
    })();
    var FilterBy = (function () {
        function FilterBy($scope, categories) {
            var _this = this;
            this.$scope = $scope;
            this.categories = categories;
            this.fieldList = {
                dataSource: new kendo.data.DataSource({
                    data: [
                        {
                            name: '{{"globalConfig.ts.None" | translate}}',
                            value: FilterBy.NONE
                        },
                        {
                            name: '{{"globalConfig.ts.Category" | translate}}',
                            value: FilterBy.CATEGORY
                        }
                    ]
                }),
                dataTextField: 'name',
                dataValueField: 'value'
            };
            this.valueList = {
                dataSource: new kendo.data.DataSource({
                    data: []
                })
            };
            this.field = FilterBy.NONE;
            $scope.$watch(function () {
                return _this.field;
            }, function () {
                if (_this.isFieldNone()) {
                    _this.valueList.dataSource.data([]);
                }
                else if (_this.field == FilterBy.CATEGORY) {
                    _this.valueList.dataSource.data(_this.categories);
                }
            });
        }
        FilterBy.prototype.isFieldNone = function () {
            return this.field == FilterBy.NONE;
        };
        FilterBy.prototype.confirm = function (popover) {
            this.$scope.oGlobalConfigGrid.setFilter(this.toKendoFilter());
            this.name = this.isFieldNone() ? null : Utils.sprintf('{0}:{1}', this.field, this.value);
            popover.toggle();
        };
        FilterBy.prototype.open = function (popover) {
            popover.toggle();
        };
        FilterBy.prototype.isValueListDisabled = function () {
            return !Utils.notNullnotUndefined(this.value);
        };
        FilterBy.prototype.getButtonName = function () {
            return this.name;
        };
        FilterBy.prototype.toKendoFilter = function () {
            if (this.isFieldNone()) {
                return null;
            }
            return {
                field: this.field,
                operator: 'eq',
                value: this.value
            };
        };
        FilterBy.NONE = 'none';
        FilterBy.CATEGORY = 'category';
        return FilterBy;
    })();
    var DetailsController = (function () {
        function DetailsController($scope, gMgr, $routeParams, current) {
            var _this = this;
            this.$scope = $scope;
            this.gMgr = gMgr;
            this.$routeParams = $routeParams;
            $scope.model = new GlobalConfigModel();
            $scope.model.current = current;
            $scope.action = new Action($scope, gMgr);
            $scope.funcRefresh = function () {
                _this.loadSelf($scope.model.current);
            };
            $scope.funcToolbarShow = function () {
                return Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.editGlobalConfigOptions = {
                config: current,
                done: function (inv) {
                    $scope.model.current = inv;
                }
            };
        }
        DetailsController.prototype.loadSelf = function (current) {
            var _this = this;
            var qobj = new ApiHeader.QueryObject();
            qobj.conditions = [
                {
                    name: 'category',
                    op: '=',
                    value: current.category
                },
                {
                    name: 'name',
                    op: '=',
                    value: current.name
                }
            ];
            this.gMgr.query(qobj, function (globalConfigs, total) {
                _this.$scope.model.current = globalConfigs[0];
            });
        };
        DetailsController.$inject = ['$scope', 'GlobalConfigManager', '$routeParams', 'current'];
        return DetailsController;
    })();
    MGlobalConfig.DetailsController = DetailsController;
    var Controller = (function () {
        function Controller($scope, gMgr, configs, $location) {
            this.$scope = $scope;
            this.gMgr = gMgr;
            this.configs = configs;
            this.$location = $location;
            $scope.model = new GlobalConfigModel();
            $scope.oGlobalConfigGrid = new OGlobalConfigGrid($scope, gMgr);
            $scope.action = new Action($scope, gMgr);
            $scope.optionsSortBy = {
                fields: [
                    {
                        name: '{{"globalConfig.ts.Name" | translate}}',
                        value: 'name'
                    },
                    {
                        name: '{{"globalConfig.ts.Category" | translate}}',
                        value: 'category'
                    },
                    {
                        name: '{{"globalConfig.ts.Description" | translate}}',
                        value: 'description'
                    }
                ],
                done: function (ret) {
                    gMgr.setSortBy(ret);
                    $scope.oGlobalConfigGrid.refresh();
                }
            };
            $scope.optionsSearch = {
                fields: ApiHeader.GlobalConfigInventoryQueryable,
                name: 'GlobalConfig',
                schema: {
                    createDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    },
                    lastOpDate: {
                        type: Directive.SearchBoxSchema.VALUE_TYPE_TIMESTAMP
                    }
                },
                done: function (ret) {
                    var qobj = new ApiHeader.QueryObject();
                    qobj.conditions = ret;
                    gMgr.query(qobj, function (configs, total) {
                        $scope.oGlobalConfigGrid.refresh(configs);
                    });
                }
            };
            $scope.funcGridDoubleClick = function (e) {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    var url = Utils.sprintf('/globalConfig/{0}/{1}', $scope.model.current.category, $scope.model.current.name);
                    $location.path(url);
                    e.preventDefault();
                }
            };
            var categories = {};
            angular.forEach(configs, function (it) {
                categories[it.category] = it;
            });
            var categoryNames = [];
            for (var k in categories) {
                categoryNames.push(k);
            }
            $scope.filterBy = new FilterBy($scope, categoryNames);
            $scope.funcSearch = function (win) {
                win.open();
            };
            $scope.funcRefresh = function () {
                $scope.oGlobalConfigGrid.refresh();
            };
            $scope.funcIsActionShow = function () {
                return !Utils.isEmptyObject($scope.model.current);
            };
            $scope.funcIsActionDisabled = function () {
                return !Utils.notNullnotUndefined($scope.model.current);
            };
            $scope.editGlobalConfigOptions = {
                config: null,
                done: function () {
                    $scope.oGlobalConfigGrid.refresh();
                }
            };
            $scope.$watch(function () {
                return $scope.model.current;
            }, function () {
                if (Utils.notNullnotUndefined($scope.model.current)) {
                    $scope.editGlobalConfigOptions.config = $scope.model.current;
                }
            });
        }
        Controller.$inject = ['$scope', 'GlobalConfigManager', 'configs', '$location'];
        return Controller;
    })();
    MGlobalConfig.Controller = Controller;
    var EditGlobalConfig = (function () {
        function EditGlobalConfig(gMgr) {
            var _this = this;
            this.gMgr = gMgr;
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/globalConfig/editGlobalConfig.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zEditGlobalConfig] = _this;
                _this.options = parent[$attrs.zOptions];
                $scope.name = null;
                $scope.category = null;
                $scope.currentValue = null;
                $scope.newValue = null;
                $scope.canProceed = function () {
                    return Utils.notNullnotUndefined($scope.newValue) && $scope.newValue != $scope.currentValue;
                };
                $scope.cancel = function () {
                    $scope.editGlobalConfig__.close();
                };
                $scope.done = function () {
                    gMgr.update({
                        name: $scope.name,
                        category: $scope.category,
                        value: $scope.newValue
                    }, function (inv) {
                        if (Utils.notNullnotUndefined(_this.options.done)) {
                            _this.options.done(inv);
                        }
                    });
                    $scope.editGlobalConfig__.close();
                };
                _this.$scope = $scope;
                $scope.editGlobalConfigOptions__ = {
                    width: '550px'
                };
            };
        }
        EditGlobalConfig.prototype.open = function () {
            this.$scope.name = this.options.config.name;
            this.$scope.category = this.options.config.category;
            this.$scope.currentValue = this.options.config.value;
            this.$scope.newValue = this.options.config.value;
            this.$scope.editGlobalConfig__.center();
            this.$scope.editGlobalConfig__.open();
        };
        return EditGlobalConfig;
    })();
    MGlobalConfig.EditGlobalConfig = EditGlobalConfig;
})(MGlobalConfig || (MGlobalConfig = {}));
angular.module('root').factory('GlobalConfigManager', ['Api', '$rootScope', function (api, $rootScope) {
        return new MGlobalConfig.GlobalConfigManager(api, $rootScope);
    }]).directive('zEditGlobalConfig', ['GlobalConfigManager', function (gMgr) {
        return new MGlobalConfig.EditGlobalConfig(gMgr);
    }]).config(['$routeProvider', function (route) {
        route.when('/globalConfig', {
            templateUrl: '/static/templates/globalConfig/globalConfig.html',
            controller: 'MGlobalConfig.Controller',
            resolve: {
                configs: function ($q, GlobalConfigManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    GlobalConfigManager.query(qobj, function (configs) {
                        defer.resolve(configs);
                    });
                    return defer.promise;
                }
            }
        }).when('/globalConfig/:category/:name', {
            templateUrl: '/static/templates/globalConfig/details.html',
            controller: 'MGlobalConfig.DetailsController',
            resolve: {
                current: function ($q, $route, GlobalConfigManager) {
                    var defer = $q.defer();
                    var qobj = new ApiHeader.QueryObject();
                    var category = $route.current.params.category;
                    var name = $route.current.params.name;
                    qobj.conditions = [{
                            name: 'category',
                            op: '=',
                            value: category
                        }, {
                            name: 'name',
                            op: '=',
                            value: name
                        }];
                    GlobalConfigManager.query(qobj, function (globalConfigs) {
                        var globalConfig = globalConfigs[0];
                        defer.resolve(globalConfig);
                    });
                    return defer.promise;
                }
            }
        });
    }]);
/// <reference path="d.ts/angularjs/angular.d.ts" />
/// <reference path="d.ts/kendo.all.d.ts" />
/// <reference path="d.ts/sprintf.d.ts" />
var Directive;
(function (Directive) {
    var PanelHeaderIn = (function () {
        function PanelHeaderIn() {
            this.scope = false;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var collapse = $element.find('.collapse');
                var i = $element.find('i.z-collapse');
                collapse.on('show.bs.collapse', function () {
                    $scope.$apply(function () {
                        i.removeClass('fa fa-chevron-right');
                        i.addClass('fa fa-chevron-down');
                    });
                });
                collapse.on('hide.bs.collapse', function () {
                    i.removeClass('fa fa-chevron-down');
                    i.addClass('fa fa-chevron-right');
                });
            };
            this.restrict = 'EA';
            this.replace = false;
        }
        return PanelHeaderIn;
    })();
    Directive.PanelHeaderIn = PanelHeaderIn;
    var PopoverImpl = (function () {
        function PopoverImpl($scope, $attrs, $element) {
            this.$scope = $scope;
            this.$attrs = $attrs;
            this.$element = $element;
            this.isOpen = false;
            this.id = '#' + $attrs.id;
            if (Utils.notNullnotUndefined($attrs.zOptions)) {
                this.options = $scope[$attrs.zOptions];
            }
            else {
                this.options = {
                    html: true,
                    trigger: 'click',
                    placement: 'bottom',
                    container: 'body'
                };
            }
            var contentId = $attrs.zContentId;
            var content = $element.parent().find('#' + contentId);
            content.hide();
            this.options.content = function () {
                content.show();
                return content;
            };
            this.popover = $(this.id);
            this.popover.popover(this.options);
        }
        PopoverImpl.prototype.toggle = function () {
            if (!this.isOpen) {
                this.popover.popover('show');
            }
            else {
                this.popover.popover('hide');
            }
            this.isOpen = !this.isOpen;
        };
        return PopoverImpl;
    })();
    var Popover = (function () {
        function Popover() {
            this.scope = true;
            this.restrict = 'EA';
            this.replace = false;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var parent = $scope.$parent;
                parent[$attrs.zPopover] = new PopoverImpl($scope, $attrs, $element);
            };
        }
        return Popover;
    })();
    Directive.Popover = Popover;
    var SearchBoxSchema = (function () {
        function SearchBoxSchema() {
        }
        SearchBoxSchema.VALUE_TYPE_TEXT = "text";
        SearchBoxSchema.VALUE_TYPE_LIST = "list";
        SearchBoxSchema.VALUE_TYPE_TIMESTAMP = "timeStamp";
        return SearchBoxSchema;
    })();
    Directive.SearchBoxSchema = SearchBoxSchema;
    var SearchCondition = (function () {
        function SearchCondition() {
        }
        SearchCondition.prototype.equals = function (obj) {
            return obj.name === this.name && obj.op === this.op && obj.value === this.value;
        };
        SearchCondition.prototype.setListValue = function (val) {
            this.type = SearchBoxSchema.VALUE_TYPE_LIST;
            this.listValue = val;
        };
        SearchCondition.prototype.setTextValue = function (val) {
            this.type = SearchBoxSchema.VALUE_TYPE_TEXT;
            this.value = val;
        };
        SearchCondition.prototype.setDateTimeValue = function (val) {
            this.type = SearchBoxSchema.VALUE_TYPE_TIMESTAMP;
            this.value = val;
        };
        SearchCondition.prototype.toQueryCondition = function () {
            var ret = new ApiHeader.QueryCondition();
            ret.name = this.name;
            ret.op = this.op;
            if (this.type == SearchBoxSchema.VALUE_TYPE_TEXT) {
                ret.value = this.value;
            }
            else if (this.type == SearchBoxSchema.VALUE_TYPE_LIST) {
                ret.value = this.listValue;
            }
            else if (this.type == SearchBoxSchema.VALUE_TYPE_TIMESTAMP) {
                ret.value = this.dateTimeValue;
            }
            return ret;
        };
        SearchCondition.prototype.hasValue = function () {
            if (this.type == SearchBoxSchema.VALUE_TYPE_TEXT) {
                return Utils.notNullnotUndefined(this.value);
            }
            else if (this.type == SearchBoxSchema.VALUE_TYPE_LIST) {
                return Utils.notNullnotUndefined(this.listValue);
            }
            else if (this.type == SearchBoxSchema.VALUE_TYPE_TIMESTAMP) {
                return Utils.notNullnotUndefined(this.dateTimeValue);
            }
        };
        return SearchCondition;
    })();
    var SearchBox = (function () {
        function SearchBox($compile) {
            var _this = this;
            this.$compile = $compile;
            this.conditions = {};
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/directives/search.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var instanceName = $attrs.zSearch;
                var parentScope = $scope.$parent;
                parentScope[instanceName] = _this;
                var options = parentScope[$attrs.zOptions];
                _this.$scope = $scope;
                _this.options = options;
                $scope.currentCondition = new SearchCondition();
                $scope.funcValueShow = function (type) {
                    var schema = _this.getSchema();
                    if (!Utils.notNullnotUndefined(schema)) {
                        return type == SearchBoxSchema.VALUE_TYPE_TEXT;
                    }
                    return schema.type == type;
                };
                $scope.valueListOptions__ = {};
                $scope.name = options.name;
                $scope.funcCancel = function () {
                    $scope.winSearch__.close();
                };
                $scope.funcSearch = function () {
                    var ret = [];
                    var tmp = {};
                    angular.forEach(_this.conditions, function (cond) {
                        if (cond.op != 'in' && cond.op != 'not in') {
                            ret.push(cond);
                        }
                        else {
                            var queue = tmp[cond.name];
                            if (!Utils.notNullnotUndefined(queue)) {
                                queue = {};
                                tmp[cond.name] = queue;
                            }
                            if (cond.op == 'in') {
                                var inq = queue['in'];
                                if (!Utils.notNullnotUndefined(inq)) {
                                    inq = [];
                                    queue['in'] = inq;
                                }
                                inq.push(cond.value);
                            }
                            else {
                                var notinq = queue['not in'];
                                if (!Utils.notNullnotUndefined(notinq)) {
                                    notinq = [];
                                    queue['not in'] = notinq;
                                }
                                notinq.push(cond.value);
                            }
                        }
                    });
                    for (var k in tmp) {
                        var queue = tmp[k];
                        var inq = queue['in'];
                        if (Utils.notNullnotUndefined(inq)) {
                            ret.push({
                                name: k,
                                op: 'in',
                                value: inq.join()
                            });
                        }
                        var notinq = queue['not in'];
                        if (Utils.notNullnotUndefined(notinq)) {
                            ret.push({
                                name: k,
                                op: 'not in',
                                value: notinq.join()
                            });
                        }
                    }
                    if (Utils.notNullnotUndefined(_this.options.done)) {
                        _this.options.done(ret);
                    }
                    $scope.winSearch__.close();
                };
                $scope.funcCanAdd = function () {
                    if ($scope.currentCondition.op != 'is null' && $scope.currentCondition.op != 'is not null') {
                        return Utils.notNullnotUndefined($scope.currentCondition.name) && Utils.notNullnotUndefined($scope.currentCondition.op)
                            && $scope.currentCondition.hasValue();
                    }
                    else {
                        return Utils.notNullnotUndefined($scope.currentCondition.name) && Utils.notNullnotUndefined($scope.currentCondition.op);
                    }
                };
                $scope.funcCanConditionsShow = function () {
                    return !Utils.isEmptyObject(_this.conditions);
                };
                $scope.duplicateCondition = false;
                $scope.funcAddCondition = function () {
                    $scope.duplicateCondition = false;
                    var cur = $scope.currentCondition;
                    for (var k in _this.conditions) {
                        var c = _this.conditions[k];
                        if (c.name == cur.name && c.op == cur.op && c.value == cur.value) {
                            $scope.duplicateCondition = true;
                            return;
                        }
                    }
                    _this.conditions[Utils.uuid()] = $scope.currentCondition.toQueryCondition();
                    _this.newCurrentCondition();
                };
                $scope.optionsSearch__ = {
                    width: "680px",
                    animation: false,
                    resizable: false
                };
                $scope.valueTimestampOptions__ = {
                    value: null,
                    format: 'yyyy-MM-dd HH:mm:ss',
                    timeFormat: "HH:mm"
                };
                $scope.valueListOptions__ = {
                    dataSource: {
                        data: []
                    }
                };
                var fieldNames = [];
                fieldNames = fieldNames.concat(options.fields);
                fieldNames.push(SearchBox.USER_TAG_CONDITION_NAME);
                _this.fieldNames = fieldNames;
                $scope.optionsField = {
                    dataSource: new kendo.data.DataSource({
                        data: fieldNames
                    }),
                    change: function (e) {
                        var list = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.currentCondition.name = list.value();
                            if ($scope.currentCondition.name === SearchBox.USER_TAG_CONDITION_NAME) {
                                $scope.optionsOp.setData(SearchBox.TAG_OPS);
                            }
                            else {
                                $scope.optionsOp.setData(SearchBox.OPS);
                            }
                            var schema = _this.getSchema();
                            if (!Utils.notNullnotUndefined(schema) || schema.type == SearchBoxSchema.VALUE_TYPE_TEXT) {
                                $scope.currentCondition.setTextValue($scope.currentCondition.value);
                            }
                            else if (schema.type == SearchBoxSchema.VALUE_TYPE_LIST) {
                                $scope.valueList__.dataSource.data(schema.list);
                                $scope.currentCondition.setListValue(schema.list[0]);
                            }
                            else if (schema.type == SearchBoxSchema.VALUE_TYPE_TIMESTAMP) {
                                $scope.currentCondition.setDateTimeValue($scope.currentCondition.dateTimeValue);
                            }
                        });
                    }
                };
                $scope.optionsOp = {
                    dataSource: new kendo.data.DataSource({
                        data: SearchBox.OPS
                    }),
                    setData: function (data) {
                        $scope.optionsOp.dataSource.data(data);
                        $scope.currentCondition.op = data[0];
                    },
                    change: function (e) {
                        var list = e.sender;
                        Utils.safeApply($scope, function () {
                            $scope.currentCondition.op = list.value();
                        });
                    }
                };
                $scope.$watch(function () {
                    return _this.conditions;
                }, function () {
                    for (var k in _this.conditions) {
                        var c = _this.conditions[k];
                        if (c.op != '=') {
                            continue;
                        }
                        var schema = _this.options.schema[c.name];
                        if (!Utils.notNullnotUndefined(schema)) {
                            continue;
                        }
                        if (!Utils.notNullnotUndefined(schema.getQueryableFields)) {
                            continue;
                        }
                        var newFieldNames = [];
                        newFieldNames = newFieldNames.concat(schema.getQueryableFields(c.value));
                        newFieldNames.push(SearchBox.USER_TAG_CONDITION_NAME);
                        $scope.optionsField.dataSource.data(newFieldNames);
                        return;
                    }
                    $scope.optionsField.dataSource.data(fieldNames);
                    if (Utils.notNullnotUndefined($scope.fieldCombo__)) {
                        $scope.fieldCombo__.value(fieldNames[0]);
                    }
                }, true);
                $scope.funcRemoveCondition = function (uuid) {
                    var cond = _this.conditions[uuid];
                    var schema = _this.options.schema[cond.name];
                    if (!Utils.notNullnotUndefined(schema) || !Utils.notNullnotUndefined(schema.removeCascade)) {
                        delete _this.conditions[uuid];
                        return;
                    }
                    for (var k in schema.removeCascade) {
                        if (k != cond.name) {
                            continue;
                        }
                        angular.forEach(schema.removeCascade[k], function (cascadeField) {
                            for (var ck in _this.conditions) {
                                var cv = _this.conditions[ck];
                                if (cv.name == cascadeField) {
                                    delete _this.conditions[ck];
                                }
                            }
                        });
                    }
                    delete _this.conditions[uuid];
                };
                var conditionTable = $element.find('#conditionTable');
                $scope.$watch(function () {
                    return _this.conditions;
                }, function () {
                    angular.forEach(conditionTable.children(), function (child) {
                        child.remove();
                    });
                    if (Utils.isEmptyObject(_this.conditions)) {
                        return;
                    }
                    var header = '<tr><th class="z-label">CONDITIONS</th><th></th></tr>';
                    header = $compile(header)($scope);
                    conditionTable.append(header);
                    angular.forEach(_this.conditions, function (cond, uuid) {
                        var tr = '<tr>'
                            + '<td>'
                            + '<span class="z-search-condition">' + cond.name + '</span>'
                            + '<span class="z-search-condition">' + cond.op + '</span>'
                            + '<span class="z-search-condition">' + cond.value + '</span>'
                            + '</td>'
                            + '<td><button type="button" class="btn btn-xs btn-danger pull-right" ng-click="funcRemoveCondition(\'' + uuid + '\')"><i class="fa fa-minus"></i></button></td>'
                            + '</tr>';
                        tr = $compile(tr)($scope);
                        conditionTable.append(tr);
                    });
                }, true);
            };
        }
        SearchBox.prototype.newCurrentCondition = function () {
            this.$scope.currentCondition = new SearchCondition();
            this.$scope.currentCondition.name = this.$scope.fieldCombo__.value();
            this.$scope.currentCondition.op = this.$scope.opDropdown__.value();
            var schema = this.getSchema();
            if (Utils.notNullnotUndefined(schema)) {
                if (schema.type == SearchBoxSchema.VALUE_TYPE_LIST) {
                    this.$scope.currentCondition.setListValue(this.$scope.valueList__.value());
                }
                else if (schema.type == SearchBoxSchema.VALUE_TYPE_TIMESTAMP) {
                    this.$scope.valueDateTime__.value(null);
                    this.$scope.currentCondition.setDateTimeValue(null);
                }
                else {
                    this.$scope.currentCondition.setTextValue(null);
                }
            }
            else {
                this.$scope.currentCondition.setTextValue(null);
            }
        };
        SearchBox.prototype.open = function () {
            this.conditions = {};
            this.newCurrentCondition();
            this.$scope.optionsField.dataSource.data(this.fieldNames);
            this.$scope.fieldCombo__.value(this.fieldNames[0]);
            this.$scope.winSearch__.center();
            this.$scope.winSearch__.open();
        };
        SearchBox.prototype.getSchema = function () {
            return this.options.schema[this.$scope.currentCondition.name];
        };
        SearchBox.OPS = ["=", "!=", ">", "<", ">=", "<=", "in", "not in", "is null", "is not null", "like", "not like"];
        SearchBox.TAG_OPS = ['in', 'not in'];
        SearchBox.USER_TAG_CONDITION_NAME = '__userTag__';
        return SearchBox;
    })();
    Directive.SearchBox = SearchBox;
    var GridDoubleClick = (function () {
        function GridDoubleClick() {
            this.scope = false;
            this.restrict = 'EA';
            this.replace = false;
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                var method = $scope[$attrs.zGridDoubleClick];
                var grid = $($element);
                grid.delegate("tbody>tr", "dblclick", function (e) {
                    Utils.safeApply($scope, function () {
                        if (Utils.notNullnotUndefined(method)) {
                            method(e);
                        }
                    });
                });
            };
        }
        return GridDoubleClick;
    })();
    Directive.GridDoubleClick = GridDoubleClick;
    var SortByData = (function () {
        function SortByData() {
        }
        SortByData.prototype.isValid = function () {
            return Utils.notNullnotUndefined(this.field);
        };
        SortByData.prototype.toString = function () {
            if (!this.isValid()) {
                return 'Sort By';
            }
            return Utils.sprintf('{0}:{1}', this.field, this.direction);
        };
        return SortByData;
    })();
    Directive.SortByData = SortByData;
    var SortBy = (function () {
        function SortBy() {
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = "/static/templates/directives/sort.html";
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                $scope.funcShow = function (popover) {
                    popover.toggle();
                };
                var parent = $scope.$parent;
                var options = parent[$attrs.zOptions];
                var fields = [
                    {
                        name: SortBy.NO_SORT_BY_NAME,
                        value: '__null__'
                    }
                ];
                fields = fields.concat(options.fields);
                $scope.optionsSortBy__ = {
                    dataSource: new kendo.data.DataSource({
                        data: fields
                    }),
                    dataTextField: 'name',
                    dataValueField: 'value'
                };
                $scope.field = fields[0].value;
                $scope.direction = "desc";
                $scope.buttonName = "Sort By";
                $scope.funcSortByConfirm = function (popover) {
                    popover.toggle();
                    var ret = new SortByData();
                    ret.direction = $scope.direction;
                    ret.field = $scope.field == '__null__' ? null : $scope.field;
                    $scope.buttonName = ret.toString();
                    options.done(ret);
                };
            };
        }
        SortBy.NO_SORT_BY_NAME = '-- No Sort --';
        return SortBy;
    })();
    Directive.SortBy = SortBy;
    var DeleteConfirmOptions = (function () {
        function DeleteConfirmOptions() {
        }
        return DeleteConfirmOptions;
    })();
    Directive.DeleteConfirmOptions = DeleteConfirmOptions;
    var DeleteConfirmImpl = (function () {
        function DeleteConfirmImpl($scope, $attrs, $element) {
            this.$scope = $scope;
            var options = $scope.$parent[$attrs.zOptions];
            $scope.optionsDelete__ = {
                animation: false,
                modal: true,
                draggable: false,
                resizable: false,
                width: "500px"
            };
            $scope.title = options.title;
            $scope.description = options.description;
            if (Utils.notNullnotUndefined(options.html)) {
                var desc = $element.find('#description');
                var el = $(options.html);
                desc.append(el);
            }
            $scope.confirm = function () {
                options.confirm();
                $scope.winDelete__.close();
            };
            $scope.cancel = function () {
                var c = options.cancel;
                if (Utils.notNullnotUndefined(c)) {
                    c();
                }
                $scope.winDelete__.close();
            };
        }
        DeleteConfirmImpl.prototype.open = function () {
            this.$scope.ok = null;
            this.$scope.winDelete__.center();
            this.$scope.winDelete__.open();
        };
        return DeleteConfirmImpl;
    })();
    var DeleteConfirm = (function () {
        function DeleteConfirm() {
            this.scope = true;
            this.replace = true;
            this.restrict = 'EA';
            this.templateUrl = '/static/templates/directives/deleteConfirm.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                $scope.$parent[$attrs.zDeleteConfirm] = new DeleteConfirmImpl($scope, $attrs, $element);
            };
        }
        return DeleteConfirm;
    })();
    Directive.DeleteConfirm = DeleteConfirm;
    var ConfirmBoxImpl = (function () {
        function ConfirmBoxImpl($scope, $attrs, $element) {
            this.$scope = $scope;
            var options = this.options = $scope.$parent[$attrs.zOptions];
            $scope.optionsConfirmBox__ = {
                animation: false,
                modal: true,
                draggable: false,
                resizable: false,
                width: Utils.notNullnotUndefined(options.width) ? options.width : '500px'
            };
            $scope.btnType = Utils.notNullnotUndefined(options.btnType) ? options.btnType : 'btn-primary';
            $scope.title = options.title;
            if (Utils.notNullnotUndefined(options.html)) {
                var desc = $element.find('#description');
                var el = $(options.html);
                desc.append(el);
            }
            $scope.confirm = function () {
                options.confirm();
                $scope.confirmBox__.close();
            };
            $scope.canProceed = function () {
                if (Utils.notNullnotUndefined(options.canProceed)) {
                    return options.canProceed();
                }
                return true;
            };
            $scope.cancel = function () {
                var c = options.cancel;
                if (Utils.notNullnotUndefined(c)) {
                    c();
                }
                $scope.confirmBox__.close();
            };
        }
        ConfirmBoxImpl.prototype.open = function () {
            if (Utils.notNullnotUndefined(this.options.description)) {
                this.$scope.description = this.options.description();
            }
            this.$scope.confirmBox__.center();
            this.$scope.confirmBox__.open();
        };
        return ConfirmBoxImpl;
    })();
    var ConfirmBox = (function () {
        function ConfirmBox() {
            this.scope = true;
            this.restrict = 'EA';
            this.replace = true;
            this.templateUrl = '/static/templates/directives/confirmBox.html';
            this.link = function ($scope, $element, $attrs, $ctrl, $transclude) {
                $scope.$parent[$attrs.zConfirm] = new ConfirmBoxImpl($scope, $attrs, $element);
            };
        }
        return ConfirmBox;
    })();
    Directive.ConfirmBox = ConfirmBox;
})(Directive || (Directive = {}));
angular.module('root')
    .directive("zPanelHeaderIn", function () {
    return new Directive.PanelHeaderIn();
}).directive('zPopover', function () {
    return new Directive.Popover();
}).directive('zSearch', ['$compile', function ($compile) {
        return new Directive.SearchBox($compile);
    }]).directive('zGridDoubleClick', function () {
    return new Directive.GridDoubleClick();
}).directive('zSortBy', function () {
    return new Directive.SortBy();
}).directive('zDeleteConfirm', function () {
    return new Directive.DeleteConfirm();
}).directive('zConfirm', function () {
    return new Directive.ConfirmBox();
}).filter('size', [function () {
        return Utils.toSizeString;
    }]).filter('HZ', [function () {
        return Utils.toHZString;
    }]).filter('percent', [function () {
        return Utils.toPercentageString;
    }]).filter('commas', [function () {
        return Utils.commaString;
    }]);
